import{parse as e}from"fast-querystring";import{mapEarlyResponse as r,mapResponse as t,mapCompactResponse as s}from"./handler";import{NotFoundError as n,ValidationError as a,InternalServerError as o,ERROR_CODE as c}from"./error";let i=new Headers,l=RegExp(" (\\w+) = context","g");export const hasReturn=e=>{let r=e.indexOf(")");return 61===e.charCodeAt(r+2)&&123!==e.charCodeAt(r+5)||e.includes("return")};let f=e=>({composeValidation:(r,t=`c.${r}`)=>e?`c.set.status = 400; throw new ValidationError(
'${r}',
${r},
${t}
)`:`c.set.status = 400; return new ValidationError(
	'${r}',
	${r},
	${t}
).toResponse(c.set.headers)`,composeResponseValidation:(r="r")=>e?`throw new ValidationError(
'response',
response[c.set.status],
${r}
)`:`return new ValidationError(
'response',
response[c.set.status],
${r}
).toResponse(c.set.headers)`});export const isFnUse=(e,r)=>{r=(r=r.trimStart()).replaceAll(/^async /g,"");let t=40===r.charCodeAt(0)||r.startsWith("function")?r.slice(r.indexOf("(")+1,r.indexOf(")")):r.slice(0,r.indexOf("=")-1);if(""===t)return!1;if(123===t.charCodeAt(0))return!!t.includes(e);if(r.match(RegExp(`${t}(.${e}|\\["${e}"\\])`)))return!0;let s=[t];for(let e of r.matchAll(l))s.push(e[1]);let n=RegExp(`{.*?} = (${s.join("|")})`,"g");for(let[t]of r.matchAll(n))if(t.includes(`{ ${e}`)||t.includes(`, ${e}`))return!0;return!1};export const findElysiaMeta=(e,r,t=[],s="")=>{if("object"===r.type){let n=r.properties;for(let r in n){let a=n[r],o=s?s+"."+r:r;if("object"===a.type){findElysiaMeta(e,a,t,o);continue}if(a.anyOf){for(let r of a.anyOf)findElysiaMeta(e,r,t,o);continue}a.elysiaMeta===e&&t.push(o)}return 0===t.length?null:t}return r?.elysiaMeta===e?(s&&t.push(s),"root"):null};let u=e=>{if(!e)return;let r=e?.schema;if(r&&"anyOf"in r){let e=!1,t=r.anyOf[0].type;for(let s of r.anyOf)if(s.type!==t){e=!0;break}if(!e)return t}},d=/(?:return|=>) \S*\(/g;export const isAsync=e=>{if("AsyncFunction"===e.constructor.name)return!0;let r=e.toString();return!!r.match(d)};export const composeHandler=({method:l,hooks:d,validator:p,handler:y,handleError:h,meta:$,onRequest:m,config:b})=>{let q=b.forceErrorEncapsulation||d.error.length>0||"undefined"==typeof Bun||d.onResponse.length>0,{composeValidation:E,composeResponseValidation:g}=f(q),R=d.onResponse.length?`
;(async () => {${d.onResponse.map((e,r)=>`await res${r}(c)`).join(";")}})();
`:"",w=q?"try {\n":"",x=p||"GET"!==l?[y,...d.transform,...d.beforeHandle,...d.afterHandle].map(e=>e.toString()):[],k="GET"!==l&&"none"!==d.type&&(!!p.body||!!d.type||x.some(e=>isFnUse("body",e))),H=p.headers||x.some(e=>isFnUse("headers",e));H&&(w+=i.toJSON?`c.headers = c.request.headers.toJSON()
`:`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`);let A=p.query||x.some(e=>isFnUse("query",e));A&&(w+=`const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`);let O=x.some(e=>isFnUse("set",e))||m.some(e=>isFnUse("set",e.toString())),v=k||isAsync(y)||d.parse.length>0||d.afterHandle.some(isAsync)||d.beforeHandle.some(isAsync)||d.transform.some(isAsync);if(k){let e=u(p?.body);if(d.type||e){if(d.type)switch(d.type){case"application/json":w+="c.body = await c.request.json();";break;case"text/plain":w+="c.body = await c.request.text();";break;case"application/x-www-form-urlencoded":w+="c.body = parseQuery(await c.request.text());";break;case"application/octet-stream":w+="c.body = await c.request.arrayBuffer();";break;case"multipart/form-data":w+=`c.body = {}

					const form = await c.request.formData()
					for (const key of form.keys()) {
						if (c.body[key])
							continue

						const value = form.getAll(key)
						if (value.length === 1)
							c.body[key] = value[0]
						else c.body[key] = value
					}`}else if(e){let r=p?.body?.schema;"object"===e?"URLEncoded"===r.elysiaMeta?w+="c.body = parseQuery(await c.request.text())":p.body.Code().includes("custom('File")?w+=`c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue
		
								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}`:w+="c.body = JSON.parse(await c.request.text())":w+="c.body = await c.request.text()"}d.parse.length&&(w+="}}")}else{if(w+="\n"+(H?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')")+`
            if (contentType) {
				const index = contentType.indexOf(';')
				if (index !== -1) contentType = contentType.substring(0, index)
`,d.parse.length){w+=`let used = false
`;for(let e=0;e<d.parse.length;e++){let r=`bo${e}`;0!==e&&(w+=`if(!used) {
`),w+=`let ${r} = parse[${e}](c, contentType);if(${r} instanceof Promise) ${r} = await ${r};
						if(${r} !== undefined) { c.body = ${r}; used = true }
`,0!==e&&(w+="}")}w+="if (!used)"}w+=`switch (contentType) {
			case 'application/json':
				c.body = await c.request.json()
				break

			case 'text/plain':
				c.body = await c.request.text()
				break

			case 'application/x-www-form-urlencoded':
				c.body = parseQuery(await c.request.text())
				break

			case 'application/octet-stream':
				c.body = await c.request.arrayBuffer();
				break

			case 'multipart/form-data':
				c.body = {}

				const form = await c.request.formData()
				for (const key of form.keys()) {
					if (c.body[key])
						continue

					const value = form.getAll(key)
					if (value.length === 1)
						c.body[key] = value[0]
					else c.body[key] = value
				}

				break
			}
		}
`}w+="\n"}if(p.params){let e=findElysiaMeta("Numeric",p.params.schema);if(e){if("object"==typeof e)for(let r of e)w+=`if(c.params.${r}) c.params.${r} = +c.params.${r};`;w+="\n"}}if(p.query){let e=findElysiaMeta("Numeric",p.query.schema);if(e){if("object"==typeof e)for(let r of e)w+=`if(c.query.${r}) c.query.${r} = +c.query.${r};`;w+="\n"}}if(p.headers){let e=findElysiaMeta("Numeric",p.headers.schema);if(e){if("object"==typeof e)for(let r of e)w+=`c.headers.${r} = +c.headers.${r};`;w+="\n"}}if(p.body){let e=findElysiaMeta("Numeric",p.body.schema);if(e){switch(typeof e){case"string":w+="c.body = +c.body;";break;case"object":for(let r of e)w+=`c.body.${r} = +c.body.${r};`}w+="\n"}let r=findElysiaMeta("Files",p.body.schema);if(r){if("object"==typeof r)for(let e of r)w+=`if(!Array.isArray(c.body.${e})) c.body.${e} = [c.body.${e}];`;w+="\n"}}if(d?.transform)for(let e=0;e<d.transform.length;e++){let r=d.transform[e];"derive"===r.$elysia?w+=isAsync(d.transform[e])?`Object.assign(c, await transform[${e}](c));`:`Object.assign(c, transform[${e}](c));`:w+=isAsync(d.transform[e])?`await transform[${e}](c);`:`transform[${e}](c);`}if(p&&(p.headers&&(w+=`
                if (headers.Check(c.headers) === false) {
                    ${E("headers")}
				}
        `),p.params&&(w+=`if(params.Check(c.params) === false) { ${E("params")} }`),p.query&&(w+=`if(query.Check(c.query) === false) { ${E("query")} }`),p.body&&(w+=`if(body.Check(c.body) === false) { ${E("body")} }`)),d?.beforeHandle)for(let e=0;e<d.beforeHandle.length;e++){let r=`be${e}`,t=hasReturn(d.beforeHandle[e].toString());if(t){if(w+=(isAsync(d.beforeHandle[e])?`let ${r} = await beforeHandle[${e}](c);
`:`let ${r} = beforeHandle[${e}](c);
`)+`if(${r} !== undefined) {
`,d?.afterHandle)for(let e=0;e<d.afterHandle.length;e++){let t=hasReturn(d.afterHandle[e].toString());if(t){let t=`af${e}`;w+=(isAsync(d.afterHandle[e])?`const ${t} = await afterHandle[${e}](c, ${r});
`:`const ${t} = afterHandle[${e}](c, ${r});
`)+`if(${t} !== undefined) { ${r} = ${t} }
`}else w+=isAsync(d.afterHandle[e])?`await afterHandle[${e}](c, ${r});
`:`afterHandle[${e}](c, ${r});
`}p.response&&(w+=`if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
							${g(r)}
					}
`),w+=`return mapEarlyResponse(${r}, c.set)}
`}else w+=isAsync(d.beforeHandle[e])?`await beforeHandle[${e}](c);
`:`beforeHandle[${e}](c);
`}if(d?.afterHandle.length){w+=isAsync(y)?`let r = await handler(c);
`:`let r = handler(c);
`;for(let e=0;e<d.afterHandle.length;e++){let r=`af${e}`,t=hasReturn(d.afterHandle[e].toString());t?(w+=isAsync(d.afterHandle[e])?`let ${r} = await afterHandle[${e}](c, r)
`:`let ${r} = afterHandle[${e}](c, r)
`,p.response?w+=`if(${r} !== undefined) {if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
						${g(r)}
					}
${r} = mapEarlyResponse(${r}, c.set)
if(${r}) return ${r};
}`:w+=`if(${r}) return ${r};
`):w+=isAsync(d.afterHandle[e])?`await afterHandle[${e}](c, r)
`:`afterHandle[${e}](c, r)
`}p.response&&(w+=`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${g()}
			}
`),O?w+=`return mapResponse(r, c.set)
`:w+=`return mapCompactResponse(r)
`}else if(p.response)w+=(isAsync(y)?`const r = await handler(c);
`:`const r = handler(c);
`)+`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${g()}
			}
`,O?w+=`return mapResponse(r, c.set)
`:w+=`return mapCompactResponse(r)
`;else{let e=isAsync(y)?"await handler(c) ":"handler(c)";O?w+=`return mapResponse(${e}, c.set)
`:w+=`return mapCompactResponse(${e})
`}q&&(w+=`
} catch(error) {
	

	${v?"":"return (async () => {"}
		const set = c.set

		if (!set.status || set.status < 300) set.status = 500

		${d.error.length?`for (let i = 0; i < handleErrors.length; i++) {
				let handled = handleErrors[i]({
					request: c.request,
					error: error,
					set,
					code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				})
				if (handled instanceof Promise) handled = await handled

				const response = mapEarlyResponse(handled, set)
				if (response) return response
			}`:""}

		return handleError(c.request, error, set)
	${v?"":"})()"}
} finally {
	${R}
}`),w=`const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		meta,
		ERROR_CODE
	} = hooks

	${d.onResponse.length?`const ${d.onResponse.map((e,r)=>`res${r} = onResponse[${r}]`).join(",")}`:""}

	return ${v?"async":""} function(c) {
		${$?'c["schema"] = meta["schema"]; c["defs"] = meta["defs"];':""}
		${w}
	}`;let j=Function("hooks",w);return j({handler:y,hooks:d,validator:p,handleError:h,utils:{mapResponse:t,mapCompactResponse:s,mapEarlyResponse:r,parseQuery:e},error:{NotFoundError:n,ValidationError:a,InternalServerError:o},meta:$,ERROR_CODE:c})};export const composeGeneralHandler=e=>{let t="";for(let r of Object.keys(e.decorators))t+=`,${r}: app.decorators.${r}`;let{router:s,staticRouter:a}=e,o=`
	const route = find(request.method, path) ${s.root.ALL?'?? find("ALL", path)':""}
	if (route === null)
		return ${e.event.error.length?`handleError(
			request,
			notFound,
			ctx.set
		)`:`new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`,c="";for(let[e,{code:r,all:t}]of Object.entries(a.map))c+=`case '${e}':
switch(request.method) {
${r}
${t??`default: ${o}`}}

`;let i=`const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError
	} = data

	const notFound = new NotFoundError()

	${e.event.request.length?"const onRequest = app.event.request":""}

	${a.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${e.event.error.length?"":"const error404 = notFound.message.toString()"}

	return function(request) {
	`;if(e.event.request.length){i+=`
			const ctx = {
				request,
				store,
				set: {
					headers: {},
					status: 200
				}
				${t}
			}

			try {
`;for(let r=0;r<e.event.request.length;r++){let t=hasReturn(e.event.request[r].toString());i+=t?`const response = mapEarlyResponse(
					onRequest[${r}](ctx),
					ctx.set
				)
				if (response) return response
`:`mapEarlyResponse(onRequest[${r}](ctx), ctx.set);`}i+=`} catch (error) {
			return handleError(request, error, ctx.set)
		}
		
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`}else i+=`
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${t}
		}`;return i+=`
		switch(path) {
			${c}

			default:
				${o}
		}
	}`,e.handleError=composeErrorHandler(e),Function("data",i)({app:e,mapEarlyResponse:r,NotFoundError:n})};export const composeErrorHandler=e=>{let r=`const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${e.event.error.find(isAsync)?"async":""} function(request, error, set) {`;for(let t=0;t<e.event.error.length;t++){let s=e.event.error[t],n=`${isAsync(s)?"await ":""}onError[${t}]({
			request,
			code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
			error,
			set
		})`;hasReturn(s.toString())?r+=`const r${t} = ${n}; if(r${t} !== undefined) return mapResponse(r${t}, set)
`:r+=n+"\n"}return Function("inject",r+=`if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`)({app:e,mapResponse:t,ERROR_CODE:c})};