{
  "version": 3,
  "sources": ["../../node_modules/@sinclair/typebox/typebox.js", "../../node_modules/@sinclair/typebox/system/system.js", "../../node_modules/@sinclair/typebox/system/index.js", "../../node_modules/@sinclair/typebox/value/guard.js", "../../node_modules/@sinclair/typebox/value/hash.js", "../../node_modules/@sinclair/typebox/errors/errors.js", "../../node_modules/@sinclair/typebox/errors/index.js", "../../node_modules/@sinclair/typebox/value/pointer.js", "../../node_modules/@sinclair/typebox/value/clone.js", "../../node_modules/@sinclair/typebox/value/delta.js", "../../node_modules/@sinclair/typebox/value/mutate.js", "../../node_modules/@sinclair/typebox/value/equal.js", "../../node_modules/@sinclair/typebox/value/check.js", "../../node_modules/@sinclair/typebox/value/create.js", "../../node_modules/@sinclair/typebox/value/cast.js", "../../node_modules/@sinclair/typebox/value/convert.js", "../../node_modules/@sinclair/typebox/value/value.js", "../../node_modules/@sinclair/typebox/value/index.js", "../../node_modules/@sinclair/typebox/compiler/compiler.js", "../../node_modules/@sinclair/typebox/compiler/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/fast-querystring/lib/parse.js", "../../node_modules/fast-querystring/lib/internals/querystring.js", "../../node_modules/fast-querystring/lib/stringify.js", "../../node_modules/fast-querystring/lib/index.js", "../../node_modules/memoirist/dist/index.js", "../../src/utils.ts", "../../node_modules/mergician/dist/mergician.mjs", "../../src/utils.ts", "../../src/utils.ts", "../../src/compose.ts", "../../src/handler.ts", "../../src/error.ts", "../../src/compose.ts", "../../src/ws/index.ts", "../../src/dynamic-handle.ts", "../../src/custom-types.ts", "../../src/index.ts"],
  "sourcesContent": [
    "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Readonly = Symbol.for('TypeBox.Readonly');\nexports.Optional = Symbol.for('TypeBox.Optional');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Deletes a registered type */\n    function Delete(kind) {\n        return map.delete(kind);\n    }\n    TypeRegistry.Delete = Delete;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Deletes a registered format */\n    function Delete(format) {\n        return map.delete(format);\n    }\n    FormatRegistry.Delete = Delete;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// ValueGuard\n// --------------------------------------------------------------------------\nvar ValueGuard;\n(function (ValueGuard) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    ValueGuard.IsObject = IsObject;\n    function IsArray(value) {\n        return Array.isArray(value);\n    }\n    ValueGuard.IsArray = IsArray;\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    ValueGuard.IsBoolean = IsBoolean;\n    function IsNull(value) {\n        return value === null;\n    }\n    ValueGuard.IsNull = IsNull;\n    function IsUndefined(value) {\n        return value === undefined;\n    }\n    ValueGuard.IsUndefined = IsUndefined;\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    ValueGuard.IsBigInt = IsBigInt;\n    function IsNumber(value) {\n        return typeof value === 'number';\n    }\n    ValueGuard.IsNumber = IsNumber;\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    ValueGuard.IsString = IsString;\n})(ValueGuard || (exports.ValueGuard = ValueGuard = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema) {\n        super('TypeGuard: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (!ValueGuard.IsString(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsOptionalBigInt(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n    }\n    function IsOptionalNumber(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n    }\n    function IsOptionalBoolean(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n    }\n    function IsOptionalString(value) {\n        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n    }\n    function IsOptionalPattern(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return ValueGuard.IsUndefined(value) || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */\n    function TAny(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Any') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */\n    function TArray(schema) {\n        return (TKindOf(schema, 'Array') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems) &&\n            IsOptionalSchema(schema.contains) &&\n            IsOptionalNumber(schema.minContains) &&\n            IsOptionalNumber(schema.maxContains));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TAsyncIterator */\n    function TAsyncIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'AsyncIterator') &&\n            schema.type === 'AsyncIterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TAsyncIterator = TAsyncIterator;\n    /** Returns true if the given schema is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'BigInt') &&\n            schema.type === 'bigint' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.multipleOf) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.exclusiveMaximum));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Boolean') &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Constructor') &&\n            schema.type === 'constructor' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */\n    function TDate(schema) {\n        return (TKindOf(schema, 'Date') &&\n            schema.type === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Function') &&\n            schema.type === 'function' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */\n    function TInteger(schema) {\n        return (TKindOf(schema, 'Integer') &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Intersect') &&\n            ValueGuard.IsArray(schema.allOf) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if ('type' in schema && schema.type !== 'object') {\n            return false;\n        }\n        for (const inner of schema.allOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TIterator */\n    function TIterator(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Iterator') &&\n            schema.type === 'Iterator' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items));\n    }\n    TypeGuard.TIterator = TIterator;\n    /** Returns true if the given schema is a TKind with the given name. */\n    function TKindOf(schema, kind) {\n        return TKind(schema) && schema[exports.Kind] === kind;\n    }\n    TypeGuard.TKindOf = TKindOf;\n    /** Returns true if the given schema is TKind */\n    function TKind(schema) {\n        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral<string> */\n    function TLiteralString(schema) {\n        return TLiteral(schema) && ValueGuard.IsString(schema.const);\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given schema is TLiteral<number> */\n    function TLiteralNumber(schema) {\n        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given schema is TLiteral<boolean> */\n    function TLiteralBoolean(schema) {\n        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given schema is TLiteral */\n    function TLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Literal') &&\n            IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) ||\n            ValueGuard.IsNumber(schema.const) ||\n            ValueGuard.IsString(schema.const)));\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */\n    function TNever(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Never') &&\n            ValueGuard.IsObject(schema.not) &&\n            Object.getOwnPropertyNames(schema.not).length === 0);\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Not') &&\n            TSchema(schema.not));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Null') &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */\n    function TNumber(schema) {\n        return (TKindOf(schema, 'Number') &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */\n    function TObject(schema) {\n        if (!(TKindOf(schema, 'Object') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsObject(schema.properties) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)) {\n            if (!IsControlCharacterFree(key))\n                return false;\n            if (!TSchema(value))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Promise') &&\n            schema.type === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Record') &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            ValueGuard.IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.getOwnPropertyNames(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Ref') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */\n    function TString(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'String') &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Symbol') &&\n            schema.type === 'symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'TemplateLiteral') &&\n            schema.type === 'string' &&\n            ValueGuard.IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'This') &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Tuple') &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            ValueGuard.IsNumber(schema.minItems) &&\n            ValueGuard.IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0) {\n            return true;\n        }\n        if (!ValueGuard.IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Undefined') &&\n            schema.type === 'undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKindOf(schema, 'Union') &&\n            ValueGuard.IsArray(schema.anyOf) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUint8Array */\n    function TUint8Array(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Uint8Array') &&\n            schema.type === 'Uint8Array' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minByteLength) &&\n            IsOptionalNumber(schema.maxByteLength));\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Unknown') &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */\n    function TUnsafe(schema) {\n        return TKindOf(schema, 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKindOf(schema, 'Void') &&\n            schema.type === 'void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the Readonly modifier */\n    function TReadonly(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */\n    function TOptional(schema) {\n        return ValueGuard.IsObject(schema) && schema[exports.Optional] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */\n    function TSchema(schema) {\n        return (ValueGuard.IsObject(schema) &&\n            (TAny(schema) ||\n                TArray(schema) ||\n                TBoolean(schema) ||\n                TBigInt(schema) ||\n                TAsyncIterator(schema) ||\n                TConstructor(schema) ||\n                TDate(schema) ||\n                TFunction(schema) ||\n                TInteger(schema) ||\n                TIntersect(schema) ||\n                TIterator(schema) ||\n                TLiteral(schema) ||\n                TNever(schema) ||\n                TNot(schema) ||\n                TNull(schema) ||\n                TNumber(schema) ||\n                TObject(schema) ||\n                TPromise(schema) ||\n                TRecord(schema) ||\n                TRef(schema) ||\n                TString(schema) ||\n                TSymbol(schema) ||\n                TTemplateLiteral(schema) ||\n                TThis(schema) ||\n                TTuple(schema) ||\n                TUndefined(schema) ||\n                TUnion(schema) ||\n                TUint8Array(schema) ||\n                TUnknown(schema) ||\n                TUnsafe(schema) ||\n                TVoid(schema) ||\n                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === 'Undefined')\n            return true;\n        if (schema[exports.Kind] === 'Not') {\n            return !Check(schema.not);\n        }\n        if (schema[exports.Kind] === 'Intersect') {\n            const intersect = schema;\n            return intersect.allOf.every((schema) => Check(schema));\n        }\n        if (schema[exports.Kind] === 'Union') {\n            const union = schema;\n            return union.anyOf.some((schema) => Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // StructuralRight\n    // --------------------------------------------------------------------------\n    function IsStructuralRight(right) {\n        // prettier-ignore\n        return (TypeGuard.TNever(right) ||\n            TypeGuard.TIntersect(right) ||\n            TypeGuard.TUnion(right) ||\n            TypeGuard.TUnknown(right) ||\n            TypeGuard.TAny(right));\n    }\n    function StructuralRight(left, right) {\n        if (TypeGuard.TNever(right))\n            return TNeverRight(left, right);\n        if (TypeGuard.TIntersect(right))\n            return TIntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return TUnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return TUnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return TAnyRight(left, right);\n        throw Error('TypeExtends: StructuralRight');\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function TAnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TAny(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return TIntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function TArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function TArray(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // AsyncIterator\n    // --------------------------------------------------------------------------\n    function TAsyncIterator(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (!TypeGuard.TAsyncIterator(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function TBigInt(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function TBooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const))\n            return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TBoolean(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function TConstructor(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function TDate(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function TFunction(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (!TypeGuard.TFunction(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function TIntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const))\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TInteger(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function TIntersectRight(left, right) {\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TIntersect(left, right) {\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Iterator\n    // --------------------------------------------------------------------------\n    function TIterator(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (!TypeGuard.TIterator(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function TLiteral(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        if (TypeGuard.TString(right))\n            return TStringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return TNumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return TIntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return TBooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function TNeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function TNever(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapTNot(schema) {\n        let [current, depth] = [schema, 0];\n        while (true) {\n            if (!TypeGuard.TNot(current))\n                break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function TNot(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        if (TypeGuard.TNot(left))\n            return Visit(UnwrapTNot(left), right);\n        if (TypeGuard.TNot(right))\n            return Visit(left, UnwrapTNot(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for Not`);\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function TNull(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function TNumberRight(left, right) {\n        if (TypeGuard.TLiteralNumber(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TNumber(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return Object.getOwnPropertyNames(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False)\n            return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))\n            return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function TObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteralString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function TObject(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        if (!TypeGuard.TObject(right))\n            return TypeExtendsResult.False;\n        for (const key of Object.getOwnPropertyNames(right.properties)) {\n            if (!(key in left.properties))\n                return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function TPromise(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties)\n            return exports.Type.String();\n        throw Error('TypeExtends: Cannot get record key');\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternStringExact];\n        throw Error('TypeExtends: Cannot get record value');\n    }\n    function TRecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of Object.getOwnPropertyNames(left.properties)) {\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function TRecord(left, right) {\n        const Value = RecordValue(left);\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (!TypeGuard.TRecord(right))\n            return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function TStringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const))\n            return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TString(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function TSymbol(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TTemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        if (TypeGuard.TTemplateLiteral(left))\n            return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right))\n            return Visit(left, TemplateLiteralResolver.Resolve(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function IsArrayOfTuple(left, right) {\n        // prettier-ignore\n        return (TypeGuard.TArray(right) &&\n            left.items !== undefined &&\n            left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True));\n    }\n    function TTupleRight(left, right) {\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        return TypeExtendsResult.False;\n    }\n    function TTuple(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right))\n            return TypeExtendsResult.False;\n        if ((ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)))\n            return TypeExtendsResult.False;\n        if (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items))\n            return TypeExtendsResult.True;\n        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function TUint8Array(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function TUndefined(left, right) {\n        if (IsStructuralRight(right))\n            return StructuralRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return TRecordRight(left, right);\n        if (TypeGuard.TVoid(right))\n            return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function TUnionRight(left, right) {\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TUnion(left, right) {\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function TUnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function TUnknown(left, right) {\n        if (TypeGuard.TNever(right))\n            return TNeverRight(left, right);\n        if (TypeGuard.TIntersect(right))\n            return TIntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return TUnionRight(left, right);\n        if (TypeGuard.TAny(right))\n            return TAnyRight(left, right);\n        if (TypeGuard.TString(right))\n            return TStringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return TNumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return TIntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return TBooleanRight(left, right);\n        if (TypeGuard.TArray(right))\n            return TArrayRight(left, right);\n        if (TypeGuard.TTuple(right))\n            return TTupleRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function TVoid(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return TIntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return TUnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return TUnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return TAnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return TObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // Resolvable Types\n        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))\n            return TTemplateLiteral(left, right);\n        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))\n            return TNot(left, right);\n        // Standard Types\n        if (TypeGuard.TAny(left))\n            return TAny(left, right);\n        if (TypeGuard.TArray(left))\n            return TArray(left, right);\n        if (TypeGuard.TBigInt(left))\n            return TBigInt(left, right);\n        if (TypeGuard.TBoolean(left))\n            return TBoolean(left, right);\n        if (TypeGuard.TAsyncIterator(left))\n            return TAsyncIterator(left, right);\n        if (TypeGuard.TConstructor(left))\n            return TConstructor(left, right);\n        if (TypeGuard.TDate(left))\n            return TDate(left, right);\n        if (TypeGuard.TFunction(left))\n            return TFunction(left, right);\n        if (TypeGuard.TInteger(left))\n            return TInteger(left, right);\n        if (TypeGuard.TIntersect(left))\n            return TIntersect(left, right);\n        if (TypeGuard.TIterator(left))\n            return TIterator(left, right);\n        if (TypeGuard.TLiteral(left))\n            return TLiteral(left, right);\n        if (TypeGuard.TNever(left))\n            return TNever(left, right);\n        if (TypeGuard.TNull(left))\n            return TNull(left, right);\n        if (TypeGuard.TNumber(left))\n            return TNumber(left, right);\n        if (TypeGuard.TObject(left))\n            return TObject(left, right);\n        if (TypeGuard.TRecord(left))\n            return TRecord(left, right);\n        if (TypeGuard.TString(left))\n            return TString(left, right);\n        if (TypeGuard.TSymbol(left))\n            return TSymbol(left, right);\n        if (TypeGuard.TTuple(left))\n            return TTuple(left, right);\n        if (TypeGuard.TPromise(left))\n            return TPromise(left, right);\n        if (TypeGuard.TUint8Array(left))\n            return TUint8Array(left, right);\n        if (TypeGuard.TUndefined(left))\n            return TUndefined(left, right);\n        if (TypeGuard.TUnion(left))\n            return TUnion(left, right);\n        if (TypeGuard.TUnknown(left))\n            return TUnknown(left, right);\n        if (TypeGuard.TVoid(left))\n            return TVoid(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function ObjectType(value) {\n        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function ArrayType(value) {\n        return value.map((value) => Visit(value));\n    }\n    function Visit(value) {\n        if (ValueGuard.IsArray(value))\n            return ArrayType(value);\n        if (ValueGuard.IsObject(value))\n            return ObjectType(value);\n        return value;\n    }\n    /** Clones a type. */\n    function Clone(schema, options = {}) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema) => {\n            const { [exports.Optional]: _, ...clone } = TypeClone.Clone(schema);\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema) => TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema) => TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        const optional = IsIntersectOptional(schema.allOf);\n        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        const optional = IsUnionOptional(schema.anyOf);\n        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        if (schema[exports.Kind] === 'Intersect')\n            return ResolveIntersect(schema);\n        if (schema[exports.Kind] === 'Union')\n            return ResolveUnion(schema);\n        return schema;\n    }\n    function TIntersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema) => {\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function TUnion(schema, key) {\n        const resolved = schema.anyOf.map((schema) => Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function TObject(schema, key) {\n        const property = schema.properties[key];\n        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);\n    }\n    function TTuple(schema, key) {\n        const items = schema.items;\n        if (ValueGuard.IsUndefined(items))\n            return exports.Type.Never();\n        const element = items[key]; //\n        if (ValueGuard.IsUndefined(element))\n            return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        if (schema[exports.Kind] === 'Intersect')\n            return TIntersect(schema, key);\n        if (schema[exports.Kind] === 'Union')\n            return TUnion(schema, key);\n        if (schema[exports.Kind] === 'Object')\n            return TObject(schema, key);\n        if (schema[exports.Kind] === 'Tuple')\n            return TTuple(schema, key);\n        return exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key) => Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// Intrinsic\n// --------------------------------------------------------------------------\nvar Intrinsic;\n(function (Intrinsic) {\n    function Uncapitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toLowerCase()}${rest}`;\n    }\n    function Capitalize(value) {\n        const [first, rest] = [value.slice(0, 1), value.slice(1)];\n        return `${first.toUpperCase()}${rest}`;\n    }\n    function Uppercase(value) {\n        return value.toUpperCase();\n    }\n    function Lowercase(value) {\n        return value.toLowerCase();\n    }\n    function IntrinsicTemplateLiteral(schema, mode) {\n        // note: template literals require special runtime handling as they are encoded in string patterns.\n        // This diverges from the mapped type which would otherwise map on the template literal kind.\n        const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n        const finite = TemplateLiteralFinite.Check(expression);\n        if (!finite)\n            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };\n        const strings = [...TemplateLiteralGenerator.Generate(expression)];\n        const literals = strings.map((value) => exports.Type.Literal(value));\n        const mapped = IntrinsicRest(literals, mode);\n        const union = exports.Type.Union(mapped);\n        return exports.Type.TemplateLiteral([union]);\n    }\n    function IntrinsicLiteral(value, mode) {\n        // prettier-ignore\n        return typeof value === 'string' ? (mode === 'Uncapitalize' ? Uncapitalize(value) :\n            mode === 'Capitalize' ? Capitalize(value) :\n                mode === 'Uppercase' ? Uppercase(value) :\n                    mode === 'Lowercase' ? Lowercase(value) :\n                        value) : value.toString();\n    }\n    function IntrinsicRest(schema, mode) {\n        if (schema.length === 0)\n            return [];\n        const [L, ...R] = schema;\n        return [Map(L, mode), ...IntrinsicRest(R, mode)];\n    }\n    function Visit(schema, mode) {\n        if (TypeGuard.TTemplateLiteral(schema))\n            return IntrinsicTemplateLiteral(schema, mode);\n        if (TypeGuard.TUnion(schema))\n            return exports.Type.Union(IntrinsicRest(schema.anyOf, mode));\n        if (TypeGuard.TLiteral(schema))\n            return exports.Type.Literal(IntrinsicLiteral(schema.const, mode));\n        return schema;\n    }\n    /** Applies an intrinsic string manipulation to the given type. */\n    function Map(schema, mode) {\n        return Visit(schema, mode);\n    }\n    Intrinsic.Map = Map;\n})(Intrinsic || (exports.Intrinsic = Intrinsic = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function TIntersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TUnion(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function TObject(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === 'Intersect')\n            return TIntersect(schema, callback);\n        if (schema[exports.Kind] === 'Union')\n            return TUnion(schema, callback);\n        if (schema[exports.Kind] === 'Object')\n            return TObject(schema, callback);\n        return schema;\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Clone(schema), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n    }\n    function TIntersect(schema, options) {\n        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n    }\n    function TUnion(schema, options) {\n        const sets = schema.anyOf.map((inner) => Visit(inner, options));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function TObject(schema, options) {\n        return Object.getOwnPropertyNames(schema.properties);\n    }\n    function TRecord(schema, options) {\n        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        if (TypeGuard.TIntersect(schema))\n            return TIntersect(schema, options);\n        if (TypeGuard.TUnion(schema))\n            return TUnion(schema, options);\n        if (TypeGuard.TObject(schema))\n            return TObject(schema, options);\n        if (TypeGuard.TRecord(schema))\n            return TRecord(schema, options);\n        return [];\n    }\n    /** Resolves an array of keys in this schema */\n    function ResolveKeys(schema, options) {\n        return [...new Set(Visit(schema, options))];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */\n    function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, { includePatterns: true });\n        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);\n        return `^(${pattern.join('|')})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */\n    function Resolve(schema) {\n        if (Array.isArray(schema))\n            return schema;\n        if (TypeGuard.TUnionLiteral(schema))\n            return schema.anyOf.map((schema) => schema.const.toString());\n        if (TypeGuard.TLiteral(schema))\n            return [schema.const];\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n            if (!TemplateLiteralFinite.Check(expression))\n                throw Error('KeyArrayResolver: Cannot resolve keys from infinite template expression');\n            return [...TemplateLiteralGenerator.Generate(expression)];\n        }\n        return [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n    function* TUnion(union) {\n        for (const schema of union.anyOf) {\n            if (schema[exports.Kind] === 'Union') {\n                yield* TUnion(schema);\n            }\n            else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */\n    function Resolve(union) {\n        return exports.Type.Union([...TUnion(union)], { ...union });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            return schema.pattern.slice(1, schema.pattern.length - 1);\n        }\n        else if (TypeGuard.TUnion(schema)) {\n            return `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})`;\n        }\n        else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        }\n        else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        }\n        else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        }\n        else if (TypeGuard.TNever(schema)) {\n            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');\n        }\n        else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        if (IsGroup(pattern))\n            return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern))\n            return Or(pattern);\n        if (IsPrecedenceAnd(pattern))\n            return And(pattern);\n        return { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        if (IsBoolean(expression))\n            return true;\n        if (IsNumber(expression) || IsString(expression))\n            return false;\n        if (expression.type === 'and')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'or')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'const')\n            return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === 'and')\n            return yield* And(expression);\n        if (expression.type === 'or')\n            return yield* Or(expression);\n        if (expression.type === 'const')\n            return yield* Const(expression);\n        throw Error('TemplateLiteralGenerator: Unknown expression');\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, '');\n        if (trim === 'boolean')\n            return yield exports.Type.Boolean();\n        if (trim === 'number')\n            return yield exports.Type.Number();\n        if (trim === 'bigint')\n            return yield exports.Type.BigInt();\n        if (trim === 'string')\n            return yield exports.Type.String();\n        const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));\n        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== '{') {\n            const L = exports.Type.Literal('$');\n            const R = ParseLiteral(template.slice(1));\n            return yield* [L, ...R];\n        }\n        for (let i = 2; i < template.length; i++) {\n            if (template[i] === '}') {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [...L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for (let i = 0; i < template.length; i++) {\n            if (template[i] === '$') {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [...ParseLiteral(template_dsl)];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Utility]` Discards a property key from the given schema */\n    Discard(schema, key) {\n        const { [key]: _, ...rest } = schema;\n        return rest;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates a Readonly and Optional property */\n    ReadonlyOptional(schema) {\n        return this.Readonly(this.Optional(schema));\n    }\n    /** `[Standard]` Creates a Readonly property */\n    Readonly(schema) {\n        return { ...TypeClone.Clone(schema), [exports.Readonly]: 'Readonly' };\n    }\n    /** `[Standard]` Creates an Optional property */\n    Optional(schema) {\n        return { ...TypeClone.Clone(schema), [exports.Optional]: 'Optional' };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Standard]` Creates an Array type */\n    Array(schema, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(schema) });\n    }\n    /** `[Standard]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Standard]` Intrinsic function to Capitalize LiteralString types */\n    Capitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Capitalize'), ...options };\n    }\n    /** `[Standard]` Creates a Composite object type */\n    Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });\n        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Standard]` Creates a Enum type */\n    Enum(item, options = {}) {\n        // prettier-ignore\n        const values = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const anyOf = values.map((value) => (ValueGuard.IsString(value) ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));\n        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });\n    }\n    /** `[Standard]` Creates a Conditional type */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n    Exclude(unionType, excludedMembers, options = {}) {\n        if (TypeGuard.TTemplateLiteral(unionType))\n            return this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options);\n        if (TypeGuard.TTemplateLiteral(excludedMembers))\n            return this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options);\n        if (TypeGuard.TUnion(unionType)) {\n            const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(unionType, options));\n        }\n    }\n    /** `[Standard]` Constructs a type by extracting from type all union members that are assignable to union */\n    Extract(type, union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(type))\n            return this.Extract(TemplateLiteralResolver.Resolve(type), union, options);\n        if (TypeGuard.TTemplateLiteral(union))\n            return this.Extract(type, TemplateLiteralResolver.Resolve(union), options);\n        if (TypeGuard.TUnion(type)) {\n            const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Clone(type, options) : this.Never(options));\n        }\n    }\n    /** `[Standard]` Returns an Indexed property type for the given keys */\n    Index(schema, unresolved, options = {}) {\n        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {\n            return TypeClone.Clone(schema.items, options);\n        }\n        else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {\n            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n            const cloned = items.map((schema) => TypeClone.Clone(schema));\n            return this.Union(cloned, options);\n        }\n        else {\n            const keys = KeyArrayResolver.Resolve(unresolved);\n            const clone = TypeClone.Clone(schema);\n            return IndexedAccessor.Resolve(clone, keys, options);\n        }\n    }\n    /** `[Standard]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    /** `[Standard]` Creates an Intersect type */\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema) => TypeClone.Clone(schema));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties) } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });\n        }\n        else {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact)\n                return this.Number(options);\n            if (pattern === exports.PatternStringExact)\n                return this.String(options);\n            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');\n        }\n        else if (TypeGuard.TTuple(schema)) {\n            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;\n            const literals = items.map((_, index) => exports.Type.Literal(index));\n            return this.Union(literals, options);\n        }\n        else if (TypeGuard.TArray(schema)) {\n            return this.Number(options);\n        }\n        else {\n            const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });\n            if (keys.length === 0)\n                return this.Never(options);\n            const literals = keys.map((key) => this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Standard]` Intrinsic function to Lowercase LiteralString types */\n    Lowercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Lowercase'), ...options };\n    }\n    /** `[Standard]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Standard]` Creates a Not type */\n    Not(schema, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', not: TypeClone.Clone(schema) });\n    }\n    /** `[Standard]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Standard]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Standard]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key]) }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });\n        }\n        else {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n        }\n    }\n    /** `[Standard]` Constructs a type whose keys are omitted from the given type */\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => !keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Standard]` Constructs a type where all properties are optional */\n    Partial(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(schema, (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Optional(object.properties[key]) };\n            }, {});\n            return this.Object(properties, this.Discard(object, 'required') /* object used as options to retain other constraints */);\n        }, options);\n    }\n    /** `[Standard]` Constructs a type whose keys are picked from the given type */\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema), (object) => {\n            if (ValueGuard.IsArray(object.required)) {\n                object.required = object.required.filter((key) => keys.includes(key));\n                if (object.required.length === 0)\n                    delete object.required;\n            }\n            for (const key of Object.getOwnPropertyNames(object.properties)) {\n                if (!keys.includes(key))\n                    delete object.properties[key];\n            }\n            return this.Create(object);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema) } });\n        }\n        else if (TypeGuard.TUnion(key)) {\n            const union = UnionResolver.Resolve(key);\n            if (TypeGuard.TUnionLiteral(union)) {\n                const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema) }), {});\n                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n            }\n            else\n                throw Error('StandardTypeBuilder: Record key of type union contains non-literal types');\n        }\n        else if (TypeGuard.TLiteral(key)) {\n            if (ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const)) {\n                return this.Object({ [key.const]: TypeClone.Clone(schema) }, options);\n            }\n            else\n                throw Error('StandardTypeBuilder: Record key of type literal is not of type string or number');\n        }\n        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [exports.PatternNumberExact]: TypeClone.Clone(schema) } });\n        }\n        else if (TypeGuard.TString(key)) {\n            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema) } });\n        }\n        else {\n            throw Error(`StandardTypeBuilder: Record key is an invalid type`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (ValueGuard.IsUndefined(options.$id))\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Standard]` Creates a Ref type. */\n    Ref(unresolved, options = {}) {\n        if (ValueGuard.IsString(unresolved))\n            return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved });\n        if (ValueGuard.IsUndefined(unresolved.$id))\n            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved.$id });\n    }\n    /** `[Standard]` Constructs a type where all properties are required */\n    Required(schema, options = {}) {\n        // prettier-ignore\n        return ObjectMap.Map(schema, (object) => {\n            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {\n                return { ...acc, [key]: this.Discard(object.properties[key], exports.Optional) };\n            }, {});\n            return this.Object(properties, object /* object used as options to retain other constraints  */);\n        }, options);\n    }\n    /** `[Standard]` Extracts the rest array from a Tuple */\n    Rest(schema) {\n        if (TypeGuard.TTuple(schema)) {\n            if (ValueGuard.IsUndefined(schema.items))\n                return [];\n            return schema.items.map((schema) => TypeClone.Clone(schema));\n        }\n        else {\n            return [TypeClone.Clone(schema)];\n        }\n    }\n    /** `[Standard]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Standard]` Creates a TemplateLiteral type */\n    TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = (ValueGuard.IsString(unresolved))\n            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))\n            : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Standard]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = items.map((item) => TypeClone.Clone(item));\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    /** `[Standard]` Intrinsic function to Uncapitalize LiteralString types */\n    Uncapitalize(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Uncapitalize'), ...options };\n    }\n    /** `[Standard]` Creates a Union type */\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        }\n        else {\n            const anyOf = union;\n            if (anyOf.length === 0)\n                return this.Never(options);\n            if (anyOf.length === 1)\n                return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema));\n            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Standard]` Creates a Unsafe type that will infers as the generic argument T */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n    /** `[Standard]` Intrinsic function to Uppercase LiteralString types */\n    Uppercase(schema, options = {}) {\n        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Uppercase'), ...options };\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a AsyncIterator type */\n    AsyncIterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'AsyncIterator', type: 'AsyncIterator', items: TypeClone.Clone(items) });\n    }\n    /** `[Extended]` Constructs a type by recursively unwrapping Promise types */\n    Awaited(schema, options = {}) {\n        const AwaitedRest = (rest) => {\n            if (rest.length === 0)\n                return rest;\n            const [L, ...R] = rest;\n            return [this.Awaited(L), ...AwaitedRest(R)];\n        };\n        // prettier-ignore\n        return (TypeGuard.TIntersect(schema) ? exports.Type.Intersect(AwaitedRest(schema.allOf)) :\n            TypeGuard.TUnion(schema) ? exports.Type.Union(AwaitedRest(schema.anyOf)) :\n                TypeGuard.TPromise(schema) ? this.Awaited(schema.item) :\n                    TypeClone.Clone(schema, options));\n    }\n    /** `[Extended]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'bigint' });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    /** `[Extended]` Creates a Constructor type */\n    Constructor(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns);\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter));\n        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'constructor', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'Date' });\n    }\n    /** `[Extended]` Creates a Function type */\n    Function(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter));\n        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'function', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor type */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates an Iterator type */\n    Iterator(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Iterator', type: 'Iterator', items: TypeClone.Clone(items) });\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[Extended]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'Promise', item: TypeClone.Clone(item) });\n    }\n    /** `[Extended]` Creates a String type */\n    RegExp(unresolved, options = {}) {\n        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern });\n    }\n    /**\n     * @deprecated Use `Type.RegExp`\n     */\n    RegEx(regex, options = {}) {\n        return this.RegExp(regex, options);\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function type */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'symbol' });\n    }\n    /** `[Extended]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'undefined' });\n    }\n    /** `[Extended]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'Uint8Array' });\n    }\n    /** `[Extended]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'void' });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema Type Builder with Static Resolution for TypeScript */\nexports.StandardType = new StandardTypeBuilder();\n/** JSON Schema Type Builder with Static Resolution for TypeScript */\nexports.Type = new ExtendedTypeBuilder();\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;\nconst Types = require(\"../typebox\");\nclass TypeSystemDuplicateTypeKind extends Error {\n    constructor(kind) {\n        super(`Duplicate type kind '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;\nclass TypeSystemDuplicateFormat extends Error {\n    constructor(kind) {\n        super(`Duplicate string format '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;\n/** Creates user defined types and formats and provides overrides for value checking behaviours */\nvar TypeSystem;\n(function (TypeSystem) {\n    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */\n    TypeSystem.ExactOptionalPropertyTypes = false;\n    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */\n    TypeSystem.AllowArrayObjects = false;\n    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */\n    TypeSystem.AllowNaN = false;\n    /** Sets whether `null` should validate for void types. The default is `false` */\n    TypeSystem.AllowVoidNull = false;\n    /** Creates a new type */\n    function Type(kind, check) {\n        if (Types.TypeRegistry.Has(kind))\n            throw new TypeSystemDuplicateTypeKind(kind);\n        Types.TypeRegistry.Set(kind, check);\n        return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });\n    }\n    TypeSystem.Type = Type;\n    /** Creates a new string format */\n    function Format(format, check) {\n        if (Types.FormatRegistry.Has(format))\n            throw new TypeSystemDuplicateFormat(format);\n        Types.FormatRegistry.Set(format, check);\n        return format;\n    }\n    TypeSystem.Format = Format;\n})(TypeSystem || (exports.TypeSystem = TypeSystem = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./system\"), exports);\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = void 0;\n// --------------------------------------------------------------------------\n// Iterators\n// --------------------------------------------------------------------------\n/** Returns true if this value is an async iterator */\nfunction IsAsyncIterator(value) {\n    return IsObject(value) && Symbol.asyncIterator in value;\n}\nexports.IsAsyncIterator = IsAsyncIterator;\n/** Returns true if this value is an iterator */\nfunction IsIterator(value) {\n    return IsObject(value) && Symbol.iterator in value;\n}\nexports.IsIterator = IsIterator;\n// --------------------------------------------------------------------------\n// Nominal\n// --------------------------------------------------------------------------\n/** Returns true if this value is a typed array */\nfunction IsTypedArray(value) {\n    return ArrayBuffer.isView(value);\n}\nexports.IsTypedArray = IsTypedArray;\n/** Returns true if this value is a Promise */\nfunction IsPromise(value) {\n    return value instanceof Promise;\n}\nexports.IsPromise = IsPromise;\n/** Returns true if the value is a Uint8Array */\nfunction IsUint8Array(value) {\n    return value instanceof Uint8Array;\n}\nexports.IsUint8Array = IsUint8Array;\n/** Returns true if this value is a Date */\nfunction IsDate(value) {\n    return value instanceof Date;\n}\nexports.IsDate = IsDate;\n// --------------------------------------------------------------------------\n// Standard\n// --------------------------------------------------------------------------\n/** Returns true if this value has this property key */\nfunction HasPropertyKey(value, key) {\n    return key in value;\n}\nexports.HasPropertyKey = HasPropertyKey;\n/** Returns true if this object is not an instance of any other type */\nfunction IsPlainObject(value) {\n    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === 'Object';\n}\nexports.IsPlainObject = IsPlainObject;\n/** Returns true of this value is an object type */\nfunction IsObject(value) {\n    return value !== null && typeof value === 'object';\n}\nexports.IsObject = IsObject;\n/** Returns true if this value is an array, but not a typed array */\nfunction IsArray(value) {\n    return Array.isArray(value) && !ArrayBuffer.isView(value);\n}\nexports.IsArray = IsArray;\n/** Returns true if this value is an undefined */\nfunction IsUndefined(value) {\n    return value === undefined;\n}\nexports.IsUndefined = IsUndefined;\n/** Returns true if this value is an null */\nfunction IsNull(value) {\n    return value === null;\n}\nexports.IsNull = IsNull;\n/** Returns true if this value is an boolean */\nfunction IsBoolean(value) {\n    return typeof value === 'boolean';\n}\nexports.IsBoolean = IsBoolean;\n/** Returns true if this value is an number */\nfunction IsNumber(value) {\n    return typeof value === 'number';\n}\nexports.IsNumber = IsNumber;\n/** Returns true if this value is an integer */\nfunction IsInteger(value) {\n    return IsNumber(value) && Number.isInteger(value);\n}\nexports.IsInteger = IsInteger;\n/** Returns true if this value is bigint */\nfunction IsBigInt(value) {\n    return typeof value === 'bigint';\n}\nexports.IsBigInt = IsBigInt;\n/** Returns true if this value is string */\nfunction IsString(value) {\n    return typeof value === 'string';\n}\nexports.IsString = IsString;\n/** Returns true if this value is a function */\nfunction IsFunction(value) {\n    return typeof value === 'function';\n}\nexports.IsFunction = IsFunction;\n/** Returns true if this value is a symbol */\nfunction IsSymbol(value) {\n    return typeof value === 'symbol';\n}\nexports.IsSymbol = IsSymbol;\n/** Returns true if this value is a value type such as number, string, boolean */\nfunction IsValueType(value) {\n    // prettier-ignore\n    return (IsBigInt(value) ||\n        IsBoolean(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsUndefined(value));\n}\nexports.IsValueType = IsValueType;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/hash\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueHashError extends Error {\n    constructor(value) {\n        super(`Hash: Unable to hash value`);\n        this.value = value;\n    }\n}\nexports.ValueHashError = ValueHashError;\n// --------------------------------------------------------------------------\n// ByteMarker\n// --------------------------------------------------------------------------\nvar ByteMarker;\n(function (ByteMarker) {\n    ByteMarker[ByteMarker[\"Undefined\"] = 0] = \"Undefined\";\n    ByteMarker[ByteMarker[\"Null\"] = 1] = \"Null\";\n    ByteMarker[ByteMarker[\"Boolean\"] = 2] = \"Boolean\";\n    ByteMarker[ByteMarker[\"Number\"] = 3] = \"Number\";\n    ByteMarker[ByteMarker[\"String\"] = 4] = \"String\";\n    ByteMarker[ByteMarker[\"Object\"] = 5] = \"Object\";\n    ByteMarker[ByteMarker[\"Array\"] = 6] = \"Array\";\n    ByteMarker[ByteMarker[\"Date\"] = 7] = \"Date\";\n    ByteMarker[ByteMarker[\"Uint8Array\"] = 8] = \"Uint8Array\";\n    ByteMarker[ByteMarker[\"Symbol\"] = 9] = \"Symbol\";\n    ByteMarker[ByteMarker[\"BigInt\"] = 10] = \"BigInt\";\n})(ByteMarker || (exports.ByteMarker = ByteMarker = {}));\n// --------------------------------------------------------------------------\n// State\n// --------------------------------------------------------------------------\nlet Accumulator = BigInt('14695981039346656037');\nconst [Prime, Size] = [BigInt('1099511628211'), BigInt('2') ** BigInt('64')];\nconst Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));\nconst F64 = new Float64Array(1);\nconst F64In = new DataView(F64.buffer);\nconst F64Out = new Uint8Array(F64.buffer);\n// --------------------------------------------------------------------------\n// Hashing Functions\n// --------------------------------------------------------------------------\nfunction ArrayType(value) {\n    FNV1A64(ByteMarker.Array);\n    for (const item of value) {\n        Visit(item);\n    }\n}\nfunction BooleanType(value) {\n    FNV1A64(ByteMarker.Boolean);\n    FNV1A64(value ? 1 : 0);\n}\nfunction BigIntType(value) {\n    FNV1A64(ByteMarker.BigInt);\n    F64In.setBigInt64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction DateType(value) {\n    FNV1A64(ByteMarker.Date);\n    Visit(value.getTime());\n}\nfunction NullType(value) {\n    FNV1A64(ByteMarker.Null);\n}\nfunction NumberType(value) {\n    FNV1A64(ByteMarker.Number);\n    F64In.setFloat64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction ObjectType(value) {\n    FNV1A64(ByteMarker.Object);\n    for (const key of globalThis.Object.keys(value).sort()) {\n        Visit(key);\n        Visit(value[key]);\n    }\n}\nfunction StringType(value) {\n    FNV1A64(ByteMarker.String);\n    for (let i = 0; i < value.length; i++) {\n        FNV1A64(value.charCodeAt(i));\n    }\n}\nfunction SymbolType(value) {\n    FNV1A64(ByteMarker.Symbol);\n    Visit(value.description);\n}\nfunction Uint8ArrayType(value) {\n    FNV1A64(ByteMarker.Uint8Array);\n    for (let i = 0; i < value.length; i++) {\n        FNV1A64(value[i]);\n    }\n}\nfunction UndefinedType(value) {\n    return FNV1A64(ByteMarker.Undefined);\n}\nfunction Visit(value) {\n    if (ValueGuard.IsArray(value))\n        return ArrayType(value);\n    if (ValueGuard.IsBoolean(value))\n        return BooleanType(value);\n    if (ValueGuard.IsBigInt(value))\n        return BigIntType(value);\n    if (ValueGuard.IsDate(value))\n        return DateType(value);\n    if (ValueGuard.IsNull(value))\n        return NullType(value);\n    if (ValueGuard.IsNumber(value))\n        return NumberType(value);\n    if (ValueGuard.IsPlainObject(value))\n        return ObjectType(value);\n    if (ValueGuard.IsString(value))\n        return StringType(value);\n    if (ValueGuard.IsSymbol(value))\n        return SymbolType(value);\n    if (ValueGuard.IsUint8Array(value))\n        return Uint8ArrayType(value);\n    if (ValueGuard.IsUndefined(value))\n        return UndefinedType(value);\n    throw new ValueHashError(value);\n}\nfunction FNV1A64(byte) {\n    Accumulator = Accumulator ^ Bytes[byte];\n    Accumulator = (Accumulator * Prime) % Size;\n}\n// --------------------------------------------------------------------------\n// Hash\n// --------------------------------------------------------------------------\n/** Creates a FNV1A-64 non cryptographic hash of the given value */\nfunction Hash(value) {\n    Accumulator = BigInt('14695981039346656037');\n    Visit(value);\n    return Accumulator;\n}\nexports.Hash = Hash;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Errors = exports.ValueErrorsDereferenceError = exports.ValueErrorsUnknownTypeError = exports.ValueErrorIterator = exports.ValueErrorType = void 0;\nconst index_1 = require(\"../system/index\");\nconst Types = require(\"../typebox\");\nconst ValueHash = require(\"../value/hash\");\nconst ValueGuard = require(\"../value/guard\");\n// --------------------------------------------------------------------------\n// ValueErrorType\n// --------------------------------------------------------------------------\nvar ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"Array\"] = 0] = \"Array\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 1] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 3] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 4] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 5] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 6] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 8] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 9] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 10] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 11] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 12] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 13] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 15] = \"Date\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 17] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 19] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 20] = \"Function\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 21] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 22] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 24] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 26] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 27] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 29] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 30] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 31] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 32] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 33] = \"Null\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 34] = \"Number\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 35] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 36] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 37] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 38] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 39] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 40] = \"Object\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 41] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 42] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 43] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperties\"] = 44] = \"ObjectRequiredProperties\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 45] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RecordKeyNumeric\"] = 46] = \"RecordKeyNumeric\";\n    ValueErrorType[ValueErrorType[\"RecordKeyString\"] = 47] = \"RecordKeyString\";\n    ValueErrorType[ValueErrorType[\"String\"] = 48] = \"String\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 49] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 50] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 51] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 52] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 53] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 54] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleZeroLength\"] = 55] = \"TupleZeroLength\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 57] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 58] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 59] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 60] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 61] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 62] = \"Void\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 63] = \"Kind\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// --------------------------------------------------------------------------\n// ValueErrorIterator\n// --------------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// --------------------------------------------------------------------------\n// ValueErrors\n// --------------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends Error {\n    constructor(schema) {\n        super('ValueErrors: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\nclass ValueErrorsDereferenceError extends Error {\n    constructor(schema) {\n        super(`ValueErrors: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsDereferenceError = ValueErrorsDereferenceError;\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// Policies\n// --------------------------------------------------------------------------\nfunction IsExactOptionalProperty(value, key) {\n    return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n}\nfunction IsObject(value) {\n    const isObject = ValueGuard.IsObject(value);\n    return index_1.TypeSystem.AllowArrayObjects ? isObject : isObject && !ValueGuard.IsArray(value);\n}\nfunction IsRecordObject(value) {\n    return IsObject(value) && !(value instanceof Date) && !(value instanceof Uint8Array);\n}\nfunction IsNumber(value) {\n    const isNumber = ValueGuard.IsNumber(value);\n    return index_1.TypeSystem.AllowNaN ? isNumber : isNumber && Number.isFinite(value);\n}\nfunction IsVoid(value) {\n    const isUndefined = ValueGuard.IsUndefined(value);\n    return index_1.TypeSystem.AllowVoidNull ? isUndefined || value === null : isUndefined;\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* TAny(schema, references, path, value) { }\nfunction* TArray(schema, references, path, value) {\n    if (!ValueGuard.IsArray(value)) {\n        return yield { type: ValueErrorType.Array, schema, path, value, message: `Expected array` };\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield { type: ValueErrorType.ArrayMinItems, schema, path, value, message: `Expected array length to be greater or equal to ${schema.minItems}` };\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield { type: ValueErrorType.ArrayMinItems, schema, path, value, message: `Expected array length to be less or equal to ${schema.maxItems}` };\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = ValueHash.Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield { type: ValueErrorType.ArrayUniqueItems, schema, path, value, message: `Expected array elements to be unique` };\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield { type: ValueErrorType.ArrayContains, schema, path, value, message: `Expected array to contain at least one matching type` };\n    }\n    if (ValueGuard.IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        yield { type: ValueErrorType.ArrayMinContains, schema, path, value, message: `Expected array to contain at least ${schema.minContains} matching types` };\n    }\n    if (ValueGuard.IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        yield { type: ValueErrorType.ArrayMaxContains, schema, path, value, message: `Expected array to contain no more than ${schema.maxContains} matching types` };\n    }\n}\nfunction* TAsyncIterator(schema, references, path, value) {\n    if (!ValueGuard.IsAsyncIterator(value)) {\n        yield { type: ValueErrorType.AsyncIterator, schema, path, value, message: `Expected value to be an async iterator` };\n    }\n}\nfunction* TBigInt(schema, references, path, value) {\n    if (!ValueGuard.IsBigInt(value)) {\n        return yield { type: ValueErrorType.BigInt, schema, path, value, message: `Expected bigint` };\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield { type: ValueErrorType.BigIntMultipleOf, schema, path, value, message: `Expected bigint to be a multiple of ${schema.multipleOf}` };\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield { type: ValueErrorType.BigIntExclusiveMinimum, schema, path, value, message: `Expected bigint to be greater than ${schema.exclusiveMinimum}` };\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield { type: ValueErrorType.BigIntExclusiveMaximum, schema, path, value, message: `Expected bigint to be less than ${schema.exclusiveMaximum}` };\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield { type: ValueErrorType.BigIntMinimum, schema, path, value, message: `Expected bigint to be greater or equal to ${schema.minimum}` };\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield { type: ValueErrorType.BigIntMaximum, schema, path, value, message: `Expected bigint to be less or equal to ${schema.maximum}` };\n    }\n}\nfunction* TBoolean(schema, references, path, value) {\n    if (!ValueGuard.IsBoolean(value)) {\n        return yield { type: ValueErrorType.Boolean, schema, path, value, message: `Expected boolean` };\n    }\n}\nfunction* TConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* TDate(schema, references, path, value) {\n    if (!ValueGuard.IsDate(value)) {\n        return yield { type: ValueErrorType.Date, schema, path, value, message: `Expected Date object` };\n    }\n    if (!isFinite(value.getTime())) {\n        return yield { type: ValueErrorType.Date, schema, path, value, message: `Invalid Date` };\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield { type: ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value, message: `Expected Date timestamp to be greater than ${schema.exclusiveMinimum}` };\n    }\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield { type: ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value, message: `Expected Date timestamp to be less than ${schema.exclusiveMaximum}` };\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield { type: ValueErrorType.DateMinimumTimestamp, schema, path, value, message: `Expected Date timestamp to be greater or equal to ${schema.minimum}` };\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield { type: ValueErrorType.DateMaximumTimestamp, schema, path, value, message: `Expected Date timestamp to be less or equal to ${schema.maximum}` };\n    }\n}\nfunction* TFunction(schema, references, path, value) {\n    if (!ValueGuard.IsFunction(value)) {\n        return yield { type: ValueErrorType.Function, schema, path, value, message: `Expected function` };\n    }\n}\nfunction* TInteger(schema, references, path, value) {\n    if (!ValueGuard.IsInteger(value)) {\n        return yield { type: ValueErrorType.Integer, schema, path, value, message: `Expected integer` };\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield { type: ValueErrorType.IntegerMultipleOf, schema, path, value, message: `Expected integer to be a multiple of ${schema.multipleOf}` };\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield { type: ValueErrorType.IntegerExclusiveMinimum, schema, path, value, message: `Expected integer to be greater than ${schema.exclusiveMinimum}` };\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield { type: ValueErrorType.IntegerExclusiveMaximum, schema, path, value, message: `Expected integer to be less than ${schema.exclusiveMaximum}` };\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield { type: ValueErrorType.IntegerMinimum, schema, path, value, message: `Expected integer to be greater or equal to ${schema.minimum}` };\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield { type: ValueErrorType.IntegerMaximum, schema, path, value, message: `Expected integer to be less or equal to ${schema.maximum}` };\n    }\n}\nfunction* TIntersect(schema, references, path, value) {\n    for (const inner of schema.allOf) {\n        const next = Visit(inner, references, path, value).next();\n        if (!next.done) {\n            yield next.value;\n            yield { type: ValueErrorType.Intersect, schema, path, value, message: `Expected all sub schemas to be valid` };\n            return;\n        }\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield { type: ValueErrorType.IntersectUnevaluatedProperties, schema, path: `${path}/${valueKey}`, value, message: `Unexpected property` };\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done) {\n                    yield next.value;\n                    yield { type: ValueErrorType.IntersectUnevaluatedProperties, schema, path: `${path}/${valueKey}`, value, message: `Invalid additional property` };\n                    return;\n                }\n            }\n        }\n    }\n}\nfunction* TIterator(schema, references, path, value) {\n    if (!(IsObject(value) && Symbol.iterator in value)) {\n        yield { type: ValueErrorType.Iterator, schema, path, value, message: `Expected value to be an iterator` };\n    }\n}\nfunction* TLiteral(schema, references, path, value) {\n    if (!(value === schema.const)) {\n        const error = typeof schema.const === 'string' ? `'${schema.const}'` : schema.const;\n        return yield { type: ValueErrorType.Literal, schema, path, value, message: `Expected ${error}` };\n    }\n}\nfunction* TNever(schema, references, path, value) {\n    yield { type: ValueErrorType.Never, schema, path, value, message: `Value cannot be validated` };\n}\nfunction* TNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true) {\n        yield { type: ValueErrorType.Not, schema, path, value, message: `Value should not validate` };\n    }\n}\nfunction* TNull(schema, references, path, value) {\n    if (!ValueGuard.IsNull(value)) {\n        return yield { type: ValueErrorType.Null, schema, path, value, message: `Expected null` };\n    }\n}\nfunction* TNumber(schema, references, path, value) {\n    if (!IsNumber(value)) {\n        return yield { type: ValueErrorType.Number, schema, path, value, message: `Expected number` };\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield { type: ValueErrorType.NumberMultipleOf, schema, path, value, message: `Expected number to be a multiple of ${schema.multipleOf}` };\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield { type: ValueErrorType.NumberExclusiveMinimum, schema, path, value, message: `Expected number to be greater than ${schema.exclusiveMinimum}` };\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield { type: ValueErrorType.NumberExclusiveMaximum, schema, path, value, message: `Expected number to be less than ${schema.exclusiveMaximum}` };\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield { type: ValueErrorType.NumberMinimum, schema, path, value, message: `Expected number to be greater or equal to ${schema.minimum}` };\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield { type: ValueErrorType.NumberMaximum, schema, path, value, message: `Expected number to be less or equal to ${schema.maximum}` };\n    }\n}\nfunction* TObject(schema, references, path, value) {\n    if (!IsObject(value)) {\n        return yield { type: ValueErrorType.Object, schema, path, value, message: `Expected object` };\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield { type: ValueErrorType.ObjectMinProperties, schema, path, value, message: `Expected object to have at least ${schema.minProperties} properties` };\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield { type: ValueErrorType.ObjectMaxProperties, schema, path, value, message: `Expected object to have no more than ${schema.maxProperties} properties` };\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);\n            if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {\n                yield { type: ValueErrorType.ObjectRequiredProperties, schema: property, path: `${path}/${knownKey}`, value: undefined, message: `Expected required property` };\n            }\n        }\n        else {\n            if (IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);\n            }\n        }\n    }\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield { type: ValueErrorType.ObjectRequiredProperties, schema: schema.properties[requiredKey], path: `${path}/${requiredKey}`, value: undefined, message: `Expected required property` };\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield { type: ValueErrorType.ObjectAdditionalProperties, schema, path: `${path}/${valueKey}`, value: value[valueKey], message: `Unexpected property` };\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${valueKey}`, value[valueKey]);\n        }\n    }\n}\nfunction* TPromise(schema, references, path, value) {\n    if (!ValueGuard.IsPromise(value)) {\n        yield { type: ValueErrorType.Promise, schema, path, value, message: `Expected Promise` };\n    }\n}\nfunction* TRecord(schema, references, path, value) {\n    if (!IsRecordObject(value)) {\n        return yield { type: ValueErrorType.Object, schema, path, value, message: `Expected record object` };\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield { type: ValueErrorType.ObjectMinProperties, schema, path, value, message: `Expected object to have at least ${schema.minProperties} properties` };\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield { type: ValueErrorType.ObjectMaxProperties, schema, path, value, message: `Expected object to have no more than ${schema.maxProperties} properties` };\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey)) {\n            yield* Visit(patternSchema, references, `${path}/${propertyKey}`, propertyValue);\n            continue;\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            yield* Visit(schema.additionalProperties, references, `${path}/${propertyKey}`, propertyValue);\n        }\n        if (schema.additionalProperties === false) {\n            const propertyPath = `${path}/${propertyKey}`;\n            const message = `Unexpected property '${propertyPath}'`;\n            return yield { type: ValueErrorType.ObjectAdditionalProperties, schema, path: propertyPath, value: propertyValue, message };\n        }\n    }\n}\nfunction* TRef(schema, references, path, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueErrorsDereferenceError(schema);\n    const target = references[index];\n    yield* Visit(target, references, path, value);\n}\nfunction* TString(schema, references, path, value) {\n    if (!ValueGuard.IsString(value)) {\n        return yield { type: ValueErrorType.String, schema, path, value, message: 'Expected string' };\n    }\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield { type: ValueErrorType.StringMinLength, schema, path, value, message: `Expected string length greater or equal to ${schema.minLength}` };\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield { type: ValueErrorType.StringMaxLength, schema, path, value, message: `Expected string length less or equal to ${schema.maxLength}` };\n    }\n    if (ValueGuard.IsString(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield { type: ValueErrorType.StringPattern, schema, path, value, message: `Expected string to match pattern ${schema.pattern}` };\n        }\n    }\n    if (ValueGuard.IsString(schema.format)) {\n        if (!Types.FormatRegistry.Has(schema.format)) {\n            yield { type: ValueErrorType.StringFormatUnknown, schema, path, value, message: `Unknown string format '${schema.format}'` };\n        }\n        else {\n            const format = Types.FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield { type: ValueErrorType.StringFormat, schema, path, value, message: `Expected string to match format '${schema.format}'` };\n            }\n        }\n    }\n}\nfunction* TSymbol(schema, references, path, value) {\n    if (!ValueGuard.IsSymbol(value)) {\n        return yield { type: ValueErrorType.Symbol, schema, path, value, message: 'Expected symbol' };\n    }\n}\nfunction* TTemplateLiteral(schema, references, path, value) {\n    if (!ValueGuard.IsString(value)) {\n        return yield { type: ValueErrorType.String, schema, path, value, message: 'Expected string' };\n    }\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield { type: ValueErrorType.StringPattern, schema, path, value, message: `Expected string to match pattern ${schema.pattern}` };\n    }\n}\nfunction* TThis(schema, references, path, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueErrorsDereferenceError(schema);\n    const target = references[index];\n    yield* Visit(target, references, path, value);\n}\nfunction* TTuple(schema, references, path, value) {\n    if (!ValueGuard.IsArray(value)) {\n        return yield { type: ValueErrorType.Array, schema, path, value, message: 'Expected Array' };\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield { type: ValueErrorType.TupleZeroLength, schema, path, value, message: 'Expected tuple to have 0 elements' };\n    }\n    if (!(value.length === schema.maxItems)) {\n        yield { type: ValueErrorType.TupleLength, schema, path, value, message: `Expected tuple to have ${schema.maxItems} elements` };\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* TUndefined(schema, references, path, value) {\n    if (!(value === undefined)) {\n        yield { type: ValueErrorType.Undefined, schema, path, value, message: `Expected undefined` };\n    }\n}\nfunction* TUnion(schema, references, path, value) {\n    const errors = [];\n    for (const inner of schema.anyOf) {\n        const variantErrors = [...Visit(inner, references, path, value)];\n        if (variantErrors.length === 0)\n            return;\n        errors.push(...variantErrors);\n    }\n    if (errors.length > 0) {\n        yield { type: ValueErrorType.Union, schema, path, value, message: 'Expected value of union' };\n    }\n    for (const error of errors) {\n        yield error;\n    }\n}\nfunction* TUint8Array(schema, references, path, value) {\n    if (!ValueGuard.IsUint8Array(value)) {\n        return yield { type: ValueErrorType.Uint8Array, schema, path, value, message: `Expected Uint8Array` };\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield { type: ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value, message: `Expected Uint8Array to have a byte length less or equal to ${schema.maxByteLength}` };\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield { type: ValueErrorType.Uint8ArrayMinByteLength, schema, path, value, message: `Expected Uint8Array to have a byte length greater or equal to ${schema.maxByteLength}` };\n    }\n}\nfunction* TUnknown(schema, references, path, value) { }\nfunction* TVoid(schema, references, path, value) {\n    if (!IsVoid(value)) {\n        return yield { type: ValueErrorType.Void, schema, path, value, message: `Expected void` };\n    }\n}\nfunction* TKind(schema, references, path, value) {\n    const check = Types.TypeRegistry.Get(schema[Types.Kind]);\n    if (!check(schema, value)) {\n        return yield { type: ValueErrorType.Kind, schema, path, value, message: `Expected kind ${schema[Types.Kind]}` };\n    }\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return yield* TAny(schema_, references_, path, value);\n        case 'Array':\n            return yield* TArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* TAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* TBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* TBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* TConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* TDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* TFunction(schema_, references_, path, value);\n        case 'Integer':\n            return yield* TInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* TIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* TIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* TLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* TNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* TNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* TNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* TNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* TObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* TPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* TRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* TRef(schema_, references_, path, value);\n        case 'String':\n            return yield* TString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* TSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* TTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* TThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* TTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* TUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* TUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* TUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* TUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* TVoid(schema_, references_, path, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* TKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nfunction Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\nexports.Errors = Errors;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./errors\"), exports);\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValuePointerRootSetError extends Error {\n    constructor(value, path, update) {\n        super('ValuePointer: Cannot set root value');\n        this.value = value;\n        this.path = path;\n        this.update = update;\n    }\n}\nexports.ValuePointerRootSetError = ValuePointerRootSetError;\nclass ValuePointerRootDeleteError extends Error {\n    constructor(value, path) {\n        super('ValuePointer: Cannot delete root value');\n        this.value = value;\n        this.path = path;\n    }\n}\nexports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;\n// --------------------------------------------------------------------------\n// ValuePointer\n// --------------------------------------------------------------------------\n/** Provides functionality to update values through RFC6901 string pointers */\nvar ValuePointer;\n(function (ValuePointer) {\n    function Escape(component) {\n        return component.indexOf('~') === -1 ? component : component.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n    /** Formats the given pointer into navigable key components */\n    function* Format(pointer) {\n        if (pointer === '')\n            return;\n        let [start, end] = [0, 0];\n        for (let i = 0; i < pointer.length; i++) {\n            const char = pointer.charAt(i);\n            if (char === '/') {\n                if (i === 0) {\n                    start = i + 1;\n                }\n                else {\n                    end = i;\n                    yield Escape(pointer.slice(start, end));\n                    start = i + 1;\n                }\n            }\n            else {\n                end = i;\n            }\n        }\n        yield Escape(pointer.slice(start));\n    }\n    ValuePointer.Format = Format;\n    /** Sets the value at the given pointer. If the value at the pointer does not exist it is created */\n    function Set(value, pointer, update) {\n        if (pointer === '')\n            throw new ValuePointerRootSetError(value, pointer, update);\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined)\n                next[component] = {};\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        owner[key] = update;\n    }\n    ValuePointer.Set = Set;\n    /** Deletes a value at the given pointer */\n    function Delete(value, pointer) {\n        if (pointer === '')\n            throw new ValuePointerRootDeleteError(value, pointer);\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined || next[component] === null)\n                return;\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        if (Array.isArray(owner)) {\n            const index = parseInt(key);\n            owner.splice(index, 1);\n        }\n        else {\n            delete owner[key];\n        }\n    }\n    ValuePointer.Delete = Delete;\n    /** Returns true if a value exists at the given pointer */\n    function Has(value, pointer) {\n        if (pointer === '')\n            return true;\n        let [owner, next, key] = [null, value, ''];\n        for (const component of Format(pointer)) {\n            if (next[component] === undefined)\n                return false;\n            owner = next;\n            next = next[component];\n            key = component;\n        }\n        return Object.getOwnPropertyNames(owner).includes(key);\n    }\n    ValuePointer.Has = Has;\n    /** Gets the value at the given pointer */\n    function Get(value, pointer) {\n        if (pointer === '')\n            return value;\n        let current = value;\n        for (const component of Format(pointer)) {\n            if (current[component] === undefined)\n                return undefined;\n            current = current[component];\n        }\n        return current;\n    }\n    ValuePointer.Get = Get;\n})(ValuePointer || (exports.ValuePointer = ValuePointer = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Clone = void 0;\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Clonable\n// --------------------------------------------------------------------------\nfunction ObjectType(value) {\n    const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];\n    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});\n}\nfunction ArrayType(value) {\n    return value.map((element) => Clone(element));\n}\nfunction TypedArrayType(value) {\n    return value.slice();\n}\nfunction DateType(value) {\n    return new Date(value.toISOString());\n}\nfunction ValueType(value) {\n    return value;\n}\n// --------------------------------------------------------------------------\n// Non-Clonable\n// --------------------------------------------------------------------------\nfunction AsyncIteratorType(value) {\n    return value;\n}\nfunction IteratorType(value) {\n    return value;\n}\nfunction FunctionType(value) {\n    return value;\n}\nfunction PromiseType(value) {\n    return value;\n}\n// --------------------------------------------------------------------------\n// Clone\n// --------------------------------------------------------------------------\n/** Returns a clone of the given value */\nfunction Clone(value) {\n    if (ValueGuard.IsArray(value))\n        return ArrayType(value);\n    if (ValueGuard.IsAsyncIterator(value))\n        return AsyncIteratorType(value);\n    if (ValueGuard.IsFunction(value))\n        return FunctionType(value);\n    if (ValueGuard.IsIterator(value))\n        return IteratorType(value);\n    if (ValueGuard.IsPromise(value))\n        return PromiseType(value);\n    if (ValueGuard.IsDate(value))\n        return DateType(value);\n    if (ValueGuard.IsPlainObject(value))\n        return ObjectType(value);\n    if (ValueGuard.IsTypedArray(value))\n        return TypedArrayType(value);\n    if (ValueGuard.IsValueType(value))\n        return ValueType(value);\n    throw new Error('ValueClone: Unable to clone value');\n}\nexports.Clone = Clone;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;\nconst typebox_1 = require(\"../typebox\");\nconst pointer_1 = require(\"./pointer\");\nconst ValueGuard = require(\"./guard\");\nconst ValueClone = require(\"./clone\");\nexports.Insert = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('insert'),\n    path: typebox_1.Type.String(),\n    value: typebox_1.Type.Unknown(),\n});\nexports.Update = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('update'),\n    path: typebox_1.Type.String(),\n    value: typebox_1.Type.Unknown(),\n});\nexports.Delete = typebox_1.Type.Object({\n    type: typebox_1.Type.Literal('delete'),\n    path: typebox_1.Type.String(),\n});\nexports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueDeltaObjectWithSymbolKeyError extends Error {\n    constructor(key) {\n        super('ValueDelta: Cannot diff objects with symbol keys');\n        this.key = key;\n    }\n}\nexports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;\nclass ValueDeltaUnableToDiffUnknownValue extends Error {\n    constructor(value) {\n        super('ValueDelta: Unable to create diff edits for unknown value');\n        this.value = value;\n    }\n}\nexports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;\n// --------------------------------------------------------------------------\n// Command Factory\n// --------------------------------------------------------------------------\nfunction CreateUpdate(path, value) {\n    return { type: 'update', path, value };\n}\nfunction CreateInsert(path, value) {\n    return { type: 'insert', path, value };\n}\nfunction CreateDelete(path) {\n    return { type: 'delete', path };\n}\n// --------------------------------------------------------------------------\n// Diffing Generators\n// --------------------------------------------------------------------------\nfunction* ObjectType(path, current, next) {\n    if (!ValueGuard.IsPlainObject(next))\n        return yield CreateUpdate(path, next);\n    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];\n    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];\n    for (const key of currentKeys) {\n        if (ValueGuard.IsSymbol(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if (ValueGuard.IsUndefined(next[key]) && nextKeys.includes(key))\n            yield CreateUpdate(`${path}/${String(key)}`, undefined);\n    }\n    for (const key of nextKeys) {\n        if (ValueGuard.IsUndefined(current[key]) || ValueGuard.IsUndefined(next[key]))\n            continue;\n        if (ValueGuard.IsSymbol(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        yield* Visit(`${path}/${String(key)}`, current[key], next[key]);\n    }\n    for (const key of nextKeys) {\n        if (ValueGuard.IsSymbol(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if (ValueGuard.IsUndefined(current[key]))\n            yield CreateInsert(`${path}/${String(key)}`, next[key]);\n    }\n    for (const key of currentKeys.reverse()) {\n        if (ValueGuard.IsSymbol(key))\n            throw new ValueDeltaObjectWithSymbolKeyError(key);\n        if (ValueGuard.IsUndefined(next[key]) && !nextKeys.includes(key))\n            yield CreateDelete(`${path}/${String(key)}`);\n    }\n}\nfunction* ArrayType(path, current, next) {\n    if (!ValueGuard.IsArray(next))\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n    for (let i = 0; i < next.length; i++) {\n        if (i < current.length)\n            continue;\n        yield CreateInsert(`${path}/${i}`, next[i]);\n    }\n    for (let i = current.length - 1; i >= 0; i--) {\n        if (i < next.length)\n            continue;\n        yield CreateDelete(`${path}/${i}`);\n    }\n}\nfunction* TypedArrayType(path, current, next) {\n    if (!ValueGuard.IsTypedArray(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n}\nfunction* ValueType(path, current, next) {\n    if (current === next)\n        return;\n    yield CreateUpdate(path, next);\n}\nfunction* Visit(path, current, next) {\n    if (ValueGuard.IsPlainObject(current))\n        return yield* ObjectType(path, current, next);\n    if (ValueGuard.IsArray(current))\n        return yield* ArrayType(path, current, next);\n    if (ValueGuard.IsTypedArray(current))\n        return yield* TypedArrayType(path, current, next);\n    if (ValueGuard.IsValueType(current))\n        return yield* ValueType(path, current, next);\n    throw new ValueDeltaUnableToDiffUnknownValue(current);\n}\n// ---------------------------------------------------------------------\n// Diff\n// ---------------------------------------------------------------------\nfunction Diff(current, next) {\n    return [...Visit('', current, next)];\n}\nexports.Diff = Diff;\n// ---------------------------------------------------------------------\n// Patch\n// ---------------------------------------------------------------------\nfunction IsRootUpdate(edits) {\n    return edits.length > 0 && edits[0].path === '' && edits[0].type === 'update';\n}\nfunction IsIdentity(edits) {\n    return edits.length === 0;\n}\nfunction Patch(current, edits) {\n    if (IsRootUpdate(edits)) {\n        return ValueClone.Clone(edits[0].value);\n    }\n    if (IsIdentity(edits)) {\n        return ValueClone.Clone(current);\n    }\n    const clone = ValueClone.Clone(current);\n    for (const edit of edits) {\n        switch (edit.type) {\n            case 'insert': {\n                pointer_1.ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'update': {\n                pointer_1.ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'delete': {\n                pointer_1.ValuePointer.Delete(clone, edit.path);\n                break;\n            }\n        }\n    }\n    return clone;\n}\nexports.Patch = Patch;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = void 0;\nconst pointer_1 = require(\"./pointer\");\nconst ValueClone = require(\"./clone\");\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueMutateTypeMismatchError extends Error {\n    constructor() {\n        super('ValueMutate: Cannot assign due type mismatch of assignable values');\n    }\n}\nexports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;\nclass ValueMutateInvalidRootMutationError extends Error {\n    constructor() {\n        super('ValueMutate: Only object and array types can be mutated at the root level');\n    }\n}\nexports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;\nfunction ObjectType(root, path, current, next) {\n    if (!ValueGuard.IsPlainObject(current)) {\n        pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));\n    }\n    else {\n        const currentKeys = Object.keys(current);\n        const nextKeys = Object.keys(next);\n        for (const currentKey of currentKeys) {\n            if (!nextKeys.includes(currentKey)) {\n                delete current[currentKey];\n            }\n        }\n        for (const nextKey of nextKeys) {\n            if (!currentKeys.includes(nextKey)) {\n                current[nextKey] = null;\n            }\n        }\n        for (const nextKey of nextKeys) {\n            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);\n        }\n    }\n}\nfunction ArrayType(root, path, current, next) {\n    if (!ValueGuard.IsArray(current)) {\n        pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));\n    }\n    else {\n        for (let index = 0; index < next.length; index++) {\n            Visit(root, `${path}/${index}`, current[index], next[index]);\n        }\n        current.splice(next.length);\n    }\n}\nfunction TypedArrayType(root, path, current, next) {\n    if (ValueGuard.IsTypedArray(current) && current.length === next.length) {\n        for (let i = 0; i < current.length; i++) {\n            current[i] = next[i];\n        }\n    }\n    else {\n        pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));\n    }\n}\nfunction ValueType(root, path, current, next) {\n    if (current === next)\n        return;\n    pointer_1.ValuePointer.Set(root, path, next);\n}\nfunction Visit(root, path, current, next) {\n    if (ValueGuard.IsArray(next))\n        return ArrayType(root, path, current, next);\n    if (ValueGuard.IsTypedArray(next))\n        return TypedArrayType(root, path, current, next);\n    if (ValueGuard.IsPlainObject(next))\n        return ObjectType(root, path, current, next);\n    if (ValueGuard.IsValueType(next))\n        return ValueType(root, path, current, next);\n}\n// --------------------------------------------------------------------------\n// Mutate\n// --------------------------------------------------------------------------\nfunction IsNonMutableValue(value) {\n    return ValueGuard.IsTypedArray(value) || ValueGuard.IsValueType(value);\n}\nfunction IsMismatchedValue(current, next) {\n    // prettier-ignore\n    return ((ValueGuard.IsPlainObject(current) && ValueGuard.IsArray(next)) ||\n        (ValueGuard.IsArray(current) && ValueGuard.IsPlainObject(next)));\n}\n// --------------------------------------------------------------------------\n// Mutate\n// --------------------------------------------------------------------------\n/** Performs a deep mutable value assignment while retaining internal references */\nfunction Mutate(current, next) {\n    if (IsNonMutableValue(current) || IsNonMutableValue(next))\n        throw new ValueMutateInvalidRootMutationError();\n    if (IsMismatchedValue(current, next))\n        throw new ValueMutateTypeMismatchError();\n    Visit(current, '', current, next);\n}\nexports.Mutate = Mutate;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Equal = void 0;\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Equality Checks\n// --------------------------------------------------------------------------\nfunction ObjectType(left, right) {\n    if (!ValueGuard.IsPlainObject(right))\n        return false;\n    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];\n    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];\n    if (leftKeys.length !== rightKeys.length)\n        return false;\n    return leftKeys.every((key) => Equal(left[key], right[key]));\n}\nfunction DateType(left, right) {\n    return ValueGuard.IsDate(right) && left.getTime() === right.getTime();\n}\nfunction ArrayType(left, right) {\n    if (!ValueGuard.IsArray(right) || left.length !== right.length)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction TypedArrayType(left, right) {\n    if (!ValueGuard.IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction ValueType(left, right) {\n    return left === right;\n}\n// --------------------------------------------------------------------------\n// Equal\n// --------------------------------------------------------------------------\n/** Returns true if the left value deep-equals the right */\nfunction Equal(left, right) {\n    if (ValueGuard.IsPlainObject(left))\n        return ObjectType(left, right);\n    if (ValueGuard.IsDate(left))\n        return DateType(left, right);\n    if (ValueGuard.IsTypedArray(left))\n        return TypedArrayType(left, right);\n    if (ValueGuard.IsArray(left))\n        return ArrayType(left, right);\n    if (ValueGuard.IsValueType(left))\n        return ValueType(left, right);\n    throw new Error('ValueEquals: Unable to compare value');\n}\nexports.Equal = Equal;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Check = exports.ValueCheckDereferenceError = exports.ValueCheckUnknownTypeError = void 0;\nconst index_1 = require(\"../system/index\");\nconst Types = require(\"../typebox\");\nconst ValueGuard = require(\"./guard\");\nconst ValueHash = require(\"./hash\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCheckUnknownTypeError extends Error {\n    constructor(schema) {\n        super(`ValueCheck: ${schema[Types.Kind] ? `Unknown type '${schema[Types.Kind]}'` : 'Unknown type'}`);\n        this.schema = schema;\n    }\n}\nexports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;\nclass ValueCheckDereferenceError extends Error {\n    constructor(schema) {\n        super(`ValueCheck: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueCheckDereferenceError = ValueCheckDereferenceError;\n// --------------------------------------------------------------------------\n// TypeGuards\n// --------------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n    return schema[Types.Kind] === 'Any' || schema[Types.Kind] === 'Unknown';\n}\n// --------------------------------------------------------------------------\n// Guards\n// --------------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// --------------------------------------------------------------------------\n// Policies\n// --------------------------------------------------------------------------\nfunction IsExactOptionalProperty(value, key) {\n    return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n}\nfunction IsObject(value) {\n    const isObject = ValueGuard.IsObject(value);\n    return index_1.TypeSystem.AllowArrayObjects ? isObject : isObject && !ValueGuard.IsArray(value);\n}\nfunction IsRecordObject(value) {\n    return IsObject(value) && !(value instanceof Date) && !(value instanceof Uint8Array);\n}\nfunction IsNumber(value) {\n    const isNumber = ValueGuard.IsNumber(value);\n    return index_1.TypeSystem.AllowNaN ? isNumber : isNumber && Number.isFinite(value);\n}\nfunction IsVoid(value) {\n    const isUndefined = ValueGuard.IsUndefined(value);\n    return index_1.TypeSystem.AllowVoidNull ? isUndefined || value === null : isUndefined;\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction TAny(schema, references, value) {\n    return true;\n}\nfunction TArray(schema, references, value) {\n    if (!Array.isArray(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        return false;\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        return false;\n    }\n    if (!value.every((value) => Visit(schema.items, references, value))) {\n        return false;\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = ValueHash.Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        return false;\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n        return true; // exit\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();\n    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        return false;\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        return false;\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        return false;\n    }\n    return true;\n}\nfunction TAsyncIterator(schema, references, value) {\n    return IsObject(value) && Symbol.asyncIterator in value;\n}\nfunction TBigInt(schema, references, value) {\n    if (!ValueGuard.IsBigInt(value)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    return true;\n}\nfunction TBoolean(schema, references, value) {\n    return typeof value === 'boolean';\n}\nfunction TConstructor(schema, references, value) {\n    return Visit(schema.returns, references, value.prototype);\n}\nfunction TDate(schema, references, value) {\n    if (!(value instanceof Date)) {\n        return false;\n    }\n    if (!IsNumber(value.getTime())) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        return false;\n    }\n    return true;\n}\nfunction TFunction(schema, references, value) {\n    return typeof value === 'function';\n}\nfunction TInteger(schema, references, value) {\n    if (!ValueGuard.IsInteger(value)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    return true;\n}\nfunction TIntersect(schema, references, value) {\n    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));\n    if (schema.unevaluatedProperties === false) {\n        const keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));\n        return check1 && check2;\n    }\n    else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {\n        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n        return check1 && check2;\n    }\n    else {\n        return check1;\n    }\n}\nfunction TIterator(schema, references, value) {\n    return IsObject(value) && Symbol.iterator in value;\n}\nfunction TLiteral(schema, references, value) {\n    return value === schema.const;\n}\nfunction TNever(schema, references, value) {\n    return false;\n}\nfunction TNot(schema, references, value) {\n    return !Visit(schema.not, references, value);\n}\nfunction TNull(schema, references, value) {\n    return value === null;\n}\nfunction TNumber(schema, references, value) {\n    if (!IsNumber(value)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    return true;\n}\nfunction TObject(schema, references, value) {\n    if (!IsObject(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            if (!Visit(property, references, value[knownKey])) {\n                return false;\n            }\n            if ((Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n                return false;\n            }\n        }\n        else {\n            if (IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n                return false;\n            }\n        }\n    }\n    if (schema.additionalProperties === false) {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        // optimization: value is valid if schemaKey length matches the valueKey length\n        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n            return true;\n        }\n        else {\n            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n        }\n    }\n    else if (typeof schema.additionalProperties === 'object') {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n    }\n    else {\n        return true;\n    }\n}\nfunction TPromise(schema, references, value) {\n    return typeof value === 'object' && typeof value.then === 'function';\n}\nfunction TRecord(schema, references, value) {\n    if (!IsRecordObject(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    return Object.entries(value).every(([key, value]) => {\n        if (regex.test(key)) {\n            return Visit(patternSchema, references, value);\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            return Visit(schema.additionalProperties, references, value);\n        }\n        if (schema.additionalProperties === false) {\n            return false;\n        }\n        return true;\n    });\n}\nfunction TRef(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueCheckDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TString(schema, references, value) {\n    if (!ValueGuard.IsString(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    if (IsDefined(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value))\n            return false;\n    }\n    if (IsDefined(schema.format)) {\n        if (!Types.FormatRegistry.Has(schema.format))\n            return false;\n        const func = Types.FormatRegistry.Get(schema.format);\n        return func(value);\n    }\n    return true;\n}\nfunction TSymbol(schema, references, value) {\n    if (!(typeof value === 'symbol')) {\n        return false;\n    }\n    return true;\n}\nfunction TTemplateLiteral(schema, references, value) {\n    if (!ValueGuard.IsString(value)) {\n        return false;\n    }\n    return new RegExp(schema.pattern).test(value);\n}\nfunction TThis(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueCheckDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TTuple(schema, references, value) {\n    if (!ValueGuard.IsArray(value)) {\n        return false;\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return false;\n    }\n    if (!(value.length === schema.maxItems)) {\n        return false;\n    }\n    if (!schema.items) {\n        return true;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        if (!Visit(schema.items[i], references, value[i]))\n            return false;\n    }\n    return true;\n}\nfunction TUndefined(schema, references, value) {\n    return value === undefined;\n}\nfunction TUnion(schema, references, value) {\n    return schema.anyOf.some((inner) => Visit(inner, references, value));\n}\nfunction TUint8Array(schema, references, value) {\n    if (!(value instanceof Uint8Array)) {\n        return false;\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        return false;\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        return false;\n    }\n    return true;\n}\nfunction TUnknown(schema, references, value) {\n    return true;\n}\nfunction TVoid(schema, references, value) {\n    return IsVoid(value);\n}\nfunction TKind(schema, references, value) {\n    if (!Types.TypeRegistry.Has(schema[Types.Kind]))\n        return false;\n    const func = Types.TypeRegistry.Get(schema[Types.Kind]);\n    return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_, value);\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return TBigInt(schema_, references_, value);\n        case 'Boolean':\n            return TBoolean(schema_, references_, value);\n        case 'Constructor':\n            return TConstructor(schema_, references_, value);\n        case 'Date':\n            return TDate(schema_, references_, value);\n        case 'Function':\n            return TFunction(schema_, references_, value);\n        case 'Integer':\n            return TInteger(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Iterator':\n            return TIterator(schema_, references_, value);\n        case 'Literal':\n            return TLiteral(schema_, references_, value);\n        case 'Never':\n            return TNever(schema_, references_, value);\n        case 'Not':\n            return TNot(schema_, references_, value);\n        case 'Null':\n            return TNull(schema_, references_, value);\n        case 'Number':\n            return TNumber(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Promise':\n            return TPromise(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'String':\n            return TString(schema_, references_, value);\n        case 'Symbol':\n            return TSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Undefined':\n            return TUndefined(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return TUnknown(schema_, references_, value);\n        case 'Void':\n            return TVoid(schema_, references_, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCheckUnknownTypeError(schema_);\n            return TKind(schema_, references_, value);\n    }\n}\n/** Returns true if the value matches the given type. */\nfunction Check(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Check = Check;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateDereferenceError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = void 0;\nconst Types = require(\"../typebox\");\nconst ValueCheck = require(\"./check\");\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCreateUnknownTypeError extends Error {\n    constructor(schema) {\n        super('ValueCreate: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;\nclass ValueCreateNeverTypeError extends Error {\n    constructor(schema) {\n        super('ValueCreate: Never types cannot be created');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;\nclass ValueCreateNotTypeError extends Error {\n    constructor(schema) {\n        super('ValueCreate: Not types must have a default value');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateNotTypeError = ValueCreateNotTypeError;\nclass ValueCreateIntersectTypeError extends Error {\n    constructor(schema) {\n        super('ValueCreate: Intersect produced invalid value. Consider using a default value.');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;\nclass ValueCreateTempateLiteralTypeError extends Error {\n    constructor(schema) {\n        super('ValueCreate: Can only create template literal values from patterns that produce finite sequences. Consider using a default value.');\n        this.schema = schema;\n    }\n}\nexports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;\nclass ValueCreateDereferenceError extends Error {\n    constructor(schema) {\n        super(`ValueCreate: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueCreateDereferenceError = ValueCreateDereferenceError;\nclass ValueCreateRecursiveInstantiationError extends Error {\n    constructor(schema, recursiveMaxDepth) {\n        super('ValueCreate: Value cannot be created as recursive type may produce value of infinite size. Consider using a default.');\n        this.schema = schema;\n        this.recursiveMaxDepth = recursiveMaxDepth;\n    }\n}\nexports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction TAny(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction TArray(schema, references) {\n    if (schema.uniqueItems === true && !ValueGuard.HasPropertyKey(schema, 'default')) {\n        throw new Error('ValueCreate.Array: Array with the uniqueItems constraint requires a default value');\n    }\n    else if ('contains' in schema && !ValueGuard.HasPropertyKey(schema, 'default')) {\n        throw new Error('ValueCreate.Array: Array with the contains constraint requires a default value');\n    }\n    else if ('default' in schema) {\n        return schema.default;\n    }\n    else if (schema.minItems !== undefined) {\n        return Array.from({ length: schema.minItems }).map((item) => {\n            return Visit(schema.items, references);\n        });\n    }\n    else {\n        return [];\n    }\n}\nfunction TAsyncIterator(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (async function* () { })();\n    }\n}\nfunction TBigInt(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return BigInt(0);\n    }\n}\nfunction TBoolean(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return false;\n    }\n}\nfunction TConstructor(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const value = Visit(schema.returns, references);\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return class {\n                constructor() {\n                    for (const [key, val] of Object.entries(value)) {\n                        const self = this;\n                        self[key] = val;\n                    }\n                }\n            };\n        }\n        else {\n            return class {\n            };\n        }\n    }\n}\nfunction TDate(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimumTimestamp !== undefined) {\n        return new Date(schema.minimumTimestamp);\n    }\n    else {\n        return new Date(0);\n    }\n}\nfunction TFunction(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return () => Visit(schema.returns, references);\n    }\n}\nfunction TInteger(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction TIntersect(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        // Note: The best we can do here is attempt to instance each sub type and apply through object assign. For non-object\n        // sub types, we just escape the assignment and just return the value. In the latter case, this is typically going to\n        // be a consequence of an illogical intersection.\n        const value = schema.allOf.reduce((acc, schema) => {\n            const next = Visit(schema, references);\n            return typeof next === 'object' ? { ...acc, ...next } : next;\n        }, {});\n        if (!ValueCheck.Check(schema, references, value))\n            throw new ValueCreateIntersectTypeError(schema);\n        return value;\n    }\n}\nfunction TIterator(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return (function* () { })();\n    }\n}\nfunction TLiteral(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return schema.const;\n    }\n}\nfunction TNever(schema, references) {\n    throw new ValueCreateNeverTypeError(schema);\n}\nfunction TNot(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new ValueCreateNotTypeError(schema);\n    }\n}\nfunction TNull(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return null;\n    }\n}\nfunction TNumber(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction TObject(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const required = new Set(schema.required);\n        return (schema.default ||\n            Object.entries(schema.properties).reduce((acc, [key, schema]) => {\n                return required.has(key) ? { ...acc, [key]: Visit(schema, references) } : { ...acc };\n            }, {}));\n    }\n}\nfunction TPromise(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return Promise.resolve(Visit(schema.item, references));\n    }\n}\nfunction TRecord(schema, references) {\n    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {\n        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split('|');\n        return propertyKeys.reduce((acc, key) => {\n            return { ...acc, [key]: Visit(valueSchema, references) };\n        }, {});\n    }\n    else {\n        return {};\n    }\n}\nfunction TRef(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n        if (index === -1)\n            throw new ValueCreateDereferenceError(schema);\n        const target = references[index];\n        return Visit(target, references);\n    }\n}\nfunction TString(schema, references) {\n    if (schema.pattern !== undefined) {\n        if (!ValueGuard.HasPropertyKey(schema, 'default')) {\n            throw new Error('ValueCreate.String: String types with patterns must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else if (schema.format !== undefined) {\n        if (!ValueGuard.HasPropertyKey(schema, 'default')) {\n            throw new Error('ValueCreate.String: String types with formats must specify a default value');\n        }\n        else {\n            return schema.default;\n        }\n    }\n    else {\n        if (ValueGuard.HasPropertyKey(schema, 'default')) {\n            return schema.default;\n        }\n        else if (schema.minLength !== undefined) {\n            return Array.from({ length: schema.minLength })\n                .map(() => '.')\n                .join('');\n        }\n        else {\n            return '';\n        }\n    }\n}\nfunction TSymbol(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if ('value' in schema) {\n        return Symbol.for(schema.value);\n    }\n    else {\n        return Symbol();\n    }\n}\nfunction TTemplateLiteral(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    const expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);\n    if (!Types.TemplateLiteralFinite.Check(expression))\n        throw new ValueCreateTempateLiteralTypeError(schema);\n    const sequence = Types.TemplateLiteralGenerator.Generate(expression);\n    return sequence.next().value;\n}\nfunction TThis(schema, references) {\n    if (recursiveDepth++ > recursiveMaxDepth)\n        throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n        if (index === -1)\n            throw new ValueCreateDereferenceError(schema);\n        const target = references[index];\n        return Visit(target, references);\n    }\n}\nfunction TTuple(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    if (schema.items === undefined) {\n        return [];\n    }\n    else {\n        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));\n    }\n}\nfunction TUndefined(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction TUnion(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.anyOf.length === 0) {\n        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n    }\n    else {\n        return Visit(schema.anyOf[0], references);\n    }\n}\nfunction TUint8Array(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else if (schema.minByteLength !== undefined) {\n        return new Uint8Array(schema.minByteLength);\n    }\n    else {\n        return new Uint8Array(0);\n    }\n}\nfunction TUnknown(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return {};\n    }\n}\nfunction TVoid(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction TKind(schema, references) {\n    if (ValueGuard.HasPropertyKey(schema, 'default')) {\n        return schema.default;\n    }\n    else {\n        throw new Error('ValueCreate: User defined types must specify a default value');\n    }\n}\nfunction Visit(schema, references) {\n    const references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_);\n        case 'Array':\n            return TArray(schema_, references_);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_);\n        case 'BigInt':\n            return TBigInt(schema_, references_);\n        case 'Boolean':\n            return TBoolean(schema_, references_);\n        case 'Constructor':\n            return TConstructor(schema_, references_);\n        case 'Date':\n            return TDate(schema_, references_);\n        case 'Function':\n            return TFunction(schema_, references_);\n        case 'Integer':\n            return TInteger(schema_, references_);\n        case 'Intersect':\n            return TIntersect(schema_, references_);\n        case 'Iterator':\n            return TIterator(schema_, references_);\n        case 'Literal':\n            return TLiteral(schema_, references_);\n        case 'Never':\n            return TNever(schema_, references_);\n        case 'Not':\n            return TNot(schema_, references_);\n        case 'Null':\n            return TNull(schema_, references_);\n        case 'Number':\n            return TNumber(schema_, references_);\n        case 'Object':\n            return TObject(schema_, references_);\n        case 'Promise':\n            return TPromise(schema_, references_);\n        case 'Record':\n            return TRecord(schema_, references_);\n        case 'Ref':\n            return TRef(schema_, references_);\n        case 'String':\n            return TString(schema_, references_);\n        case 'Symbol':\n            return TSymbol(schema_, references_);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_);\n        case 'This':\n            return TThis(schema_, references_);\n        case 'Tuple':\n            return TTuple(schema_, references_);\n        case 'Undefined':\n            return TUndefined(schema_, references_);\n        case 'Union':\n            return TUnion(schema_, references_);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_);\n        case 'Unknown':\n            return TUnknown(schema_, references_);\n        case 'Void':\n            return TVoid(schema_, references_);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCreateUnknownTypeError(schema_);\n            return TKind(schema_, references_);\n    }\n}\n// --------------------------------------------------------------------------\n// State\n// --------------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nfunction Create(...args) {\n    recursiveDepth = 0;\n    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}\nexports.Create = Create;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cast = exports.ValueCastDereferenceError = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = exports.ValueCastReferenceTypeError = void 0;\nconst Types = require(\"../typebox\");\nconst ValueCreate = require(\"./create\");\nconst ValueCheck = require(\"./check\");\nconst ValueClone = require(\"./clone\");\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueCastReferenceTypeError extends Error {\n    constructor(schema) {\n        super(`ValueCast: Cannot locate referenced schema with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueCastReferenceTypeError = ValueCastReferenceTypeError;\nclass ValueCastArrayUniqueItemsTypeError extends Error {\n    constructor(schema, value) {\n        super('ValueCast: Array cast produced invalid data due to uniqueItems constraint');\n        this.schema = schema;\n        this.value = value;\n    }\n}\nexports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;\nclass ValueCastNeverTypeError extends Error {\n    constructor(schema) {\n        super('ValueCast: Never types cannot be cast');\n        this.schema = schema;\n    }\n}\nexports.ValueCastNeverTypeError = ValueCastNeverTypeError;\nclass ValueCastRecursiveTypeError extends Error {\n    constructor(schema) {\n        super('ValueCast.Recursive: Cannot cast recursive schemas');\n        this.schema = schema;\n    }\n}\nexports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;\nclass ValueCastUnknownTypeError extends Error {\n    constructor(schema) {\n        super('ValueCast: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;\nclass ValueCastDereferenceError extends Error {\n    constructor(schema) {\n        super(`ValueCast: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueCastDereferenceError = ValueCastDereferenceError;\n// --------------------------------------------------------------------------\n// The following will score a schema against a value. For objects, the score\n// is the tally of points awarded for each property of the value. Property\n// points are (1.0 / propertyCount) to prevent large property counts biasing\n// results. Properties that match literal values are maximally awarded as\n// literals are typically used as union discriminator fields.\n// --------------------------------------------------------------------------\nvar UnionCastCreate;\n(function (UnionCastCreate) {\n    function Score(schema, references, value) {\n        if (schema[Types.Kind] === 'Object' && typeof value === 'object' && !ValueGuard.IsNull(value)) {\n            const object = schema;\n            const keys = Object.getOwnPropertyNames(value);\n            const entries = Object.entries(object.properties);\n            const [point, max] = [1 / entries.length, entries.length];\n            return entries.reduce((acc, [key, schema]) => {\n                const literal = schema[Types.Kind] === 'Literal' && schema.const === value[key] ? max : 0;\n                const checks = ValueCheck.Check(schema, references, value[key]) ? point : 0;\n                const exists = keys.includes(key) ? point : 0;\n                return acc + (literal + checks + exists);\n            }, 0);\n        }\n        else {\n            return ValueCheck.Check(schema, references, value) ? 1 : 0;\n        }\n    }\n    function Select(union, references, value) {\n        let [select, best] = [union.anyOf[0], 0];\n        for (const schema of union.anyOf) {\n            const score = Score(schema, references, value);\n            if (score > best) {\n                select = schema;\n                best = score;\n            }\n        }\n        return select;\n    }\n    function Create(union, references, value) {\n        if ('default' in union) {\n            return union.default;\n        }\n        else {\n            const schema = Select(union, references, value);\n            return Cast(schema, references, value);\n        }\n    }\n    UnionCastCreate.Create = Create;\n})(UnionCastCreate || (UnionCastCreate = {}));\n// --------------------------------------------------------------------------\n// Cast\n// --------------------------------------------------------------------------\nfunction TAny(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TArray(schema, references, value) {\n    if (ValueCheck.Check(schema, references, value))\n        return ValueClone.Clone(value);\n    const created = ValueGuard.IsArray(value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n    const minimum = ValueGuard.IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;\n    const maximum = ValueGuard.IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;\n    const casted = maximum.map((value) => Visit(schema.items, references, value));\n    if (schema.uniqueItems !== true)\n        return casted;\n    const unique = [...new Set(casted)];\n    if (!ValueCheck.Check(schema, references, unique))\n        throw new ValueCastArrayUniqueItemsTypeError(schema, unique);\n    return unique;\n}\nfunction TAsyncIterator(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TBigInt(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TBoolean(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TConstructor(schema, references, value) {\n    if (ValueCheck.Check(schema, references, value))\n        return ValueCreate.Create(schema, references);\n    const required = new Set(schema.returns.required || []);\n    const result = function () { };\n    for (const [key, property] of Object.entries(schema.returns.properties)) {\n        if (!required.has(key) && value.prototype[key] === undefined)\n            continue;\n        result.prototype[key] = Visit(property, references, value.prototype[key]);\n    }\n    return result;\n}\nfunction TDate(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TFunction(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TInteger(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TIntersect(schema, references, value) {\n    const created = ValueCreate.Create(schema, references);\n    const mapped = ValueGuard.IsPlainObject(created) && ValueGuard.IsPlainObject(value) ? { ...created, ...value } : value;\n    return ValueCheck.Check(schema, references, mapped) ? mapped : ValueCreate.Create(schema, references);\n}\nfunction TIterator(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TLiteral(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TNever(schema, references, value) {\n    throw new ValueCastNeverTypeError(schema);\n}\nfunction TNot(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TNull(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TNumber(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TObject(schema, references, value) {\n    if (ValueCheck.Check(schema, references, value))\n        return value;\n    if (value === null || typeof value !== 'object')\n        return ValueCreate.Create(schema, references);\n    const required = new Set(schema.required || []);\n    const result = {};\n    for (const [key, property] of Object.entries(schema.properties)) {\n        if (!required.has(key) && value[key] === undefined)\n            continue;\n        result[key] = Visit(property, references, value[key]);\n    }\n    // additional schema properties\n    if (typeof schema.additionalProperties === 'object') {\n        const propertyNames = Object.getOwnPropertyNames(schema.properties);\n        for (const propertyName of Object.getOwnPropertyNames(value)) {\n            if (propertyNames.includes(propertyName))\n                continue;\n            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);\n        }\n    }\n    return result;\n}\nfunction TPromise(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TRecord(schema, references, value) {\n    if (ValueCheck.Check(schema, references, value))\n        return ValueClone.Clone(value);\n    if (value === null || typeof value !== 'object' || Array.isArray(value) || value instanceof Date)\n        return ValueCreate.Create(schema, references);\n    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const subschema = schema.patternProperties[subschemaPropertyName];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(subschema, references, propValue);\n    }\n    return result;\n}\nfunction TRef(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueCastDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TString(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);\n}\nfunction TSymbol(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TTemplateLiteral(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TThis(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueCastDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TTuple(schema, references, value) {\n    if (ValueCheck.Check(schema, references, value))\n        return ValueClone.Clone(value);\n    if (!ValueGuard.IsArray(value))\n        return ValueCreate.Create(schema, references);\n    if (schema.items === undefined)\n        return [];\n    return schema.items.map((schema, index) => Visit(schema, references, value[index]));\n}\nfunction TUndefined(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TUnion(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : UnionCastCreate.Create(schema, references, value);\n}\nfunction TUint8Array(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TUnknown(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TVoid(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction TKind(schema, references, value) {\n    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);\n}\nfunction Visit(schema, references, value) {\n    const references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_, value);\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return TBigInt(schema_, references_, value);\n        case 'Boolean':\n            return TBoolean(schema_, references_, value);\n        case 'Constructor':\n            return TConstructor(schema_, references_, value);\n        case 'Date':\n            return TDate(schema_, references_, value);\n        case 'Function':\n            return TFunction(schema_, references_, value);\n        case 'Integer':\n            return TInteger(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Iterator':\n            return TIterator(schema_, references_, value);\n        case 'Literal':\n            return TLiteral(schema_, references_, value);\n        case 'Never':\n            return TNever(schema_, references_, value);\n        case 'Not':\n            return TNot(schema_, references_, value);\n        case 'Null':\n            return TNull(schema_, references_, value);\n        case 'Number':\n            return TNumber(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Promise':\n            return TPromise(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'String':\n            return TString(schema_, references_, value);\n        case 'Symbol':\n            return TSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Undefined':\n            return TUndefined(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return TUnknown(schema_, references_, value);\n        case 'Void':\n            return TVoid(schema_, references_, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueCastUnknownTypeError(schema_);\n            return TKind(schema_, references_, value);\n    }\n}\n/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\nfunction Cast(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Cast = Cast;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Convert = exports.ValueConvertDereferenceError = exports.ValueConvertUnknownTypeError = void 0;\nconst Types = require(\"../typebox\");\nconst ValueClone = require(\"./clone\");\nconst ValueCheck = require(\"./check\");\nconst ValueGuard = require(\"./guard\");\n// --------------------------------------------------------------------------\n// Errors\n// --------------------------------------------------------------------------\nclass ValueConvertUnknownTypeError extends Error {\n    constructor(schema) {\n        super('ValueConvert: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;\nclass ValueConvertDereferenceError extends Error {\n    constructor(schema) {\n        super(`ValueConvert: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueConvertDereferenceError = ValueConvertDereferenceError;\n// --------------------------------------------------------------------------\n// Conversions\n// --------------------------------------------------------------------------\nfunction IsStringNumeric(value) {\n    return ValueGuard.IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));\n}\nfunction IsValueToString(value) {\n    return ValueGuard.IsBigInt(value) || ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value);\n}\nfunction IsValueTrue(value) {\n    return value === true || (ValueGuard.IsNumber(value) && value === 1) || (ValueGuard.IsBigInt(value) && value === BigInt('1')) || (ValueGuard.IsString(value) && (value.toLowerCase() === 'true' || value === '1'));\n}\nfunction IsValueFalse(value) {\n    return value === false || (ValueGuard.IsNumber(value) && value === 0) || (ValueGuard.IsBigInt(value) && value === BigInt('0')) || (ValueGuard.IsString(value) && (value.toLowerCase() === 'false' || value === '0'));\n}\nfunction IsTimeStringWithTimeZone(value) {\n    return ValueGuard.IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsTimeStringWithoutTimeZone(value) {\n    return ValueGuard.IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateTimeStringWithTimeZone(value) {\n    return ValueGuard.IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsDateTimeStringWithoutTimeZone(value) {\n    return ValueGuard.IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateString(value) {\n    return ValueGuard.IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value);\n}\n// --------------------------------------------------------------------------\n// Convert\n// --------------------------------------------------------------------------\nfunction TryConvertLiteralString(value, target) {\n    const conversion = TryConvertString(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralNumber(value, target) {\n    const conversion = TryConvertNumber(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralBoolean(value, target) {\n    const conversion = TryConvertBoolean(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteral(schema, value) {\n    if (typeof schema.const === 'string') {\n        return TryConvertLiteralString(value, schema.const);\n    }\n    else if (typeof schema.const === 'number') {\n        return TryConvertLiteralNumber(value, schema.const);\n    }\n    else if (typeof schema.const === 'boolean') {\n        return TryConvertLiteralBoolean(value, schema.const);\n    }\n    else {\n        return ValueClone.Clone(value);\n    }\n}\nfunction TryConvertBoolean(value) {\n    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;\n}\nfunction TryConvertBigInt(value) {\n    return IsStringNumeric(value) ? BigInt(parseInt(value)) : ValueGuard.IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? 0 : IsValueTrue(value) ? 1 : value;\n}\nfunction TryConvertString(value) {\n    return IsValueToString(value) ? value.toString() : ValueGuard.IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;\n}\nfunction TryConvertNumber(value) {\n    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertInteger(value) {\n    return IsStringNumeric(value) ? parseInt(value) : ValueGuard.IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertNull(value) {\n    return ValueGuard.IsString(value) && value.toLowerCase() === 'null' ? null : value;\n}\nfunction TryConvertUndefined(value) {\n    return ValueGuard.IsString(value) && value === 'undefined' ? undefined : value;\n}\nfunction TryConvertDate(value) {\n    // --------------------------------------------------------------------------\n    // note: this function may return an invalid dates for the regex tests\n    // above. Invalid dates will however be checked during the casting function\n    // and will return a epoch date if invalid. Consider better string parsing\n    // for the iso dates in future revisions.\n    // --------------------------------------------------------------------------\n    return ValueGuard.IsDate(value)\n        ? value\n        : ValueGuard.IsNumber(value)\n            ? new Date(value)\n            : IsValueTrue(value)\n                ? new Date(1)\n                : IsValueFalse(value)\n                    ? new Date(0)\n                    : IsStringNumeric(value)\n                        ? new Date(parseInt(value))\n                        : IsTimeStringWithoutTimeZone(value)\n                            ? new Date(`1970-01-01T${value}.000Z`)\n                            : IsTimeStringWithTimeZone(value)\n                                ? new Date(`1970-01-01T${value}`)\n                                : IsDateTimeStringWithoutTimeZone(value)\n                                    ? new Date(`${value}.000Z`)\n                                    : IsDateTimeStringWithTimeZone(value)\n                                        ? new Date(value)\n                                        : IsDateString(value)\n                                            ? new Date(`${value}T00:00:00.000Z`)\n                                            : value;\n}\n// --------------------------------------------------------------------------\n// Cast\n// --------------------------------------------------------------------------\nfunction TAny(schema, references, value) {\n    return value;\n}\nfunction TArray(schema, references, value) {\n    if (ValueGuard.IsArray(value)) {\n        return value.map((value) => Visit(schema.items, references, value));\n    }\n    return value;\n}\nfunction TAsyncIterator(schema, references, value) {\n    return value;\n}\nfunction TBigInt(schema, references, value) {\n    return TryConvertBigInt(value);\n}\nfunction TBoolean(schema, references, value) {\n    return TryConvertBoolean(value);\n}\nfunction TConstructor(schema, references, value) {\n    return ValueClone.Clone(value);\n}\nfunction TDate(schema, references, value) {\n    return TryConvertDate(value);\n}\nfunction TFunction(schema, references, value) {\n    return value;\n}\nfunction TInteger(schema, references, value) {\n    return TryConvertInteger(value);\n}\nfunction TIntersect(schema, references, value) {\n    return value;\n}\nfunction TIterator(schema, references, value) {\n    return value;\n}\nfunction TLiteral(schema, references, value) {\n    return TryConvertLiteral(schema, value);\n}\nfunction TNever(schema, references, value) {\n    return value;\n}\nfunction TNull(schema, references, value) {\n    return TryConvertNull(value);\n}\nfunction TNumber(schema, references, value) {\n    return TryConvertNumber(value);\n}\nfunction TObject(schema, references, value) {\n    if (ValueGuard.IsObject(value))\n        return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {\n            return value[key] !== undefined ? { ...acc, [key]: Visit(schema.properties[key], references, value[key]) } : { ...acc };\n        }, value);\n    return value;\n}\nfunction TPromise(schema, references, value) {\n    return value;\n}\nfunction TRecord(schema, references, value) {\n    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[propertyKey];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(property, references, propValue);\n    }\n    return result;\n}\nfunction TRef(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueConvertDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TString(schema, references, value) {\n    return TryConvertString(value);\n}\nfunction TSymbol(schema, references, value) {\n    return value;\n}\nfunction TTemplateLiteral(schema, references, value) {\n    return value;\n}\nfunction TThis(schema, references, value) {\n    const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n    if (index === -1)\n        throw new ValueConvertDereferenceError(schema);\n    const target = references[index];\n    return Visit(target, references, value);\n}\nfunction TTuple(schema, references, value) {\n    if (ValueGuard.IsArray(value) && !ValueGuard.IsUndefined(schema.items)) {\n        return value.map((value, index) => {\n            return index < schema.items.length ? Visit(schema.items[index], references, value) : value;\n        });\n    }\n    return value;\n}\nfunction TUndefined(schema, references, value) {\n    return TryConvertUndefined(value);\n}\nfunction TUnion(schema, references, value) {\n    for (const subschema of schema.anyOf) {\n        const converted = Visit(subschema, references, value);\n        if (ValueCheck.Check(subschema, references, converted)) {\n            return converted;\n        }\n    }\n    return value;\n}\nfunction TUint8Array(schema, references, value) {\n    return value;\n}\nfunction TUnknown(schema, references, value) {\n    return value;\n}\nfunction TVoid(schema, references, value) {\n    return value;\n}\nfunction TKind(schema, references, value) {\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema[Types.Kind]) {\n        case 'Any':\n            return TAny(schema_, references_, value);\n        case 'Array':\n            return TArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return TAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return TBigInt(schema_, references_, value);\n        case 'Boolean':\n            return TBoolean(schema_, references_, value);\n        case 'Constructor':\n            return TConstructor(schema_, references_, value);\n        case 'Date':\n            return TDate(schema_, references_, value);\n        case 'Function':\n            return TFunction(schema_, references_, value);\n        case 'Integer':\n            return TInteger(schema_, references_, value);\n        case 'Intersect':\n            return TIntersect(schema_, references_, value);\n        case 'Iterator':\n            return TIterator(schema_, references_, value);\n        case 'Literal':\n            return TLiteral(schema_, references_, value);\n        case 'Never':\n            return TNever(schema_, references_, value);\n        case 'Null':\n            return TNull(schema_, references_, value);\n        case 'Number':\n            return TNumber(schema_, references_, value);\n        case 'Object':\n            return TObject(schema_, references_, value);\n        case 'Promise':\n            return TPromise(schema_, references_, value);\n        case 'Record':\n            return TRecord(schema_, references_, value);\n        case 'Ref':\n            return TRef(schema_, references_, value);\n        case 'String':\n            return TString(schema_, references_, value);\n        case 'Symbol':\n            return TSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return TTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return TThis(schema_, references_, value);\n        case 'Tuple':\n            return TTuple(schema_, references_, value);\n        case 'Undefined':\n            return TUndefined(schema_, references_, value);\n        case 'Union':\n            return TUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return TUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return TUnknown(schema_, references_, value);\n        case 'Void':\n            return TVoid(schema_, references_, value);\n        default:\n            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                throw new ValueConvertUnknownTypeError(schema_);\n            return TKind(schema_, references_, value);\n    }\n}\n/** Converts any type mismatched values to their target type if a reasonable conversion is possible. */\nfunction Convert(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nexports.Convert = Convert;\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Value = void 0;\nconst ValueErrors = require(\"../errors/index\");\nconst ValueMutate = require(\"./mutate\");\nconst ValueHash = require(\"./hash\");\nconst ValueEqual = require(\"./equal\");\nconst ValueCast = require(\"./cast\");\nconst ValueClone = require(\"./clone\");\nconst ValueConvert = require(\"./convert\");\nconst ValueCreate = require(\"./create\");\nconst ValueCheck = require(\"./check\");\nconst ValueDelta = require(\"./delta\");\n/** Functions to perform structural operations on JavaScript values */\nvar Value;\n(function (Value) {\n    /** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\n    function Cast(...args) {\n        return ValueCast.Cast.apply(ValueCast, args);\n    }\n    Value.Cast = Cast;\n    /** Creates a value from the given type */\n    function Create(...args) {\n        return ValueCreate.Create.apply(ValueCreate, args);\n    }\n    Value.Create = Create;\n    /** Returns true if the value matches the given type */\n    function Check(...args) {\n        return ValueCheck.Check.apply(ValueCheck, args);\n    }\n    Value.Check = Check;\n    /** Converts any type mismatched values to their target type if a reasonable conversion is possible */\n    function Convert(...args) {\n        return ValueConvert.Convert.apply(ValueConvert, args);\n    }\n    Value.Convert = Convert;\n    /** Returns a structural clone of the given value */\n    function Clone(value) {\n        return ValueClone.Clone(value);\n    }\n    Value.Clone = Clone;\n    /** Returns an iterator for each error in this value. */\n    function Errors(...args) {\n        return ValueErrors.Errors.apply(ValueErrors, args);\n    }\n    Value.Errors = Errors;\n    /** Returns true if left and right values are structurally equal */\n    function Equal(left, right) {\n        return ValueEqual.Equal(left, right);\n    }\n    Value.Equal = Equal;\n    /** Returns edits to transform the current value into the next value */\n    function Diff(current, next) {\n        return ValueDelta.Diff(current, next);\n    }\n    Value.Diff = Diff;\n    /** Returns a FNV1A-64 non cryptographic hash of the given value */\n    function Hash(value) {\n        return ValueHash.Hash(value);\n    }\n    Value.Hash = Hash;\n    /** Returns a new value with edits applied to the given value */\n    function Patch(current, edits) {\n        return ValueDelta.Patch(current, edits);\n    }\n    Value.Patch = Patch;\n    /** Performs a deep mutable value assignment while retaining internal references. */\n    function Mutate(current, next) {\n        ValueMutate.Mutate(current, next);\n    }\n    Value.Mutate = Mutate;\n})(Value || (exports.Value = Value = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/value\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;\nvar index_1 = require(\"../errors/index\");\nObject.defineProperty(exports, \"ValueErrorType\", { enumerable: true, get: function () { return index_1.ValueErrorType; } });\nObject.defineProperty(exports, \"ValueErrorIterator\", { enumerable: true, get: function () { return index_1.ValueErrorIterator; } });\nvar delta_1 = require(\"./delta\");\nObject.defineProperty(exports, \"Edit\", { enumerable: true, get: function () { return delta_1.Edit; } });\nObject.defineProperty(exports, \"Insert\", { enumerable: true, get: function () { return delta_1.Insert; } });\nObject.defineProperty(exports, \"Update\", { enumerable: true, get: function () { return delta_1.Update; } });\nObject.defineProperty(exports, \"Delete\", { enumerable: true, get: function () { return delta_1.Delete; } });\nvar pointer_1 = require(\"./pointer\");\nObject.defineProperty(exports, \"ValuePointer\", { enumerable: true, get: function () { return pointer_1.ValuePointer; } });\nvar value_1 = require(\"./value\");\nObject.defineProperty(exports, \"Value\", { enumerable: true, get: function () { return value_1.Value; } });\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeCompiler = exports.TypeCompilerTypeGuardError = exports.TypeCompilerDereferenceError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;\nconst index_1 = require(\"../system/index\");\nconst Types = require(\"../typebox\");\nconst ValueErrors = require(\"../errors/index\");\nconst ValueHash = require(\"../value/hash\");\nconst ValueGuard = require(\"../value/guard\");\n// -------------------------------------------------------------------\n// TypeCheck\n// -------------------------------------------------------------------\nclass TypeCheck {\n    constructor(schema, references, checkFunc, code) {\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    Code() {\n        return this.code;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors(value) {\n        return ValueErrors.Errors(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */\n    Check(value) {\n        return this.checkFunc(value);\n    }\n}\nexports.TypeCheck = TypeCheck;\n// -------------------------------------------------------------------\n// Character\n// -------------------------------------------------------------------\nvar Character;\n(function (Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// -------------------------------------------------------------------\n// MemberExpression\n// -------------------------------------------------------------------\nvar MemberExpression;\n(function (MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0)\n            return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check)\n                return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// -------------------------------------------------------------------\n// Identifier\n// -------------------------------------------------------------------\nvar Identifier;\n(function (Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for (let i = 0; i < $id.length; i++) {\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            }\n            else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join('').replace(/__/g, '_');\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// -------------------------------------------------------------------\n// Errors\n// -------------------------------------------------------------------\nclass TypeCompilerUnknownTypeError extends Error {\n    constructor(schema) {\n        super('TypeCompiler: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;\nclass TypeCompilerDereferenceError extends Error {\n    constructor(schema) {\n        super(`TypeCompiler: Unable to dereference type with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerDereferenceError = TypeCompilerDereferenceError;\nclass TypeCompilerTypeGuardError extends Error {\n    constructor(schema) {\n        super('TypeCompiler: Preflight validation check failed to guard for the given schema');\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;\n/** Compiles Types for Runtime Type Checking */\nvar TypeCompiler;\n(function (TypeCompiler) {\n    // ----------------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Types.Kind] === 'Any' || schema[Types.Kind] === 'Unknown';\n    }\n    // -------------------------------------------------------------------\n    // Polices\n    // -------------------------------------------------------------------\n    function IsExactOptionalProperty(value, key, expression) {\n        return index_1.TypeSystem.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    function IsObjectCheck(value) {\n        return !index_1.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    function IsRecordCheck(value) {\n        return !index_1.TypeSystem.AllowArrayObjects\n            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`\n            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    function IsNumberCheck(value) {\n        return !index_1.TypeSystem.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;\n    }\n    function IsVoidCheck(value) {\n        return index_1.TypeSystem.AllowVoidNull ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    // -------------------------------------------------------------------\n    // Types\n    // -------------------------------------------------------------------\n    function* TAny(schema, references, value) {\n        yield 'true';\n    }\n    function* TArray(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];\n        if (ValueGuard.IsNumber(schema.minItems))\n            yield `${value}.length >= ${schema.minItems}`;\n        if (ValueGuard.IsNumber(schema.maxItems))\n            yield `${value}.length <= ${schema.maxItems}`;\n        const elementExpression = CreateExpression(schema.items, references, 'value');\n        yield `${value}.every((${parameter}) => ${elementExpression})`;\n        if (Types.TypeGuard.TSchema(schema.contains) || ValueGuard.IsNumber(schema.minContains) || ValueGuard.IsNumber(schema.maxContains)) {\n            const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();\n            const checkExpression = CreateExpression(containsSchema, references, 'value');\n            const checkMinContains = ValueGuard.IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];\n            const checkMaxContains = ValueGuard.IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];\n            const checkCount = `const count = ${value}.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;\n            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');\n            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;\n        }\n        if (schema.uniqueItems === true) {\n            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;\n            const block = `const set = new Set(); for(const element of value) { ${check} }`;\n            yield `((${parameter}) => { ${block} )(${value})`;\n        }\n    }\n    function* TAsyncIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;\n    }\n    function* TBigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if (ValueGuard.IsBigInt(schema.multipleOf))\n            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n        if (ValueGuard.IsBigInt(schema.exclusiveMinimum))\n            yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if (ValueGuard.IsBigInt(schema.exclusiveMaximum))\n            yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if (ValueGuard.IsBigInt(schema.minimum))\n            yield `${value} >= BigInt(${schema.minimum})`;\n        if (ValueGuard.IsBigInt(schema.maximum))\n            yield `${value} <= BigInt(${schema.maximum})`;\n    }\n    function* TBoolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* TConstructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* TDate(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if (ValueGuard.IsNumber(schema.exclusiveMinimumTimestamp))\n            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if (ValueGuard.IsNumber(schema.exclusiveMaximumTimestamp))\n            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if (ValueGuard.IsNumber(schema.minimumTimestamp))\n            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if (ValueGuard.IsNumber(schema.maximumTimestamp))\n            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n    }\n    function* TFunction(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* TInteger(schema, references, value) {\n        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;\n        if (ValueGuard.IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n        if (ValueGuard.IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (ValueGuard.IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (ValueGuard.IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (ValueGuard.IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n    }\n    function* TIntersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        }\n        else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {\n            const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        }\n        else {\n            yield `(${check1})`;\n        }\n    }\n    function* TIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;\n    }\n    function* TLiteral(schema, references, value) {\n        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {\n            yield `(${value} === ${schema.const})`;\n        }\n        else {\n            yield `(${value} === '${schema.const}')`;\n        }\n    }\n    function* TNever(schema, references, value) {\n        yield `false`;\n    }\n    function* TNot(schema, references, value) {\n        const expression = CreateExpression(schema.not, references, value);\n        yield `(!${expression})`;\n    }\n    function* TNull(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* TNumber(schema, references, value) {\n        yield IsNumberCheck(value);\n        if (ValueGuard.IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n        if (ValueGuard.IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (ValueGuard.IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (ValueGuard.IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (ValueGuard.IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n    }\n    function* TObject(schema, references, value) {\n        yield IsObjectCheck(value);\n        if (ValueGuard.IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (ValueGuard.IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys) {\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))\n                    yield `('${knownKey}' in ${value})`;\n            }\n            else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            }\n            else {\n                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* TPromise(schema, references, value) {\n        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;\n    }\n    function* TRecord(schema, references, value) {\n        yield IsRecordCheck(value);\n        if (ValueGuard.IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (ValueGuard.IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n        const variable = CreateVariable(`new RegExp(/${patternKey}/)`);\n        const check1 = CreateExpression(patternSchema, references, 'value');\n        const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';\n        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* TRef(schema, references, value) {\n        const index = references.findIndex((foreign) => foreign.$id === schema.$ref);\n        if (index === -1)\n            throw new TypeCompilerDereferenceError(schema);\n        const target = references[index];\n        // Reference: If we have seen this reference before we can just yield and return the function call.\n        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref))\n            return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* TString(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if (ValueGuard.IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        if (ValueGuard.IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (schema.pattern !== undefined) {\n            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n            yield `${variable}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* TSymbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* TTemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n        yield `${variable}.test(${value})`;\n    }\n    function* TThis(schema, references, value) {\n        const func = CreateFunctionName(schema.$ref);\n        yield `${func}(${value})`;\n    }\n    function* TTuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined)\n            return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for (let i = 0; i < schema.items.length; i++) {\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* TUndefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* TUnion(schema, references, value) {\n        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));\n        yield `(${expressions.join(' || ')})`;\n    }\n    function* TUint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if (ValueGuard.IsNumber(schema.maxByteLength))\n            yield `(${value}.length <= ${schema.maxByteLength})`;\n        if (ValueGuard.IsNumber(schema.minByteLength))\n            yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* TUnknown(schema, references, value) {\n        yield 'true';\n    }\n    function* TVoid(schema, references, value) {\n        yield IsVoidCheck(value);\n    }\n    function* TKind(schema, references, value) {\n        const instance = state.instances.size;\n        state.instances.set(instance, schema);\n        yield `kind('${schema[Types.Kind]}', ${instance}, ${value})`;\n    }\n    function* Visit(schema, references, value, useHoisting = true) {\n        const references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        // ----------------------------------------------------------------------------------\n        // Hoisting\n        // ----------------------------------------------------------------------------------\n        if (useHoisting && ValueGuard.IsString(schema.$id)) {\n            const functionName = CreateFunctionName(schema.$id);\n            if (state.functions.has(functionName)) {\n                return yield `${functionName}(${value})`;\n            }\n            else {\n                const functionCode = CreateFunction(functionName, schema, references, 'value', false);\n                state.functions.set(functionName, functionCode);\n                return yield `${functionName}(${value})`;\n            }\n        }\n        // ----------------------------------------------------------------------------------\n        // Types\n        // ----------------------------------------------------------------------------------\n        switch (schema_[Types.Kind]) {\n            case 'Any':\n                return yield* TAny(schema_, references_, value);\n            case 'Array':\n                return yield* TArray(schema_, references_, value);\n            case 'AsyncIterator':\n                return yield* TAsyncIterator(schema_, references_, value);\n            case 'BigInt':\n                return yield* TBigInt(schema_, references_, value);\n            case 'Boolean':\n                return yield* TBoolean(schema_, references_, value);\n            case 'Constructor':\n                return yield* TConstructor(schema_, references_, value);\n            case 'Date':\n                return yield* TDate(schema_, references_, value);\n            case 'Function':\n                return yield* TFunction(schema_, references_, value);\n            case 'Integer':\n                return yield* TInteger(schema_, references_, value);\n            case 'Intersect':\n                return yield* TIntersect(schema_, references_, value);\n            case 'Iterator':\n                return yield* TIterator(schema_, references_, value);\n            case 'Literal':\n                return yield* TLiteral(schema_, references_, value);\n            case 'Never':\n                return yield* TNever(schema_, references_, value);\n            case 'Not':\n                return yield* TNot(schema_, references_, value);\n            case 'Null':\n                return yield* TNull(schema_, references_, value);\n            case 'Number':\n                return yield* TNumber(schema_, references_, value);\n            case 'Object':\n                return yield* TObject(schema_, references_, value);\n            case 'Promise':\n                return yield* TPromise(schema_, references_, value);\n            case 'Record':\n                return yield* TRecord(schema_, references_, value);\n            case 'Ref':\n                return yield* TRef(schema_, references_, value);\n            case 'String':\n                return yield* TString(schema_, references_, value);\n            case 'Symbol':\n                return yield* TSymbol(schema_, references_, value);\n            case 'TemplateLiteral':\n                return yield* TTemplateLiteral(schema_, references_, value);\n            case 'This':\n                return yield* TThis(schema_, references_, value);\n            case 'Tuple':\n                return yield* TTuple(schema_, references_, value);\n            case 'Undefined':\n                return yield* TUndefined(schema_, references_, value);\n            case 'Union':\n                return yield* TUnion(schema_, references_, value);\n            case 'Uint8Array':\n                return yield* TUint8Array(schema_, references_, value);\n            case 'Unknown':\n                return yield* TUnknown(schema_, references_, value);\n            case 'Void':\n                return yield* TVoid(schema_, references_, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind]))\n                    throw new TypeCompilerUnknownTypeError(schema);\n                return yield* TKind(schema_, references_, value);\n        }\n    }\n    // -------------------------------------------------------------------\n    // Compiler State\n    // -------------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: 'javascript',\n        functions: new Map(),\n        variables: new Map(),\n        instances: new Map() // exterior kind instances\n    };\n    // -------------------------------------------------------------------\n    // Compiler Factory\n    // -------------------------------------------------------------------\n    function CreateExpression(schema, references, value, useHoisting = true) {\n        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;\n    }\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateVariable(expression) {\n        const variableName = `local_${state.variables.size}`;\n        state.variables.set(variableName, `const ${variableName} = ${expression}`);\n        return variableName;\n    }\n    function CreateFunction(name, schema, references, value, useHoisting = true) {\n        const [newline, pad] = ['\\n', (length) => ''.padStart(length, ' ')];\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);\n        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\\n}`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === 'typescript' ? `: ${type}` : '';\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === 'typescript' ? `: ${type}` : '';\n    }\n    // -------------------------------------------------------------------\n    // Compile\n    // -------------------------------------------------------------------\n    function Build(schema, references, options) {\n        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const functions = [...state.functions.values()];\n        const variables = [...state.variables.values()];\n        // prettier-ignore\n        const checkFunction = ValueGuard.IsString(schema.$id) // ensure top level schemas with $id's are hoisted\n            ? `return function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}`\n            : `return ${functionCode}`;\n        return [...variables, ...functions, checkFunction].join('\\n');\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    function Code(...args) {\n        const defaults = { language: 'javascript' };\n        // prettier-ignore\n        const [schema, references, options] = (args.length === 2 && ValueGuard.IsArray(args[1]) ? [args[0], args[1], defaults] :\n            args.length === 2 && !ValueGuard.IsArray(args[1]) ? [args[0], [], args[1]] :\n                args.length === 3 ? [args[0], args[1], args[2]] :\n                    args.length === 1 ? [args[0], [], defaults] :\n                        [null, [], defaults]);\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.instances.clear();\n        if (!Types.TypeGuard.TSchema(schema))\n            throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)\n            if (!Types.TypeGuard.TSchema(schema))\n                throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references, options);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles the given type for runtime type checking. This compiler only accepts known TypeBox types non-inclusive of unsafe types. */\n    function Compile(schema, references = []) {\n        const generatedCode = Code(schema, references, { language: 'javascript' });\n        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);\n        const instances = new Map(state.instances);\n        function typeRegistryFunction(kind, instance, value) {\n            if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))\n                return false;\n            const schema = instances.get(instance);\n            const checkFunc = Types.TypeRegistry.Get(kind);\n            return checkFunc(schema, value);\n        }\n        function formatRegistryFunction(format, value) {\n            if (!Types.FormatRegistry.Has(format))\n                return false;\n            const checkFunc = Types.FormatRegistry.Get(format);\n            return checkFunc(value);\n        }\n        function valueHashFunction(value) {\n            return ValueHash.Hash(value);\n        }\n        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, valueHashFunction);\n        return new TypeCheck(schema, references, checkFunction, generatedCode);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));\n",
  "\"use strict\";\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueErrorType = void 0;\nvar index_1 = require(\"../errors/index\");\nObject.defineProperty(exports, \"ValueErrorType\", { enumerable: true, get: function () { return index_1.ValueErrorType; } });\n__exportStar(require(\"./compiler\"), exports);\n",
  "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
  "\"use strict\";\n\nconst fastDecode = require(\"fast-decode-uri-component\");\n\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = Object.create(null);\n\n/**\n * @callback parse\n * @param {string} input\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n\n  if (typeof input !== \"string\") {\n    return result;\n  }\n\n  let inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex);\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = fastDecode(key) || key;\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n\n          if (shouldDecodeValue) {\n            value = fastDecode(value) || value;\n          }\n        }\n        const currentValue = result[key];\n\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = parse;\n",
  "// This file is taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n);\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// rome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, // 112 - 127\n]);\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n\n      if (++i === len) break outer;\n\n      c = str.charCodeAt(i);\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff;\n\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2);\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = { encodeString };\n",
  "\"use strict\";\n\nconst { encodeString } = require(\"./internals/querystring\");\n\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\") {\n    return value.toString();\n  } else if (type === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n\n  return \"\";\n}\n\n/**\n * @param {Record<string, string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} input\n * @returns {string}\n */\nfunction stringify(input) {\n  let result = \"\";\n\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n\n    if (i) {\n      result += separator;\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = stringify;\n",
  "\"use strict\";\n\nconst parse = require(\"./parse\");\nconst stringify = require(\"./stringify\");\n\nconst fastQuerystring = {\n  parse,\n  stringify,\n};\n\n/**\n * Enable TS and JS support\n *\n * - `const qs = require('fast-querystring')`\n * - `import qs from 'fast-querystring'`\n */\nmodule.exports = fastQuerystring;\nmodule.exports.default = fastQuerystring;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n",
  "let e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});export class Memoirist{root={};history=[];static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g};add(a,l,i){let s;if(\"string\"!=typeof l)throw TypeError(\"Route path must be a string\");\"\"===l?l=\"/\":\"/\"!==l[0]&&(l=`/${l}`),this.history.push([a,l,i]);let n=\"*\"===l[l.length-1];n&&(l=l.slice(0,-1));let o=l.split(Memoirist.regex.static),u=l.match(Memoirist.regex.params)||[];\"\"===o[o.length-1]&&o.pop(),s=this.root[a]?this.root[a]:this.root[a]=e(\"/\");let p=0;for(let a=0;a<o.length;++a){let i=o[a];if(a>0){let t=u[p++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(i);continue}s=a.inert}for(let r=0;;){if(r===i.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(i,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(i.charCodeAt(r))){s=s.inert.get(i.charCodeAt(r)),i=i.slice(r),r=0;continue}let t=e(i.slice(r));s.inert.set(i.charCodeAt(r),t),s=t;break}if(i[r]!==s.part[r]){let a=t(s,s.part.slice(r)),l=e(i.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,l])),s=l;break}++r}}if(p<u.length){let e=u[p],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route \"${l}\" with parameter \"${t}\" because a route already exists with a different parameter name (\"${s.params.paramName}\") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return n?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?a(t,t.length,r,0):null}}let a=(e,t,r,l)=>{let i=r?.part,s=l+i.length;if(i.length>1){if(s>t)return null;if(i.length<15){for(let t=1,r=l+1;t<i.length;++t,++r)if(i.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(l,s)!==i)return null}if(s===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":\"\"}}:null;if(null!==r.inert){let l=r.inert.get(e.charCodeAt(s));if(void 0!==l){let r=a(e,t,l,s);if(null!==r)return r}}if(null!==r.params){let l=r.params,i=e.indexOf(\"/\",s);if(i!==s){if(-1===i||i>=t){if(null!==l.store){let r={};return r[l.paramName]=e.substring(s,t),{store:l.store,params:r}}}else if(null!==l.inert){let r=a(e,t,l.inert,i);if(null!==r)return r.params[l.paramName]=e.substring(s,i),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{\"*\":e.substring(s,t)}}:null};export default Memoirist;",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\n// @ts-ignore\nimport Mergician from 'mergician'\n\nimport type {\n\tElysiaInstance,\n\tLifeCycleStore,\n\tLocalHook,\n\tTypedSchema,\n\tRegisteredHook,\n\tWithArray\n} from './types'\n\nexport const mergeDeep = Mergician({\n\tappendArrays: true\n})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta: LocalHook<any, any> | LifeCycleStore<any>,\n\tb: LocalHook<any, any>\n): RegisteredHook<any> => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\n\t\terror: mergeObjectArray(a.error ?? [], b?.error ?? [])\n\t}\n}\n\n// const isObject = (item: any): item is Object =>\n// \titem && typeof item === 'object' && !Array.isArray(item)\n\n// https://stackoverflow.com/a/37164538\n// export const mergeDeep = <A extends Object = Object, B extends Object = Object>(\n// \ttarget: A,\n// \tsource: B\n// ): DeepMergeTwoTypes<A, B> => {\n// \tconst output: Partial<DeepMergeTwoTypes<A, B>> = Object.assign({}, target)\n// \tif (isObject(target) && isObject(source)) {\n// \t\tObject.keys(source).forEach((key) => {\n// \t\t\t// @ts-ignore\n// \t\t\tif (isObject(source[key])) {\n// \t\t\t\tif (!(key in target))\n// \t\t\t\t\t// @ts-ignore\n// \t\t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t\t// @ts-ignore\n// \t\t\t\telse output[key] = mergeDeep(target[key], source[key])\n// \t\t\t} else {\n// \t\t\t\t// @ts-ignore\n// \t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t}\n// \t\t})\n// \t}\n\n// \treturn output as DeepMergeTwoTypes<A, B>\n// }\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema)\n}\n\nexport const getResponseSchemaValidator = (\n\ts: TypedSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord)\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord)\n\t\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema)\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = <\n\tA extends ElysiaInstance,\n\tB extends ElysiaInstance\n>(\n\ta: LifeCycleStore<A>,\n\tb: LifeCycleStore<B> | LocalHook<{}, B>,\n\tchecksum?: number\n): LifeCycleStore<A & B> => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\tif (checksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(a.parse as any, b?.parse ?? ([] as any)).map(\n\t\t\tinjectChecksum\n\t\t),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = <T extends LocalHook<any, any>>(\n\thook: T,\n\tinject = true\n): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as T\n}\n\nexport const asGlobal = <T extends WithArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends WithArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = <T extends LocalHook<any, any>>(hook: T): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as T\n}\n",
  "/*!\n * mergician\n * v1.1.0\n * https://jhildenbiddle.github.io/mergician/\n * (c) 2022-2023 John Hildenbiddle\n * MIT license\n */\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// src/util.cjs\nvar require_util = __commonJS({\n  \"src/util.cjs\"(exports, module) {\n    function countOccurrences(...arrays) {\n      const countObj = {};\n      arrays.forEach((array) => {\n        array.forEach((v) => {\n          countObj[v] = v in countObj ? ++countObj[v] : 1;\n        });\n      });\n      return countObj;\n    }\n    function getInMultiple(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] > 1);\n    }\n    function getInAll(...arrays) {\n      return arrays.reduce(\n        (acc, curr) => acc.filter(Set.prototype.has, new Set(curr))\n      );\n    }\n    function getNotInMultiple(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] === 1);\n    }\n    function getNotInAll(...arrays) {\n      const countObj = countOccurrences(...arrays);\n      return Object.keys(countObj).filter((v) => countObj[v] < arrays.length);\n    }\n    function getObjectKeys(obj, includeProto = false) {\n      if (includeProto) {\n        const keys = [];\n        for (const key in obj) {\n          keys.push(key);\n        }\n        return keys;\n      } else {\n        return Object.keys(obj);\n      }\n    }\n    function isObject(value) {\n      return typeof value === \"object\" && value !== null && !Array.isArray(value);\n    }\n    function isPropDescriptor(obj) {\n      if (!isObject(obj)) {\n        return false;\n      }\n      const hasFlagKey = [\"writable\", \"enumerable\", \"configurable\"].some((key) => key in obj);\n      const hasMethod = [\"get\", \"set\"].some((key) => typeof obj[key] === \"function\");\n      const hasMethodKeys = [\"get\", \"set\"].every((key) => key in obj);\n      let isDescriptor = \"value\" in obj && hasFlagKey || hasMethod && (hasMethodKeys || hasFlagKey);\n      if (isDescriptor) {\n        const validKeys = [\n          \"configurable\",\n          \"get\",\n          \"set\",\n          \"enumerable\",\n          \"value\",\n          \"writable\"\n        ];\n        isDescriptor = Object.keys(obj).some((key) => !(key in validKeys));\n      }\n      return isDescriptor;\n    }\n    module.exports = {\n      countOccurrences,\n      getInMultiple,\n      getInAll,\n      getNotInMultiple,\n      getNotInAll,\n      getObjectKeys,\n      isObject,\n      isPropDescriptor\n    };\n  }\n});\n\n// src/index.cjs\nvar require_src = __commonJS({\n  \"src/index.cjs\"(exports, module) {\n    var {\n      getInMultiple,\n      getInAll,\n      getNotInMultiple,\n      getNotInAll,\n      getObjectKeys,\n      isObject,\n      isPropDescriptor\n    } = require_util();\n    var defaults = {\n      // Keys\n      onlyKeys: [],\n      skipKeys: [],\n      onlyCommonKeys: false,\n      onlyUniversalKeys: false,\n      skipCommonKeys: false,\n      skipUniversalKeys: false,\n      // Values\n      invokeGetters: false,\n      skipSetters: false,\n      // Arrays\n      appendArrays: false,\n      prependArrays: false,\n      dedupArrays: false,\n      sortArrays: false,\n      // Prototype\n      hoistProto: false,\n      // Callbacks\n      filter: Function.prototype,\n      beforeEach: Function.prototype,\n      afterEach: Function.prototype,\n      onCircular: Function.prototype\n    };\n    /**\n     * Deep recursive object merging with options to inspect, modify, and filter\n     * keys/values, merge arrays (append/prepend), and remove duplicate values from\n     * merged arrays. Returns new object without modifying sources (immutable).\n     *\n     * @preserve\n     *\n     * @example\n     * // Without options (use default option values)\n     * mergician(obj1, obj2, obj3, ...);\n     *\n     * @example\n     * // With options (defaults shown)\n     * mergician({\n     *   // Keys\n     *   onlyKeys: [],\n     *   skipKeys: [],\n     *   onlyCommonKeys: false,\n     *   onlyUniversalKeys: false,\n     *   skipCommonKeys: false,\n     *   skipUniversalKeys: false,\n     *   // Values\n     *   invokeGetters: false,\n     *   skipSetters: false,\n     *   // Arrays\n     *   appendArrays: false,\n     *   prependArrays: false,\n     *   dedupArrays: false,\n     *   sortArrays: false,\n     *   // Prototype\n     *   hoistProto: false,\n     *   // Callbacks\n     *   filter({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n     *   beforeEach({ depth, key, srcObj, srcVal, targetObj, targetVal }) {},\n     *   afterEach({ depth, key, mergeVal, srcObj, targetObj }) {},\n     *   onCircular({ depth, key, srcObj, srcVal, targetObj, targetVal }) {}\n     * })(obj1, obj2, obj3, ...)\n     *\n     * @param {...object} optionsOrObjects - Options or objects to merge\n     * @param {array} [options.onlyKeys] - Exclusive array of keys to be merged\n     * (others are skipped)\n     * @param {array} [options.skipKeys] - Array of keys to skip (others are merged)\n     * @param {boolean} [options.onlyCommonKeys = false] - Merge only keys found in\n     * multiple objects (ignore single occurrence keys)\n     * @param {boolean} [options.onlyUniversalKeys = false] - Merge only keys found\n     * in all objects\n     * @param {boolean} [options.skipCommonKeys = false] - Skip keys found in\n     * multiple objects (merge only single occurrence keys)\n     * @param {boolean} [options.skipUniversalKeys = false] - Skip keys found in all\n     * objects (merge only common keys)\n     * @param {boolean} [options.invokeGetters = false] - Invoke \"getter\" methods\n     * and merge returned values\n     * @param {boolean} [options.skipSetters = false] - Skip \"setter\" methods during\n     * merge\n     * @param {boolean} [options.appendArrays = false] - Merge array values at the\n     * end of existing arrays\n     * @param {boolean} [options.prependArrays = false] - Merge array values at the\n     * beginning of existing arrays\n     * @param {boolean} [options.dedupArrays = false] - Remove duplicate array\n     * values in new merged object\n     * @param {boolean|function} [options.sortArrays = false] - Sort array values in\n     * new merged object\n     * @param {boolean} [options.hoistProto = false] - Clone prototype properties as\n     * direct properties of merged/cloned object\n     * @param {function} [options.filter] - Callback used to conditionally merge or\n     * skip a property. Return a \"truthy\" value to merge or a \"falsy\" value to skip.\n     * Return no value to proceed according to other option values.\n     * @param {function} [options.beforeEach] - Callback used for\n     * inspecting/modifying properties before merge. Return value is used as value\n     * to merge.\n     * @param {function} [options.afterEach] - Callback used for\n     * inspecting/modifying properties after merge. Return value is used as merged\n     * value.\n     * @param {function} [options.onCircular] - Callback used for handling circular\n     * object references during merge\n     * @returns {function|object} Merge function with options applied or new merged\n     * object\n     * @param {...object} [objects] - Objects to merge\n     * @returns {object} New merged object\n     */\n    function mergician(...optionsOrObjects) {\n      const options = arguments.length === 1 ? arguments[0] : {};\n      const settings = { ...defaults, ...options };\n      const dedupArrayMap = /* @__PURE__ */ new Map();\n      const sortArrayMap = /* @__PURE__ */ new Map();\n      const sortArrayFn = typeof settings.sortArrays === \"function\" ? settings.sortArrays : void 0;\n      const circularRefs = /* @__PURE__ */ new WeakMap();\n      let mergeDepth = 0;\n      function _getObjectKeys(obj) {\n        return getObjectKeys(obj, settings.hoistProto);\n      }\n      function _mergician(...objects) {\n        let mergeKeyList;\n        if (objects.length > 1) {\n          if (settings.onlyCommonKeys) {\n            mergeKeyList = getInMultiple(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.onlyUniversalKeys) {\n            mergeKeyList = getInAll(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.skipCommonKeys) {\n            mergeKeyList = getNotInMultiple(...objects.map((obj) => _getObjectKeys(obj)));\n          } else if (settings.skipUniversalKeys) {\n            mergeKeyList = getNotInAll(...objects.map((obj) => _getObjectKeys(obj)));\n          }\n        }\n        if (!mergeKeyList && settings.onlyKeys.length) {\n          mergeKeyList = settings.onlyKeys;\n        }\n        if (mergeKeyList && mergeKeyList !== settings.onlyKeys && settings.onlyKeys.length) {\n          mergeKeyList = mergeKeyList.filter((key) => settings.onlyKeys.includes(key));\n        }\n        const newObj = objects.reduce((targetObj, srcObj) => {\n          circularRefs.set(srcObj, targetObj);\n          let keys = mergeKeyList || _getObjectKeys(srcObj);\n          if (settings.skipKeys.length) {\n            keys = keys.filter((key) => settings.skipKeys.indexOf(key) === -1);\n          }\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const targetVal = targetObj[key];\n            let isReturnVal = false;\n            let mergeVal;\n            if (key in srcObj === false) {\n              continue;\n            }\n            try {\n              mergeVal = srcObj[key];\n            } catch (err) {\n              console.error(err);\n              continue;\n            }\n            const srcDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n            const isSetterOnly = srcDescriptor && typeof srcDescriptor.set === \"function\" && typeof srcDescriptor.get !== \"function\";\n            if (isSetterOnly) {\n              if (!settings.skipSetters) {\n                srcDescriptor.configurable = true;\n                Object.defineProperty(targetObj, key, srcDescriptor);\n              }\n              continue;\n            }\n            if (settings.filter !== defaults.filter) {\n              const returnVal = settings.filter({\n                depth: mergeDepth,\n                key,\n                srcObj,\n                srcVal: mergeVal,\n                targetObj,\n                targetVal\n              });\n              if (returnVal !== void 0 && !returnVal) {\n                continue;\n              }\n            }\n            if (settings.beforeEach !== defaults.beforeEach) {\n              const returnVal = settings.beforeEach({\n                depth: mergeDepth,\n                key,\n                srcObj,\n                srcVal: mergeVal,\n                targetObj,\n                targetVal\n              });\n              if (returnVal !== void 0) {\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (typeof mergeVal === \"object\" && mergeVal !== null) {\n              if (circularRefs.has(srcObj[key])) {\n                const returnVal = settings.onCircular({\n                  depth: mergeDepth,\n                  key,\n                  srcObj,\n                  srcVal: srcObj[key],\n                  targetObj,\n                  targetVal\n                });\n                if (returnVal === void 0) {\n                  mergeVal = circularRefs.get(srcObj[key]);\n                  targetObj[key] = mergeVal;\n                  continue;\n                }\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (Array.isArray(mergeVal)) {\n              mergeVal = [...mergeVal];\n              if (Array.isArray(targetVal)) {\n                if (settings.appendArrays) {\n                  mergeVal = [...targetVal, ...mergeVal];\n                } else if (settings.prependArrays) {\n                  mergeVal = [...mergeVal, ...targetVal];\n                }\n              }\n              if (settings.dedupArrays) {\n                if (settings.afterEach !== defaults.afterEach) {\n                  mergeVal = [...new Set(mergeVal)];\n                } else {\n                  const keyArray = dedupArrayMap.get(targetObj);\n                  if (keyArray && !keyArray.includes(key)) {\n                    keyArray.push(key);\n                  } else {\n                    dedupArrayMap.set(targetObj, [key]);\n                  }\n                }\n              }\n              if (settings.sortArrays) {\n                if (settings.afterEach !== defaults.afterEach) {\n                  mergeVal = mergeVal.sort(sortArrayFn);\n                } else {\n                  const keyArray = sortArrayMap.get(targetObj);\n                  if (keyArray && !keyArray.includes(key)) {\n                    keyArray.push(key);\n                  } else {\n                    sortArrayMap.set(targetObj, [key]);\n                  }\n                }\n              }\n            } else if (isObject(mergeVal) && (!isReturnVal || !isPropDescriptor(mergeVal))) {\n              mergeDepth++;\n              if (isObject(targetVal)) {\n                mergeVal = _mergician(targetVal, mergeVal);\n              } else {\n                mergeVal = _mergician(mergeVal);\n              }\n              mergeDepth--;\n            }\n            if (settings.afterEach !== defaults.afterEach) {\n              const returnVal = settings.afterEach({\n                depth: mergeDepth,\n                key,\n                mergeVal,\n                srcObj,\n                targetObj\n              });\n              if (returnVal !== void 0) {\n                isReturnVal = true;\n                mergeVal = returnVal;\n              }\n            }\n            if (isReturnVal) {\n              if (isPropDescriptor(mergeVal)) {\n                mergeVal.configurable = true;\n                mergeVal.enumerable = !(\"enumerable\" in mergeVal) ? true : mergeVal.enumerable;\n                if (\"value\" in mergeVal && !(\"writable\" in mergeVal)) {\n                  mergeVal.writable = true;\n                }\n                Object.defineProperty(targetObj, key, mergeVal);\n              } else {\n                targetObj[key] = mergeVal;\n              }\n            } else {\n              const mergeDescriptor = Object.getOwnPropertyDescriptor(srcObj, key);\n              if (mergeDescriptor && typeof mergeDescriptor.get === \"function\" && !settings.invokeGetters) {\n                if (settings.skipSetters) {\n                  mergeDescriptor.set = void 0;\n                }\n                mergeDescriptor.configurable = true;\n                Object.defineProperty(targetObj, key, mergeDescriptor);\n              } else {\n                targetObj[key] = mergeVal;\n              }\n            }\n          }\n          return targetObj;\n        }, {});\n        for (const [obj, keyArray] of dedupArrayMap.entries()) {\n          for (const key of keyArray) {\n            obj[key] = [...new Set(obj[key])];\n          }\n        }\n        for (const [obj, keyArray] of sortArrayMap.entries()) {\n          for (const key of keyArray) {\n            obj[key].sort(sortArrayFn);\n          }\n        }\n        return newObj;\n      }\n      if (arguments.length === 1) {\n        return function(...objects) {\n          if (arguments.length === 1) {\n            return mergician({ ...settings, ...objects[0] });\n          } else {\n            return _mergician(...objects);\n          }\n        };\n      } else {\n        return _mergician(...arguments);\n      }\n    }\n    module.exports = mergician;\n  }\n});\nexport default require_src();\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\n// @ts-ignore\nimport Mergician from 'mergician'\n\nimport type {\n\tElysiaInstance,\n\tLifeCycleStore,\n\tLocalHook,\n\tTypedSchema,\n\tRegisteredHook,\n\tWithArray\n} from './types'\n\nexport const mergeDeep = Mergician({\n\tappendArrays: true\n})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta: LocalHook<any, any> | LifeCycleStore<any>,\n\tb: LocalHook<any, any>\n): RegisteredHook<any> => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\n\t\terror: mergeObjectArray(a.error ?? [], b?.error ?? [])\n\t}\n}\n\n// const isObject = (item: any): item is Object =>\n// \titem && typeof item === 'object' && !Array.isArray(item)\n\n// https://stackoverflow.com/a/37164538\n// export const mergeDeep = <A extends Object = Object, B extends Object = Object>(\n// \ttarget: A,\n// \tsource: B\n// ): DeepMergeTwoTypes<A, B> => {\n// \tconst output: Partial<DeepMergeTwoTypes<A, B>> = Object.assign({}, target)\n// \tif (isObject(target) && isObject(source)) {\n// \t\tObject.keys(source).forEach((key) => {\n// \t\t\t// @ts-ignore\n// \t\t\tif (isObject(source[key])) {\n// \t\t\t\tif (!(key in target))\n// \t\t\t\t\t// @ts-ignore\n// \t\t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t\t// @ts-ignore\n// \t\t\t\telse output[key] = mergeDeep(target[key], source[key])\n// \t\t\t} else {\n// \t\t\t\t// @ts-ignore\n// \t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t}\n// \t\t})\n// \t}\n\n// \treturn output as DeepMergeTwoTypes<A, B>\n// }\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema)\n}\n\nexport const getResponseSchemaValidator = (\n\ts: TypedSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord)\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord)\n\t\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema)\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = <\n\tA extends ElysiaInstance,\n\tB extends ElysiaInstance\n>(\n\ta: LifeCycleStore<A>,\n\tb: LifeCycleStore<B> | LocalHook<{}, B>,\n\tchecksum?: number\n): LifeCycleStore<A & B> => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\tif (checksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(a.parse as any, b?.parse ?? ([] as any)).map(\n\t\t\tinjectChecksum\n\t\t),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = <T extends LocalHook<any, any>>(\n\thook: T,\n\tinject = true\n): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as T\n}\n\nexport const asGlobal = <T extends WithArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends WithArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = <T extends LocalHook<any, any>>(hook: T): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as T\n}\n",
  "import { Kind, TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\n// @ts-ignore\nimport Mergician from 'mergician'\n\nimport type {\n\tElysiaInstance,\n\tLifeCycleStore,\n\tLocalHook,\n\tTypedSchema,\n\tRegisteredHook,\n\tWithArray\n} from './types'\n\nexport const mergeDeep = Mergician({\n\tappendArrays: true\n})\n\nexport const mergeObjectArray = <T>(a: T | T[], b: T | T[]): T[] => {\n\tconst array = [...(Array.isArray(a) ? a : [a])]\n\tconst checksums = []\n\n\tfor (const item of array) {\n\t\t// @ts-ignore\n\t\tif (item.$elysiaChecksum)\n\t\t\t// @ts-ignore\n\t\t\tchecksums.push(item.$elysiaChecksum)\n\t}\n\n\tfor (const item of Array.isArray(b) ? b : [b]) {\n\t\t// @ts-ignore\n\t\tif (!checksums.includes(item?.$elysiaChecksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const mergeHook = (\n\ta: LocalHook<any, any> | LifeCycleStore<any>,\n\tb: LocalHook<any, any>\n): RegisteredHook<any> => {\n\treturn {\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tresponse: b?.response ?? a?.response,\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray((a.parse as any) ?? [], b?.parse ?? []),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform ?? [],\n\t\t\tb?.transform ?? []\n\t\t) as any,\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle ?? [],\n\t\t\tb?.beforeHandle ?? []\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle ?? [],\n\t\t\tb?.afterHandle ?? []\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse ?? [],\n\t\t\tb?.onResponse ?? []\n\t\t) as any,\n\n\t\terror: mergeObjectArray(a.error ?? [], b?.error ?? [])\n\t}\n}\n\n// const isObject = (item: any): item is Object =>\n// \titem && typeof item === 'object' && !Array.isArray(item)\n\n// https://stackoverflow.com/a/37164538\n// export const mergeDeep = <A extends Object = Object, B extends Object = Object>(\n// \ttarget: A,\n// \tsource: B\n// ): DeepMergeTwoTypes<A, B> => {\n// \tconst output: Partial<DeepMergeTwoTypes<A, B>> = Object.assign({}, target)\n// \tif (isObject(target) && isObject(source)) {\n// \t\tObject.keys(source).forEach((key) => {\n// \t\t\t// @ts-ignore\n// \t\t\tif (isObject(source[key])) {\n// \t\t\t\tif (!(key in target))\n// \t\t\t\t\t// @ts-ignore\n// \t\t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t\t// @ts-ignore\n// \t\t\t\telse output[key] = mergeDeep(target[key], source[key])\n// \t\t\t} else {\n// \t\t\t\t// @ts-ignore\n// \t\t\t\tObject.assign(output, { [key]: source[key] })\n// \t\t\t}\n// \t\t})\n// \t}\n\n// \treturn output as DeepMergeTwoTypes<A, B>\n// }\n\nexport const getSchemaValidator = (\n\ts: TSchema | string | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n) => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic)\n\t\treturn {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => ''\n\t\t} as unknown as TypeCheck<TSchema>\n\n\treturn TypeCompiler.Compile(schema)\n}\n\nexport const getResponseSchemaValidator = (\n\ts: TypedSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tadditionalProperties = false,\n\t\tdynamic = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\treturn TypeCompiler.Compile(schema)\n\t}\n\n\tif (Kind in maybeSchemaOrRecord)\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord)\n\t\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] = Kind in schema ? compile(schema) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema)\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const mergeLifeCycle = <\n\tA extends ElysiaInstance,\n\tB extends ElysiaInstance\n>(\n\ta: LifeCycleStore<A>,\n\tb: LifeCycleStore<B> | LocalHook<{}, B>,\n\tchecksum?: number\n): LifeCycleStore<A & B> => {\n\tconst injectChecksum = <T>(x: T): T => {\n\t\tif (checksum)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaChecksum = checksum\n\n\t\treturn x\n\t}\n\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start as any,\n\t\t\t('start' in b ? b.start : []).map(injectChecksum) as any\n\t\t),\n\t\trequest: mergeObjectArray(\n\t\t\ta.request as any,\n\t\t\t('request' in b ? b.request : []).map(injectChecksum) as any\n\t\t),\n\t\tparse: mergeObjectArray(a.parse as any, b?.parse ?? ([] as any)).map(\n\t\t\tinjectChecksum\n\t\t),\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform as any,\n\t\t\t(b?.transform ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle as any,\n\t\t\t(b?.beforeHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle as any,\n\t\t\t(b?.afterHandle ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tonResponse: mergeObjectArray(\n\t\t\ta.onResponse as any,\n\t\t\t(b?.onResponse ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\terror: mergeObjectArray(\n\t\t\ta.error as any,\n\t\t\t(b?.error ?? ([] as any)).map(injectChecksum)\n\t\t),\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop as any,\n\t\t\t('stop' in b ? b.stop : ([] as any)).map(injectChecksum)\n\t\t)\n\t}\n}\n\nexport const asGlobalHook = <T extends LocalHook<any, any>>(\n\thook: T,\n\tinject = true\n): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: asGlobal(hook?.parse, inject),\n\t\ttransform: asGlobal(hook?.transform, inject),\n\t\tbeforeHandle: asGlobal(hook?.beforeHandle, inject),\n\t\tafterHandle: asGlobal(hook?.afterHandle, inject),\n\t\tonResponse: asGlobal(hook?.onResponse, inject),\n\t\terror: asGlobal(hook?.error, inject)\n\t} as T\n}\n\nexport const asGlobal = <T extends WithArray<Function> | undefined>(\n\tfn: T,\n\tinject = true\n): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tfn.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse fn.$elysiaHookType = undefined\n\n\t\treturn fn\n\t}\n\n\treturn fn.map((x) => {\n\t\tif (inject)\n\t\t\t// @ts-ignore\n\t\t\tx.$elysiaHookType = 'global'\n\t\t// @ts-ignore\n\t\telse x.$elysiaHookType = undefined\n\n\t\treturn x\n\t}) as T\n}\n\nconst filterGlobal = <T extends WithArray<Function> | undefined>(fn: T): T => {\n\tif (!fn) return fn\n\n\tif (typeof fn === 'function') {\n\t\t// @ts-ignore\n\t\treturn fn.$elysiaHookType === 'global' ? fn : undefined\n\t}\n\n\t// @ts-ignore\n\treturn fn.filter((x) => x.$elysiaHookType === 'global') as T\n}\n\nexport const filterGlobalHook = <T extends LocalHook<any, any>>(hook: T): T => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tonResponse: filterGlobal(hook?.onResponse),\n\t\terror: filterGlobal(hook?.error)\n\t} as T\n}\n",
  "import type { Elysia } from '.'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { mapEarlyResponse, mapResponse, mapCompactResponse } from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE\n} from './error'\n\nimport type {\n\tElysiaConfig,\n\tComposedHandler,\n\tHTTPMethod,\n\tLocalHandler,\n\tRegisteredHook,\n\tSchemaValidator,\n\tBeforeRequestHandler\n} from './types'\nimport type { TAnySchema } from '@sinclair/typebox'\nimport { TypeCheck } from '@sinclair/typebox/compiler'\n\nconst _demoHeaders = new Headers()\n\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (hasErrorHandler: boolean) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (value = 'r') =>\n\t\thasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${value}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${value}\n).toResponse(c.set.headers)`\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\treturn false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst aliases = [argument]\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex)) {\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\t}\n\n\treturn false\n}\n\nexport const findElysiaMeta = (\n\ttype: string,\n\tschema: TAnySchema,\n\tfound: string[] = [],\n\tparent = ''\n) => {\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key in properties) {\n\t\t\tconst property = properties[key]\n\n\t\t\tconst accessor = !parent ? key : parent + '.' + key\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tfindElysiaMeta(type, property, found, accessor)\n\t\t\t\tcontinue\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (const prop of property.anyOf) {\n\t\t\t\t\tfindElysiaMeta(type, prop, found, accessor)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (property.elysiaMeta === type) found.push(accessor)\n\t\t}\n\n\t\tif (found.length === 0) return null\n\n\t\treturn found\n\t} else if (schema?.elysiaMeta === type) {\n\t\tif (parent) found.push(parent)\n\n\t\treturn 'root'\n\t}\n\n\treturn null\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n}\n\nconst matchFnReturn = /(?:return|=>) \\S*\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\n\tif (literal.match(matchFnReturn)) return true\n\n\treturn false\n}\n\nexport const composeHandler = ({\n\t// path,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tmeta,\n\tonRequest,\n\tconfig\n}: {\n\tpath: string\n\tmethod: HTTPMethod\n\thooks: RegisteredHook<any>\n\tvalidator: SchemaValidator\n\thandler: LocalHandler<any, any>\n\thandleError: Elysia['handleError']\n\tmeta?: Elysia['meta']\n\tonRequest: BeforeRequestHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tlet fnLiteral = hasErrorHandler ? 'try {\\n' : ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || method !== 'GET'\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle\n\t\t\t  ].map((x) => x.toString())\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\thooks.type !== 'none' &&\n\t\t(!!validator.body ||\n\t\t\t!!hooks.type ||\n\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))\n\n\tconst hasHeaders =\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn))\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += _demoHeaders.toJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tconst hasQuery =\n\t\tvalidator.query || lifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tfnLiteral += `const url = c.request.url\n\n\t\tif(c.qi !== -1) {\n\t\t\tc.query ??= parseQuery(url.substring(c.qi + 1))\n\t\t} else {\n\t\t\tc.query ??= {}\n\t\t}\n\t\t`\n\t}\n\n\tconst hasSet =\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst maybeAsync =\n\t\thasBody ||\n\t\tisAsync(handler) ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type || type) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text());`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t}`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (type) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tif (schema.elysiaMeta === 'URLEncoded') {\n\t\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())`\n\t\t\t\t\t\t} // Accept file which means it's formdata\n\t\t\t\t\t\telse if (\n\t\t\t\t\t\t\tvalidator.body!.Code().includes(\"custom('File\")\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}`\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// we can infer that it's JSON\n\t\t\t\t\t\t\tfnLiteral += `c.body = JSON.parse(await c.request.text())`\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfnLiteral += 'c.body = await c.request.text()'\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n            if (contentType) {\n\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType);`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name};`\n\n\t\t\t\t\tfnLiteral += `\n\t\t\t\t\t\tif(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += `if (!used)`\n\t\t\t}\n\n\t\t\tfnLiteral += `switch (contentType) {\n\t\t\tcase 'application/json':\n\t\t\t\tc.body = await c.request.json()\n\t\t\t\tbreak\n\n\t\t\tcase 'text/plain':\n\t\t\t\tc.body = await c.request.text()\n\t\t\t\tbreak\n\n\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\tbreak\n\n\t\t\tcase 'application/octet-stream':\n\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\tbreak\n\n\t\t\tcase 'multipart/form-data':\n\t\t\t\tc.body = {}\n\n\t\t\t\tconst form = await c.request.formData()\n\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\telse c.body[key] = value\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tif (validator.params) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.params.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `if(c.params.${property}) c.params.${property} = +c.params.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.query) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.query.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `if(c.query.${property}) c.query.${property} = +c.query.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.headers) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.headers.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `c.headers.${property} = +c.headers.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.body) {\n\t\t// @ts-ignore\n\t\tconst numericProperties = findElysiaMeta('Numeric', validator.body.schema)\n\n\t\tif (numericProperties) {\n\t\t\tswitch (typeof numericProperties) {\n\t\t\t\tcase 'string':\n\t\t\t\t\tfnLiteral += `c.body = +c.body;`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of numericProperties)\n\t\t\t\t\t\tfnLiteral += `c.body.${property} = +c.body.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\n\t\t// @ts-ignore\n\t\tconst filesProperties = findElysiaMeta('Files', validator.body.schema)\n\t\tif (filesProperties) {\n\t\t\tswitch (typeof filesProperties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of filesProperties)\n\t\t\t\t\t\tfnLiteral += `if(!Array.isArray(c.body.${property})) c.body.${property} = [c.body.${property}];`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (hooks?.transform)\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\t\t}\n\n\tif (validator) {\n\t\tif (validator.headers)\n\t\t\tfnLiteral += `\n                if (headers.Check(c.headers) === false) {\n                    ${composeValidation('headers')}\n\t\t\t\t}\n        `\n\n\t\tif (validator.params)\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) { ${composeValidation(\n\t\t\t\t'params'\n\t\t\t)} }`\n\n\t\tif (validator.query)\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) { ${composeValidation(\n\t\t\t\t'query'\n\t\t\t)} }`\n\n\t\tif (validator.body)\n\t\t\tfnLiteral += `if(body.Check(c.body) === false) { ${composeValidation(\n\t\t\t\t'body'\n\t\t\t)} }`\n\t}\n\n\tif (hooks?.beforeHandle)\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst name = `be${i}`\n\n\t\t\tconst returning = hasReturn(hooks.beforeHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `let ${name} = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `let ${name} = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tfnLiteral += `if(${name} !== undefined) {\\n`\n\t\t\t\tif (hooks?.afterHandle) {\n\t\t\t\t\tconst beName = name\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst name = `af${i}`\n\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `const ${name} = await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `const ${name} = afterHandle[${i}](c, ${beName});\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { ${beName} = ${name} }\\n`\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += `if(response[c.set.status]?.Check(${name}) === false) { \n\t\t\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t\t\t${composeResponseValidation(name)}\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${name}, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tfnLiteral += isAsync(handler)\n\t\t\t? `let r = await handler(c);\\n`\n\t\t\t: `let r = handler(c);\\n`\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst name = `af${i}`\n\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c, r)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c, r)\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `let ${name} = await afterHandle[${i}](c, r)\\n`\n\t\t\t\t\t: `let ${name} = afterHandle[${i}](c, r)\\n`\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) {`\n\t\t\t\t\tfnLiteral += `if(response[c.set.status]?.Check(${name}) === false) { \n\t\t\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t\t${composeResponseValidation(name)}\n\t\t\t\t\t}\\n`\n\n\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `if(${name}) return ${name};\\n}`\n\t\t\t\t} else fnLiteral += `if(${name}) return ${name};\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (validator.response)\n\t\t\tfnLiteral += `if(response[c.set.status]?.Check(r) === false) { \n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${composeResponseValidation()}\n\t\t\t}\\n`\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tif (validator.response) {\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `const r = await handler(c);\\n`\n\t\t\t\t: `const r = handler(c);\\n`\n\n\t\t\tfnLiteral += `if(response[c.set.status]?.Check(r) === false) { \n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${composeResponseValidation()}\n\t\t\t}\\n`\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tconst handled = isAsync(handler)\n\t\t\t\t? 'await handler(c) '\n\t\t\t\t: 'handler(c)'\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t}\n\t}\n\n\tif (hasErrorHandler) {\n\t\tfnLiteral += `\n} catch(error) {\n\t${\n\t\t''\n\t\t// hasStrictContentType ||\n\t\t// // @ts-ignore\n\t\t// validator?.body?.schema\n\t\t// \t? `if(!c.body) error = parseError`\n\t\t// \t: ''\n\t}\n\n\t${maybeAsync ? '' : 'return (async () => {'}\n\t\tconst set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = 500\n\n\t\t${\n\t\t\thooks.error.length\n\t\t\t\t? `for (let i = 0; i < handleErrors.length; i++) {\n\t\t\t\tlet handled = handleErrors[i]({\n\t\t\t\t\trequest: c.request,\n\t\t\t\t\terror: error,\n\t\t\t\t\tset,\n\t\t\t\t\tcode: error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t\t})\n\t\t\t\tif (handled instanceof Promise) handled = await handled\n\n\t\t\t\tconst response = mapEarlyResponse(handled, set)\n\t\t\t\tif (response) return response\n\t\t\t}`\n\t\t\t\t: ''\n\t\t}\n\n\t\treturn handleError(c.request, error, set)\n\t${maybeAsync ? '' : '})()'}\n} finally {\n\t${handleResponse}\n}`\n\t}\n\n\t// console.log(fnLiteral)\n\n\tfnLiteral = `const { \n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tmeta,\n\t\tERROR_CODE\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function(c) {\n\t\t${meta ? 'c[\"schema\"] = meta[\"schema\"]; c[\"defs\"] = meta[\"defs\"];' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tmeta,\n\t\tERROR_CODE\n\t})\n}\n\nexport const composeGeneralHandler = (app: Elysia<any, any>) => {\n\tlet decoratorsLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst findDynamicRoute = `\n\tconst route = find(request.method, path) ${\n\t\trouter.root.ALL ? '?? find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `handleError(\n\t\t\trequest,\n\t\t\tnotFound,\n\t\t\tctx.set\n\t\t)`\n\t\t\t\t: `new Response(error404, {\n\t\t\t\t\tstatus: 404\n\t\t\t\t})`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: ${findDynamicRoute}`\n\t\t}}\\n\\n`\n\n\tlet fnLiteral = `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\n\t${staticRouter.variables}\n\n\tconst find = router.find.bind(router)\n\tconst handleError = app.handleError.bind(this)\n\n\t${app.event.error.length ? '' : `const error404 = notFound.message.toString()`}\n\n\treturn function(request) {\n\t`\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\theaders: {},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\n\t\t\ttry {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst withReturn = hasReturn(app.event.request[i].toString())\n\n\t\t\tfnLiteral += !withReturn\n\t\t\t\t? `mapEarlyResponse(onRequest[${i}](ctx), ctx.set);`\n\t\t\t\t: `const response = mapEarlyResponse(\n\t\t\t\t\tonRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\n\t\t\t\tif (response) return response\\n`\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn handleError(request, error, ctx.set)\n\t\t}\n\t\t\n\t\tconst url = request.url,\n\t\ts = url.indexOf('/', 11),\n\t\ti = ctx.qi = url.indexOf('?', s + 1),\n\t\tpath = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1\n\t\t\t\t? url.substring(s)\n\t\t\t\t: url.substring(s, qi)\n\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: {},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\t}\n\n\tfnLiteral += `\n\t\tswitch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\t${findDynamicRoute}\n\t\t}\n\t}`\n\n\t// @ts-ignore\n\tapp.handleError = composeErrorHandler(app) as any\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError\n\t})\n}\n\nexport const composeErrorHandler = (app: Elysia<any, any>) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(request, error, set) {`\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${isAsync(handler) ? 'await ' : ''}onError[${i}]({\n\t\t\trequest,\n\t\t\tcode: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',\n\t\t\terror,\n\t\t\tset\n\t\t})`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `const r${i} = ${response}; if(r${i} !== undefined) return mapResponse(r${i}, set)\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message, \n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\treturn new Response(error.message, { headers: set.headers, status: error.status ?? 500 })\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE\n\t})\n}\n",
  "/* eslint-disable no-case-declarations */\nimport type { Context } from './context'\n\nconst hasHeaderShorthand = 'toJSON' in new Headers()\n\nexport const isNotEmpty = (obj: Object) => {\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nconst parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\theaders.delete('Set-Cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'Set-Cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response | undefined => {\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.redirect) {\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tset.status = 302\n\t\t}\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\t// @ts-ignore\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob, set)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (!(key in set.headers)) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set.headers)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn (response as Function)()\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset\n\t\t\t\t)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(JSON.stringify(response), set) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set.headers)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn (response as Function)()\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set']\n): Response => {\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.redirect) {\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tset.status = 302\n\t\t}\n\n\t\tif (\n\t\t\tset.headers['Set-Cookie'] &&\n\t\t\tArray.isArray(set.headers['Set-Cookie'])\n\t\t)\n\t\t\t// @ts-ignore\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers),\n\t\t\t\tset.headers['Set-Cookie']\n\t\t\t)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob, {\n\t\t\t\t\tstatus: set.status,\n\t\t\t\t\theaders: set.headers\n\t\t\t\t})\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set)\n\n\t\t\t\treturn Response.json(response, set)\n\n\t\t\tcase 'Response':\n\t\t\t\tconst inherits = Object.assign({}, set.headers)\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tset.headers = (response as Response).headers.toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\tif (!(key in set.headers)) set.headers[key] = value\n\n\t\t\t\tfor (const key in inherits)\n\t\t\t\t\t(response as Response).headers.append(key, inherits[key])\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set.headers)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn response.then((x) => mapResponse(x, set))\n\n\t\t\tcase 'Function':\n\t\t\t\treturn (response as Function)()\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset\n\t\t\t\t)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123) {\n\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\treturn new Response(JSON.stringify(response), set) as any\n\t\t\t\t}\n\n\t\t\t\treturn new Response(r, set)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\tcase 'Blob':\n\t\t\t\treturn new Response(response as string | Blob)\n\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapResponse(x, set)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn new Response('')\n\t\t\t\t})\n\n\t\t\t// ? Maybe response or Blob\n\t\t\tcase 'Function':\n\t\t\t\treturn (response as Function)()\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tconst r = JSON.stringify(response)\n\t\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\n\t\t\t\treturn new Response(r)\n\t\t}\n}\n\nexport const mapCompactResponse = (response: unknown): Response => {\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\tcase 'Blob':\n\t\t\treturn new Response(response as string | Blob)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\t// @ts-ignore\n\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\tconst r = mapCompactResponse(x)\n\n\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\treturn new Response('')\n\t\t\t})\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn (response as Function)()\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tdefault:\n\t\t\tif (response instanceof Response) return response\n\n\t\t\tconst r = JSON.stringify(response)\n\t\t\tif (r.charCodeAt(0) === 123)\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t}) as any\n\n\t\t\treturn new Response(r)\n\t}\n}\n\nexport const errorToResponse = (error: Error, headers?: HeadersInit) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus: 500,\n\t\t\theaders\n\t\t}\n\t)\n",
  "import { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t? process?.env\n\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ErrorCode')\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\nexport class InternalServerError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 500\n\n\tconstructor() {\n\t\tsuper('INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor() {\n\t\tsuper('NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor() {\n\t\tsuper('PARSE')\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\tconst error = isProduction ? undefined : validator.Errors(value).First()\n\t\tconst customError = error?.schema.error\n\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t? error.schema.error(type, validator, value)\n\t\t\t\t: error.schema.error\n\t\t\t: undefined\n\n\t\tconst message = isProduction\n\t\t\t? customError ??\n\t\t\t  `Invalid ${type ?? error?.schema.error ?? error?.message}`\n\t\t\t: customError ??\n\t\t\t  `Invalid ${type}, '${error?.path?.slice(1) || 'type'}': ${\n\t\t\t\t\terror?.message\n\t\t\t  }` +\n\t\t\t\t\t'\\n\\n' +\n\t\t\t\t\t'Expected: ' +\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tJSON.stringify(Value.Create(validator.schema), null, 2) +\n\t\t\t\t\t'\\n\\n' +\n\t\t\t\t\t'Found: ' +\n\t\t\t\t\tJSON.stringify(value, null, 2)\n\t\t// +\n\t\t// '\\n\\n' +\n\t\t// 'Schema: ' +\n\t\t// // @ts-ignore\n\t\t// JSON.stringify(validator.schema, null, 2) +\n\t\t// '\\n'\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn [...this.validator.Errors(this.value)]\n\t}\n\n\tget model() {\n\t\t// @ts-ignore\n\t\treturn Value.Create(this.validator.schema)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders\n\t\t})\n\t}\n}\n",
  "import type { Elysia } from '.'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nimport { mapEarlyResponse, mapResponse, mapCompactResponse } from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE\n} from './error'\n\nimport type {\n\tElysiaConfig,\n\tComposedHandler,\n\tHTTPMethod,\n\tLocalHandler,\n\tRegisteredHook,\n\tSchemaValidator,\n\tBeforeRequestHandler\n} from './types'\nimport type { TAnySchema } from '@sinclair/typebox'\nimport { TypeCheck } from '@sinclair/typebox/compiler'\n\nconst _demoHeaders = new Headers()\n\nconst findAliases = new RegExp(` (\\\\w+) = context`, 'g')\n\nexport const hasReturn = (fnLiteral: string) => {\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\nconst composeValidationFactory = (hasErrorHandler: boolean) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\thasErrorHandler\n\t\t\t? `c.set.status = 400; throw new ValidationError(\n'${type}',\n${type},\n${value}\n)`\n\t\t\t: `c.set.status = 400; return new ValidationError(\n\t'${type}',\n\t${type},\n\t${value}\n).toResponse(c.set.headers)`,\n\tcomposeResponseValidation: (value = 'r') =>\n\t\thasErrorHandler\n\t\t\t? `throw new ValidationError(\n'response',\nresponse[c.set.status],\n${value}\n)`\n\t\t\t: `return new ValidationError(\n'response',\nresponse[c.set.status],\n${value}\n).toResponse(c.set.headers)`\n})\n\nexport const isFnUse = (keyword: string, fnLiteral: string) => {\n\tfnLiteral = fnLiteral.trimStart()\n\tfnLiteral = fnLiteral.replaceAll(/^async /g, '')\n\n\tconst argument =\n\t\t// CharCode 40 is '('\n\t\tfnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith('function')\n\t\t\t? // Bun: (context) => {}\n\t\t\t  fnLiteral.slice(\n\t\t\t\t\tfnLiteral.indexOf('(') + 1,\n\t\t\t\t\tfnLiteral.indexOf(')')\n\t\t\t  )\n\t\t\t: // Node: context => {}\n\t\t\t  fnLiteral.slice(0, fnLiteral.indexOf('=') - 1)\n\n\tif (argument === '') return false\n\n\t// Using object destructuring\n\tif (argument.charCodeAt(0) === 123) {\n\t\t// Since Function already format the code, styling is enforced\n\t\tif (argument.includes(keyword)) return true\n\n\t\treturn false\n\t}\n\n\t// Match dot notation and named access\n\tif (\n\t\tfnLiteral.match(\n\t\t\tnew RegExp(`${argument}(.${keyword}|\\\\[\"${keyword}\"\\\\])`)\n\t\t)\n\t) {\n\t\treturn true\n\t}\n\n\tconst aliases = [argument]\n\tfor (const found of fnLiteral.matchAll(findAliases)) aliases.push(found[1])\n\n\tconst destructuringRegex = new RegExp(`{.*?} = (${aliases.join('|')})`, 'g')\n\n\tfor (const [params] of fnLiteral.matchAll(destructuringRegex)) {\n\t\tif (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))\n\t\t\treturn true\n\t}\n\n\treturn false\n}\n\nexport const findElysiaMeta = (\n\ttype: string,\n\tschema: TAnySchema,\n\tfound: string[] = [],\n\tparent = ''\n) => {\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key in properties) {\n\t\t\tconst property = properties[key]\n\n\t\t\tconst accessor = !parent ? key : parent + '.' + key\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tfindElysiaMeta(type, property, found, accessor)\n\t\t\t\tcontinue\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (const prop of property.anyOf) {\n\t\t\t\t\tfindElysiaMeta(type, prop, found, accessor)\n\t\t\t\t}\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (property.elysiaMeta === type) found.push(accessor)\n\t\t}\n\n\t\tif (found.length === 0) return null\n\n\t\treturn found\n\t} else if (schema?.elysiaMeta === type) {\n\t\tif (parent) found.push(parent)\n\n\t\treturn 'root'\n\t}\n\n\treturn null\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\nconst getUnionedType = (validator: TypeCheck<any> | undefined) => {\n\tif (!validator) return\n\n\t// @ts-ignore\n\tconst schema = validator?.schema\n\n\tif (schema && 'anyOf' in schema) {\n\t\tlet foundDifference = false\n\t\tconst type: string = schema.anyOf[0].type\n\n\t\tfor (const validator of schema.anyOf as { type: string }[]) {\n\t\t\tif (validator.type !== type) {\n\t\t\t\tfoundDifference = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (!foundDifference) return type\n\t}\n}\n\nconst matchFnReturn = /(?:return|=>) \\S*\\(/g\n\nexport const isAsync = (fn: Function) => {\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\n\tif (literal.match(matchFnReturn)) return true\n\n\treturn false\n}\n\nexport const composeHandler = ({\n\t// path,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\thandleError,\n\tmeta,\n\tonRequest,\n\tconfig\n}: {\n\tpath: string\n\tmethod: HTTPMethod\n\thooks: RegisteredHook<any>\n\tvalidator: SchemaValidator\n\thandler: LocalHandler<any, any>\n\thandleError: Elysia['handleError']\n\tmeta?: Elysia['meta']\n\tonRequest: BeforeRequestHandler<any, any>[]\n\tconfig: ElysiaConfig<any>\n}): ComposedHandler => {\n\tconst hasErrorHandler =\n\t\tconfig.forceErrorEncapsulation ||\n\t\thooks.error.length > 0 ||\n\t\ttypeof Bun === 'undefined' ||\n\t\thooks.onResponse.length > 0\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory(hasErrorHandler)\n\n\tconst handleResponse = hooks.onResponse.length\n\t\t? `\\n;(async () => {${hooks.onResponse\n\t\t\t\t.map((_, i) => `await res${i}(c)`)\n\t\t\t\t.join(';')}})();\\n`\n\t\t: ''\n\n\tlet fnLiteral = hasErrorHandler ? 'try {\\n' : ''\n\n\tconst lifeCycleLiteral =\n\t\tvalidator || method !== 'GET'\n\t\t\t? [\n\t\t\t\t\thandler,\n\t\t\t\t\t...hooks.transform,\n\t\t\t\t\t...hooks.beforeHandle,\n\t\t\t\t\t...hooks.afterHandle\n\t\t\t  ].map((x) => x.toString())\n\t\t\t: []\n\n\tconst hasBody =\n\t\tmethod !== 'GET' &&\n\t\thooks.type !== 'none' &&\n\t\t(!!validator.body ||\n\t\t\t!!hooks.type ||\n\t\t\tlifeCycleLiteral.some((fn) => isFnUse('body', fn)))\n\n\tconst hasHeaders =\n\t\tvalidator.headers ||\n\t\tlifeCycleLiteral.some((fn) => isFnUse('headers', fn))\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += _demoHeaders.toJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tconst hasQuery =\n\t\tvalidator.query || lifeCycleLiteral.some((fn) => isFnUse('query', fn))\n\n\tif (hasQuery) {\n\t\tfnLiteral += `const url = c.request.url\n\n\t\tif(c.qi !== -1) {\n\t\t\tc.query ??= parseQuery(url.substring(c.qi + 1))\n\t\t} else {\n\t\t\tc.query ??= {}\n\t\t}\n\t\t`\n\t}\n\n\tconst hasSet =\n\t\tlifeCycleLiteral.some((fn) => isFnUse('set', fn)) ||\n\t\tonRequest.some((fn) => isFnUse('set', fn.toString()))\n\n\tconst maybeAsync =\n\t\thasBody ||\n\t\tisAsync(handler) ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync)\n\n\tif (hasBody) {\n\t\tconst type = getUnionedType(validator?.body)\n\n\t\tif (hooks.type || type) {\n\t\t\tif (hooks.type) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text());`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer();`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t}`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (type) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst schema = validator?.body?.schema\n\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tif (schema.elysiaMeta === 'URLEncoded') {\n\t\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())`\n\t\t\t\t\t\t} // Accept file which means it's formdata\n\t\t\t\t\t\telse if (\n\t\t\t\t\t\t\tvalidator.body!.Code().includes(\"custom('File\")\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}`\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Since it's an object an not accepting file\n\t\t\t\t\t\t\t// we can infer that it's JSON\n\t\t\t\t\t\t\tfnLiteral += `c.body = JSON.parse(await c.request.text())`\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfnLiteral += 'c.body = await c.request.text()'\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += '}}'\n\t\t} else {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n            if (contentType) {\n\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType);`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name};`\n\n\t\t\t\t\tfnLiteral += `\n\t\t\t\t\t\tif(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += `if (!used)`\n\t\t\t}\n\n\t\t\tfnLiteral += `switch (contentType) {\n\t\t\tcase 'application/json':\n\t\t\t\tc.body = await c.request.json()\n\t\t\t\tbreak\n\n\t\t\tcase 'text/plain':\n\t\t\t\tc.body = await c.request.text()\n\t\t\t\tbreak\n\n\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\tbreak\n\n\t\t\tcase 'application/octet-stream':\n\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\tbreak\n\n\t\t\tcase 'multipart/form-data':\n\t\t\t\tc.body = {}\n\n\t\t\t\tconst form = await c.request.formData()\n\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\telse c.body[key] = value\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t\t}\n\n\t\tfnLiteral += '\\n'\n\t}\n\n\tif (validator.params) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.params.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `if(c.params.${property}) c.params.${property} = +c.params.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.query) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.query.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `if(c.query.${property}) c.query.${property} = +c.query.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.headers) {\n\t\t// @ts-ignore\n\t\tconst properties = findElysiaMeta('Numeric', validator.headers.schema)\n\n\t\tif (properties) {\n\t\t\tswitch (typeof properties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of properties)\n\t\t\t\t\t\tfnLiteral += `c.headers.${property} = +c.headers.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (validator.body) {\n\t\t// @ts-ignore\n\t\tconst numericProperties = findElysiaMeta('Numeric', validator.body.schema)\n\n\t\tif (numericProperties) {\n\t\t\tswitch (typeof numericProperties) {\n\t\t\t\tcase 'string':\n\t\t\t\t\tfnLiteral += `c.body = +c.body;`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of numericProperties)\n\t\t\t\t\t\tfnLiteral += `c.body.${property} = +c.body.${property};`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\n\t\t// @ts-ignore\n\t\tconst filesProperties = findElysiaMeta('Files', validator.body.schema)\n\t\tif (filesProperties) {\n\t\t\tswitch (typeof filesProperties) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tfor (const property of filesProperties)\n\t\t\t\t\t\tfnLiteral += `if(!Array.isArray(c.body.${property})) c.body.${property} = [c.body.${property}];`\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfnLiteral += '\\n'\n\t\t}\n\t}\n\n\tif (hooks?.transform)\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\t// @ts-ignore\n\t\t\tif (transform.$elysia === 'derive')\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `Object.assign(c, await transform[${i}](c));`\n\t\t\t\t\t: `Object.assign(c, transform[${i}](c));`\n\t\t\telse\n\t\t\t\tfnLiteral += isAsync(hooks.transform[i])\n\t\t\t\t\t? `await transform[${i}](c);`\n\t\t\t\t\t: `transform[${i}](c);`\n\t\t}\n\n\tif (validator) {\n\t\tif (validator.headers)\n\t\t\tfnLiteral += `\n                if (headers.Check(c.headers) === false) {\n                    ${composeValidation('headers')}\n\t\t\t\t}\n        `\n\n\t\tif (validator.params)\n\t\t\tfnLiteral += `if(params.Check(c.params) === false) { ${composeValidation(\n\t\t\t\t'params'\n\t\t\t)} }`\n\n\t\tif (validator.query)\n\t\t\tfnLiteral += `if(query.Check(c.query) === false) { ${composeValidation(\n\t\t\t\t'query'\n\t\t\t)} }`\n\n\t\tif (validator.body)\n\t\t\tfnLiteral += `if(body.Check(c.body) === false) { ${composeValidation(\n\t\t\t\t'body'\n\t\t\t)} }`\n\t}\n\n\tif (hooks?.beforeHandle)\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst name = `be${i}`\n\n\t\t\tconst returning = hasReturn(hooks.beforeHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.beforeHandle[i])\n\t\t\t\t\t? `let ${name} = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `let ${name} = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tfnLiteral += `if(${name} !== undefined) {\\n`\n\t\t\t\tif (hooks?.afterHandle) {\n\t\t\t\t\tconst beName = name\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst returning = hasReturn(\n\t\t\t\t\t\t\thooks.afterHandle[i].toString()\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst name = `af${i}`\n\n\t\t\t\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t\t\t\t? `const ${name} = await afterHandle[${i}](c, ${beName});\\n`\n\t\t\t\t\t\t\t\t: `const ${name} = afterHandle[${i}](c, ${beName});\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { ${beName} = ${name} }\\n`\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += `if(response[c.set.status]?.Check(${name}) === false) { \n\t\t\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t\t\t${composeResponseValidation(name)}\n\t\t\t\t\t}\\n`\n\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${name}, c.set)}\\n`\n\t\t\t}\n\t\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tfnLiteral += isAsync(handler)\n\t\t\t? `let r = await handler(c);\\n`\n\t\t\t: `let r = handler(c);\\n`\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst name = `af${i}`\n\n\t\t\tconst returning = hasReturn(hooks.afterHandle[i].toString())\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `await afterHandle[${i}](c, r)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c, r)\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hooks.afterHandle[i])\n\t\t\t\t\t? `let ${name} = await afterHandle[${i}](c, r)\\n`\n\t\t\t\t\t: `let ${name} = afterHandle[${i}](c, r)\\n`\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) {`\n\t\t\t\t\tfnLiteral += `if(response[c.set.status]?.Check(${name}) === false) { \n\t\t\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t\t${composeResponseValidation(name)}\n\t\t\t\t\t}\\n`\n\n\t\t\t\t\tfnLiteral += `${name} = mapEarlyResponse(${name}, c.set)\\n`\n\n\t\t\t\t\tfnLiteral += `if(${name}) return ${name};\\n}`\n\t\t\t\t} else fnLiteral += `if(${name}) return ${name};\\n`\n\t\t\t}\n\t\t}\n\n\t\tif (validator.response)\n\t\t\tfnLiteral += `if(response[c.set.status]?.Check(r) === false) { \n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${composeResponseValidation()}\n\t\t\t}\\n`\n\n\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t} else {\n\t\tif (validator.response) {\n\t\t\tfnLiteral += isAsync(handler)\n\t\t\t\t? `const r = await handler(c);\\n`\n\t\t\t\t: `const r = handler(c);\\n`\n\n\t\t\tfnLiteral += `if(response[c.set.status]?.Check(r) === false) { \n\t\t\t\tif(!(response instanceof Error))\n\t\t\t\t\t${composeResponseValidation()}\n\t\t\t}\\n`\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(r, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(r)\\n`\n\t\t} else {\n\t\t\tconst handled = isAsync(handler)\n\t\t\t\t? 'await handler(c) '\n\t\t\t\t: 'handler(c)'\n\n\t\t\tif (hasSet) fnLiteral += `return mapResponse(${handled}, c.set)\\n`\n\t\t\telse fnLiteral += `return mapCompactResponse(${handled})\\n`\n\t\t}\n\t}\n\n\tif (hasErrorHandler) {\n\t\tfnLiteral += `\n} catch(error) {\n\t${\n\t\t''\n\t\t// hasStrictContentType ||\n\t\t// // @ts-ignore\n\t\t// validator?.body?.schema\n\t\t// \t? `if(!c.body) error = parseError`\n\t\t// \t: ''\n\t}\n\n\t${maybeAsync ? '' : 'return (async () => {'}\n\t\tconst set = c.set\n\n\t\tif (!set.status || set.status < 300) set.status = 500\n\n\t\t${\n\t\t\thooks.error.length\n\t\t\t\t? `for (let i = 0; i < handleErrors.length; i++) {\n\t\t\t\tlet handled = handleErrors[i]({\n\t\t\t\t\trequest: c.request,\n\t\t\t\t\terror: error,\n\t\t\t\t\tset,\n\t\t\t\t\tcode: error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t\t})\n\t\t\t\tif (handled instanceof Promise) handled = await handled\n\n\t\t\t\tconst response = mapEarlyResponse(handled, set)\n\t\t\t\tif (response) return response\n\t\t\t}`\n\t\t\t\t: ''\n\t\t}\n\n\t\treturn handleError(c.request, error, set)\n\t${maybeAsync ? '' : '})()'}\n} finally {\n\t${handleResponse}\n}`\n\t}\n\n\t// console.log(fnLiteral)\n\n\tfnLiteral = `const { \n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tonResponse\n\t\t},\n\t\tvalidator: {\n\t\t\tbody,\n\t\t\theaders,\n\t\t\tparams,\n\t\t\tquery,\n\t\t\tresponse\n\t\t},\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tmeta,\n\t\tERROR_CODE\n\t} = hooks\n\n\t${\n\t\thooks.onResponse.length\n\t\t\t? `const ${hooks.onResponse\n\t\t\t\t\t.map((x, i) => `res${i} = onResponse[${i}]`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\treturn ${maybeAsync ? 'async' : ''} function(c) {\n\t\t${meta ? 'c[\"schema\"] = meta[\"schema\"]; c[\"defs\"] = meta[\"defs\"];' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\t// console.log(fnLiteral)\n\n\tconst createHandler = Function('hooks', fnLiteral)\n\n\treturn createHandler({\n\t\thandler,\n\t\thooks,\n\t\tvalidator,\n\t\thandleError,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError\n\t\t},\n\t\tmeta,\n\t\tERROR_CODE\n\t})\n}\n\nexport const composeGeneralHandler = (app: Elysia<any, any>) => {\n\tlet decoratorsLiteral = ''\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.decorators))\n\t\tdecoratorsLiteral += `,${key}: app.decorators.${key}`\n\n\t// @ts-ignore\n\tconst { router, staticRouter } = app\n\n\tconst findDynamicRoute = `\n\tconst route = find(request.method, path) ${\n\t\trouter.root.ALL ? '?? find(\"ALL\", path)' : ''\n\t}\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `handleError(\n\t\t\trequest,\n\t\t\tnotFound,\n\t\t\tctx.set\n\t\t)`\n\t\t\t\t: `new Response(error404, {\n\t\t\t\t\tstatus: 404\n\t\t\t\t})`\n\t\t}\n\n\tctx.params = route.params\n\n\treturn route.store(ctx)`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(staticRouter.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: ${findDynamicRoute}`\n\t\t}}\\n\\n`\n\n\tlet fnLiteral = `const {\n\t\tapp,\n\t\tapp: { store, router, staticRouter },\n\t\tmapEarlyResponse,\n\t\tNotFoundError\n\t} = data\n\n\tconst notFound = new NotFoundError()\n\n\t${app.event.request.length ? `const onRequest = app.event.request` : ''}\n\n\t${staticRouter.variables}\n\n\tconst find = router.find.bind(router)\n\tconst handleError = app.handleError.bind(this)\n\n\t${app.event.error.length ? '' : `const error404 = notFound.message.toString()`}\n\n\treturn function(request) {\n\t`\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\n\t\t\tconst ctx = {\n\t\t\t\trequest,\n\t\t\t\tstore,\n\t\t\t\tset: {\n\t\t\t\t\theaders: {},\n\t\t\t\t\tstatus: 200\n\t\t\t\t}\n\t\t\t\t${decoratorsLiteral}\n\t\t\t}\n\n\t\t\ttry {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst withReturn = hasReturn(app.event.request[i].toString())\n\n\t\t\tfnLiteral += !withReturn\n\t\t\t\t? `mapEarlyResponse(onRequest[${i}](ctx), ctx.set);`\n\t\t\t\t: `const response = mapEarlyResponse(\n\t\t\t\t\tonRequest[${i}](ctx),\n\t\t\t\t\tctx.set\n\t\t\t\t)\n\t\t\t\tif (response) return response\\n`\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn handleError(request, error, ctx.set)\n\t\t}\n\t\t\n\t\tconst url = request.url,\n\t\ts = url.indexOf('/', 11),\n\t\ti = ctx.qi = url.indexOf('?', s + 1),\n\t\tpath = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`\n\t} else {\n\t\tfnLiteral += `\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1\n\t\t\t\t? url.substring(s)\n\t\t\t\t: url.substring(s, qi)\n\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\tset: {\n\t\t\t\theaders: {},\n\t\t\t\tstatus: 200\n\t\t\t}\n\t\t\t${decoratorsLiteral}\n\t\t}`\n\t}\n\n\tfnLiteral += `\n\t\tswitch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\t${findDynamicRoute}\n\t\t}\n\t}`\n\n\t// @ts-ignore\n\tapp.handleError = composeErrorHandler(app) as any\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError\n\t})\n}\n\nexport const composeErrorHandler = (app: Elysia<any, any>) => {\n\tlet fnLiteral = `const {\n\t\tapp: { event: { error: onError, onResponse: res } },\n\t\tmapResponse,\n\t\tERROR_CODE\n\t} = inject\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) ? 'async' : ''\n\t} function(request, error, set) {`\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${isAsync(handler) ? 'await ' : ''}onError[${i}]({\n\t\t\trequest,\n\t\t\tcode: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',\n\t\t\terror,\n\t\t\tset\n\t\t})`\n\n\t\tif (hasReturn(handler.toString()))\n\t\t\tfnLiteral += `const r${i} = ${response}; if(r${i} !== undefined) return mapResponse(r${i}, set)\\n`\n\t\telse fnLiteral += response + '\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\") {\n\t\tset.status = error.status ?? 400\n\t\treturn new Response(\n\t\t\terror.message, \n\t\t\t{ headers: set.headers, status: set.status }\n\t\t)\n\t} else {\n\t\treturn new Response(error.message, { headers: set.headers, status: error.status ?? 500 })\n\t}\n}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE\n\t})\n}\n",
  "import { Memoirist } from 'memoirist'\nimport type {\n\tServerWebSocket,\n\tServerWebSocketSendStatus,\n\tWebSocketHandler\n} from 'bun'\n\nimport type { Elysia, Context } from '..'\n\nimport type { ElysiaWSContext } from './types'\nimport { ValidationError } from '../error'\n\nconst getPath = (url: string) => {\n\tconst start = url.indexOf('/', 10)\n\tconst end = url.indexOf('?', start)\n\n\tif (end === -1) return url.slice(start)\n\n\treturn url.slice(start, end)\n}\n\nexport class ElysiaWS<WS extends ElysiaWSContext> {\n\traw: WS\n\tdata: WS['data']\n\tisSubscribed: WS['isSubscribed']\n\n\tconstructor(ws: WS) {\n\t\tthis.raw = ws\n\t\tthis.data = ws.data\n\t\tthis.isSubscribed = ws.isSubscribed\n\t}\n\n\tpublish(\n\t\ttopic: string,\n\t\tdata: WS['data']['schema']['response'] = undefined as any,\n\t\tcompress?: boolean\n\t) {\n\t\t// @ts-ignore\n\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\treturn this\n\t}\n\n\tpublishToSelf(\n\t\ttopic: string,\n\t\tdata: WS['data']['schema']['response'] = undefined as any,\n\t\tcompress?: boolean\n\t) {\n\t\t// @ts-ignore\n\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\treturn this\n\t}\n\n\tsend(data: WS['data']['schema']['response']) {\n\t\t// @ts-ignore\n\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\tthis.raw.send(data as unknown as string)\n\n\t\treturn this\n\t}\n\n\tsubscribe(room: string) {\n\t\tthis.raw.subscribe(room)\n\n\t\treturn this\n\t}\n\n\tunsubscribe(room: string) {\n\t\tthis.raw.unsubscribe(room)\n\n\t\treturn this\n\t}\n\n\tcork(callback: (ws: ServerWebSocket<any>) => any) {\n\t\tthis.raw.cork(callback)\n\n\t\treturn this\n\t}\n\n\tclose() {\n\t\tthis.raw.close()\n\n\t\treturn this\n\t}\n}\n\n/**\n * Register websocket config for Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n * import { websocket } from '@elysiajs/websocket'\n *\n * const app = new Elysia()\n *     .use(websocket())\n *     .ws('/ws', {\n *         message: () => \"Hi\"\n *     })\n *     .listen(8080)\n * ```\n */\nexport const ws =\n\t(config?: Omit<WebSocketHandler, 'open' | 'message' | 'close' | 'drain'>) =>\n\t(app: Elysia) => {\n\t\t// @ts-ignore\n\t\tif (!app.wsRouter) app.wsRouter = new Memoirist()\n\n\t\t// @ts-ignore\n\t\tconst router = app.wsRouter!\n\n\t\tif (!app.config.serve)\n\t\t\tapp.config.serve = {\n\t\t\t\twebsocket: {\n\t\t\t\t\t...config,\n\t\t\t\t\topen(ws) {\n\t\t\t\t\t\tif (!ws.data) return\n\n\t\t\t\t\t\tconst url = getPath(\n\t\t\t\t\t\t\t(ws?.data as unknown as Context).request.url\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!url) return\n\n\t\t\t\t\t\tconst route = router.find('subscribe', url)?.store\n\n\t\t\t\t\t\tif (route && route.open)\n\t\t\t\t\t\t\troute.open(new ElysiaWS(ws as any))\n\t\t\t\t\t},\n\t\t\t\t\tmessage(ws, message: any): void {\n\t\t\t\t\t\tif (!ws.data) return\n\n\t\t\t\t\t\tconst url = getPath(\n\t\t\t\t\t\t\t(ws?.data as unknown as Context).request.url\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!url) return\n\n\t\t\t\t\t\tconst route = router.find('subscribe', url)?.store\n\t\t\t\t\t\tif (!route?.message) return\n\n\t\t\t\t\t\tmessage = message.toString()\n\t\t\t\t\t\tconst start = message.charCodeAt(0)\n\n\t\t\t\t\t\tif (start === 47 || start === 123)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// Not empty\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!Number.isNaN(+message)) message = +message\n\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\ti <\n\t\t\t\t\t\t\t(ws.data as ElysiaWSContext['data'])\n\t\t\t\t\t\t\t\t.transformMessage.length;\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst temp: any = (\n\t\t\t\t\t\t\t\tws.data as ElysiaWSContext['data']\n\t\t\t\t\t\t\t).transformMessage[i](message)\n\n\t\t\t\t\t\t\tif (temp !== undefined) message = temp\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(ws.data as ElysiaWSContext['data']).message?.Check(\n\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t) === false\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t(ws.data as ElysiaWSContext['data'])\n\t\t\t\t\t\t\t\t\t\t.message as any,\n\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t).cause as string\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\troute.message(new ElysiaWS(ws as any), message)\n\t\t\t\t\t},\n\t\t\t\t\tclose(ws, code, reason) {\n\t\t\t\t\t\tif (!ws.data) return\n\n\t\t\t\t\t\tconst url = getPath(\n\t\t\t\t\t\t\t(ws?.data as unknown as Context).request.url\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!url) return\n\n\t\t\t\t\t\tconst route = router.find('subscribe', url)?.store\n\n\t\t\t\t\t\tif (route && route.close)\n\t\t\t\t\t\t\troute.close(new ElysiaWS(ws as any), code, reason)\n\t\t\t\t\t},\n\t\t\t\t\tdrain(ws) {\n\t\t\t\t\t\tif (!ws.data) return\n\n\t\t\t\t\t\tconst url = getPath(\n\t\t\t\t\t\t\t(ws?.data as unknown as Context).request.url\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (!url) return\n\n\t\t\t\t\t\tconst route = router.find('subscribe', url)?.store\n\n\t\t\t\t\t\tif (route && route.drain)\n\t\t\t\t\t\t\troute.drain(new ElysiaWS(ws as any))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn app\n\t\t\t.decorate('publish', app.server?.publish as WSPublish)\n\t\t\t.onStart((app) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.decorators.publish = app.server?.publish\n\t\t\t})\n\t}\n\ntype WSPublish = (\n\ttopic: string,\n\tdata: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n\tcompress?: boolean\n) => ServerWebSocketSendStatus\n\nexport type {\n\tWSTypedSchema,\n\tWebSocketHeaderHandler,\n\tWebSocketSchemaToRoute,\n\tElysiaWSContext,\n\tElysiaWSOptions,\n\tTransformMessageHandler\n} from './types'\n",
  "import type { Elysia } from '.'\n\nimport {\n\tElysiaErrors,\n\tNotFoundError,\n\tValidationError,\n\tERROR_CODE\n} from './error'\nimport { mapEarlyResponse, mapResponse } from './handler'\n\nimport type { Context } from './context'\nimport type { Handler, RegisteredHook, SchemaValidator } from './types'\n\nimport { parse as parseQuery } from 'fast-querystring'\n\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: RegisteredHook<any>\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst set: Context['set'] = {\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tlet context: Context\n\n\t\t// @ts-ignore\n\t\tif (app.decorators) {\n\t\t\t// @ts-ignore\n\t\t\tcontext = app.decorators as any as Context\n\n\t\t\tcontext.request = request\n\t\t\tcontext.set = set\n\t\t\tcontext.store = app.store\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tcontext = {\n\t\t\t\tset,\n\t\t\t\tstore: app.store,\n\t\t\t\trequest\n\t\t\t}\n\t\t}\n\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tq = url.indexOf('?', s + 1),\n\t\t\tpath = q === -1 ? url.substring(s) : url.substring(s, q)\n\n\t\ttry {\n\t\t\t// @ts-ignore\n\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst onRequest = app.event.request[i]\n\t\t\t\tlet response = onRequest(context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return response\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find(request.method, path) ??\n\t\t\t\t// @ts-ignore\n\t\t\t\tapp.dynamicRouter.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tfor (let i = 0; i < app.event.parse.length; i++) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tlet temp = app.event.parse[i](context, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = await request.json()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\tcontext.params = handler?.params || {}\n\t\t\tcontext.query = q === -1 ? {} : parseQuery(url.substring(q + 1))\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst operation = hooks.transform[i](context)\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (hooks.transform[i].$elysia === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.headers) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.params?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.query?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.body?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i](context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i](\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return result\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst responseValidator = validator?.response?.[response.status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i](context, response)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[response.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\treturn mapResponse(response, context.set)\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-ignore\n\t\t\treturn app.handleError(request, error as Error, set)\n\t\t} finally {\n\t\t\t// @ts-ignore\n\t\t\tfor (const onResponse of app.event.onResponse)\n\t\t\t\tawait onResponse(context)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any>) =>\n\tasync (\n\t\trequest: Request,\n\t\terror: ElysiaErrors,\n\t\tset: Context['set'] = {\n\t\t\theaders: {}\n\t\t}\n\t) => {\n\t\t// @ts-ignore\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\t// @ts-ignore\n\t\t\tlet response = app.event.error[i]({\n\t\t\t\trequest,\n\t\t\t\t// @ts-ignore\n\t\t\t\tcode: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',\n\t\t\t\terror,\n\t\t\t\tset\n\t\t\t})\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn mapResponse(response, set)\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
  "import {\n\tType,\n\ttype SchemaOptions,\n\ttype NumericOptions\n} from '@sinclair/typebox'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\nimport { TypeSystem } from '@sinclair/typebox/system'\n\ntry {\n\tTypeSystem.Format('email', (value) =>\n\t\t/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format('uuid', (value) =>\n\t\t/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n\t\t\tvalue\n\t\t)\n\t)\n\n\tTypeSystem.Format(\n\t\t'date',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n\n\tTypeSystem.Format(\n\t\t'date-time',\n\t\t(value) => !Number.isNaN(new Date(value).getTime())\n\t)\n} catch (error) {\n\t// Not empty\n}\n\ntype MaybeArray<T> = T | T[]\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumericOptions<number>\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<\n\t\t\t| (string & {})\n\t\t\t| 'image'\n\t\t\t| 'image/jpeg'\n\t\t\t| 'image/png'\n\t\t\t| 'image/gif'\n\t\t\t| 'image/tiff'\n\t\t\t| 'image/x-icon'\n\t\t\t| 'image/svg'\n\t\t\t| 'image/webp'\n\t\t\t| 'image/avif'\n\t\t\t| 'audio'\n\t\t\t| 'audio/mpeg'\n\t\t\t| 'audio/x-ms-wma'\n\t\t\t| 'audio/vnd.rn-realaudio'\n\t\t\t| 'audio/x-wav'\n\t\t\t| 'video'\n\t\t\t| 'video/mpeg'\n\t\t\t| 'video/mp4'\n\t\t\t| 'video/quicktime'\n\t\t\t| 'video/x-ms-wmv'\n\t\t\t| 'video/x-msvideo'\n\t\t\t| 'video/x-flv'\n\t\t\t| 'video/webm'\n\t\t\t| 'text'\n\t\t\t| 'text/css'\n\t\t\t| 'text/csv'\n\t\t\t| 'text/html'\n\t\t\t| 'text/javascript'\n\t\t\t| 'text/plain'\n\t\t\t| 'text/xml'\n\t\t\t| 'application'\n\t\t\t| 'application/ogg'\n\t\t\t| 'application/pdf'\n\t\t\t| 'application/xhtml'\n\t\t\t| 'application/html'\n\t\t\t| 'application/json'\n\t\t\t| 'application/ld+json'\n\t\t\t| 'application/xml'\n\t\t\t| 'application/zip'\n\t\t>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\nexport const ElysiaType = {\n\t// Numeric type is for type reference only since it's aliased to t.Number\n\tNumeric: TypeSystem.Type<number, NumericOptions<number>>(\n\t\t'Numeric',\n\t\t{} as any\n\t),\n\tFile: TypeSystem.Type<Blob, ElysiaTypeOptions.File>('File', validateFile),\n\tFiles: TypeSystem.Type<Blob[], ElysiaTypeOptions.Files>(\n\t\t'Files',\n\t\t(options, value) => {\n\t\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\t\tif (options.minItems && value.length < options.minItems)\n\t\t\t\treturn false\n\n\t\t\tif (options.maxItems && value.length > options.maxItems)\n\t\t\t\treturn false\n\n\t\t\tfor (let i = 0; i < value.length; i++)\n\t\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\t\treturn true\n\t\t}\n\t)\n} as const\n\ndeclare module '@sinclair/typebox' {\n\tinterface TypeBuilder {\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\tFile: typeof ElysiaType.File\n\t\tFiles: typeof ElysiaType.Files\n\t\tURLEncoded: (typeof Type)['Object']\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| ((\n\t\t\t\t\ttype: string,\n\t\t\t\t\tvalidator: TypeCheck<any>,\n\t\t\t\t\tvalue: unknown\n\t\t\t  ) => string | void)\n\t}\n}\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nType.Numeric = (properties) => {\n\treturn Type.Number({\n\t\t...properties,\n\t\telysiaMeta: 'Numeric'\n\t}) as any\n}\n\nType.URLEncoded = (property, options) =>\n\tType.Object(property, {\n\t\t...options,\n\t\telysiaMeta: 'URLEncoded'\n\t})\n\nType.File = (arg?: ElysiaTypeOptions.File) =>\n\tElysiaType.File({\n\t\telysiaMeta: 'File',\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nType.Files = (arg?: ElysiaTypeOptions.Files) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nexport { Type as t }\n",
  "import { Memoirist } from 'memoirist'\nimport type { Serve, Server } from 'bun'\n\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tmergeDeep,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasGlobal\n} from './utils'\nimport type { Context } from './context'\n\nimport {\n\tcomposeErrorHandler,\n\tcomposeGeneralHandler,\n\tcomposeHandler\n} from './compose'\n\nimport { ws } from './ws'\nimport type { ElysiaWSContext, ElysiaWSOptions, WSTypedSchema } from './ws'\n\nimport type {\n\tHandler,\n\tRegisteredHook,\n\tVoidRequestHandler,\n\tTypedRoute,\n\tElysiaInstance,\n\tElysiaConfig,\n\tHTTPMethod,\n\tComposedHandler,\n\tInternalRoute,\n\tBodyParser,\n\tErrorHandler,\n\tTypedSchema,\n\tLocalHook,\n\tLocalHandler,\n\tLifeCycle,\n\tLifeCycleEvent,\n\tLifeCycleStore,\n\tVoidLifeCycle,\n\tAfterRequestHandler,\n\tSchemaValidator,\n\tIsAny,\n\tOverwritableTypeRoute,\n\tMergeSchema,\n\tListenCallback,\n\tNoReturnHandler,\n\tMaybePromise,\n\tPrettify,\n\tTypedWSRouteToEden,\n\tUnwrapSchema,\n\tExtractPath,\n\tTypedSchemaToRoute,\n\tDeepWritable,\n\tReconciliation,\n\tBeforeRequestHandler,\n\tElysiaDefaultMeta\n} from './types'\nimport type { Static, TSchema } from '@sinclair/typebox'\n\nimport {\n\ttype ValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError,\n\tisProduction,\n\tERROR_CODE\n} from './error'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(8080)\n * ```\n */\nexport default class Elysia<\n\tBasePath extends string = '',\n\tInstance extends ElysiaInstance<{\n\t\tstore?: Record<string, unknown>\n\t\trequest?: Record<string, unknown>\n\t\terror?: Record<string, Error>\n\t\tschema?: TypedSchema<any>\n\t\tmeta?: ElysiaDefaultMeta\n\t}> = {\n\t\tstore: {}\n\t\trequest: {}\n\t\tschema: {}\n\t\terror: {}\n\t\tmeta: {\n\t\t\tschema: {}\n\t\t\tdefs: {}\n\t\t\texposed: {}\n\t\t}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath>\n\tprivate dependencies: Record<string, number[]> = {}\n\n\tstore: Instance['store'] = {}\n\tmeta: Instance['meta'] = {\n\t\tschema: Object.create(null),\n\t\tdefs: Object.create(null),\n\t\texposed: Object.create(null)\n\t}\n\n\t// Will be applied to Context\n\tprivate decorators: Instance['request'] = {}\n\n\tevent: LifeCycleStore<Instance> = {\n\t\tstart: [],\n\t\trequest: [],\n\t\tparse: [],\n\t\ttransform: [],\n\t\tbeforeHandle: [],\n\t\tafterHandle: [],\n\t\tonResponse: [],\n\t\terror: [],\n\t\tstop: []\n\t}\n\n\tserver: Server | null = null\n\n\tprivate $schema: SchemaValidator | null = null\n\tprivate error: Instance['error'] = {}\n\n\tprivate router = new Memoirist<ComposedHandler>()\n\troutes: InternalRoute<Instance>[] = []\n\n\tprivate staticRouter = {\n\t\thandlers: [] as ComposedHandler[],\n\t\tvariables: '',\n\t\tmap: {} as Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tcode: string\n\t\t\t\tall?: string\n\t\t\t}\n\t\t>,\n\t\tall: ''\n\t}\n\tprivate wsRouter: Memoirist<any> | undefined\n\n\tprivate dynamicRouter = new Memoirist<DynamicHandler>()\n\tprivate lazyLoadModules: Promise<Elysia<any, any>>[] = []\n\tpath: BasePath = '' as any\n\n\tconstructor(config?: Partial<ElysiaConfig<BasePath>>) {\n\t\tthis.config = {\n\t\t\tforceErrorEncapsulation: false,\n\t\t\tprefix: '',\n\t\t\taot: true,\n\t\t\tstrictPath: false,\n\t\t\tscoped: false,\n\t\t\t...config,\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandler: LocalHandler<any, any>,\n\t\thook?: LocalHook<any, any, string>,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tpath =\n\t\t\tpath === '' ? path : path.charCodeAt(0) === 47 ? path : `/${path}`\n\n\t\tif (this.config.prefix && !skipPrefix) path = this.config.prefix + path\n\n\t\tconst defs = this.meta.defs\n\n\t\tif (hook?.type)\n\t\t\tswitch (hook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\thook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\thook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\thook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\thook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\thook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst validator = {\n\t\t\tbody: getSchemaValidator(\n\t\t\t\thook?.body ?? (this.$schema?.body as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels: defs\n\t\t\t\t}\n\t\t\t),\n\t\t\theaders: getSchemaValidator(\n\t\t\t\thook?.headers ?? (this.$schema?.headers as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels: defs,\n\t\t\t\t\tadditionalProperties: true\n\t\t\t\t}\n\t\t\t),\n\t\t\tparams: getSchemaValidator(\n\t\t\t\thook?.params ?? (this.$schema?.params as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels: defs\n\t\t\t\t}\n\t\t\t),\n\t\t\tquery: getSchemaValidator(\n\t\t\t\thook?.query ?? (this.$schema?.query as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels: defs\n\t\t\t\t}\n\t\t\t),\n\t\t\tresponse: getResponseSchemaValidator(\n\t\t\t\thook?.response ?? (this.$schema?.response as any),\n\t\t\t\t{\n\t\t\t\t\tdynamic: !this.config.aot,\n\t\t\t\t\tmodels: defs\n\t\t\t\t}\n\t\t\t)\n\t\t} as any\n\n\t\tconst hooks = mergeHook(this.event, hook as RegisteredHook)\n\t\tconst loosePath = path.endsWith('/')\n\t\t\t? path.slice(0, path.length - 1)\n\t\t\t: path + '/'\n\n\t\tif (this.config.aot === false) {\n\t\t\tthis.dynamicRouter.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: hook?.type as string,\n\t\t\t\thandle: handler\n\t\t\t})\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tthis.dynamicRouter.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: hook?.type as string,\n\t\t\t\t\thandle: handler\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.routes.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler,\n\t\t\t\thooks\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tconst mainHandler = composeHandler({\n\t\t\tpath,\n\t\t\tmethod,\n\t\t\thooks,\n\t\t\tvalidator,\n\t\t\thandler,\n\t\t\thandleError: this.handleError,\n\t\t\tmeta: allowMeta ? this.meta : undefined,\n\t\t\tonRequest: this.event.request,\n\t\t\tconfig: this.config\n\t\t})\n\n\t\tthis.routes.push({\n\t\t\tmethod,\n\t\t\tpath,\n\t\t\tcomposed: mainHandler,\n\t\t\thandler,\n\t\t\thooks\n\t\t})\n\n\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\tconst index = this.staticRouter.handlers.length\n\t\t\tthis.staticRouter.handlers.push(mainHandler)\n\n\t\t\tthis.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\\n`\n\n\t\t\tif (!this.staticRouter.map[path])\n\t\t\t\tthis.staticRouter.map[path] = {\n\t\t\t\t\tcode: ''\n\t\t\t\t}\n\n\t\t\tif (method === 'ALL')\n\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\tpath\n\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\telse\n\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\tpath\n\t\t\t\t].code += `case '${method}': return st${index}(ctx)\\n`\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tif (!this.staticRouter.map[loosePath])\n\t\t\t\t\tthis.staticRouter.map[loosePath] = {\n\t\t\t\t\t\tcode: ''\n\t\t\t\t\t}\n\n\t\t\t\tif (method === 'ALL')\n\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\tloosePath\n\t\t\t\t\t].all = `default: return st${index}(ctx)\\n`\n\t\t\t\telse\n\t\t\t\t\tthis.staticRouter.map[\n\t\t\t\t\t\tloosePath\n\t\t\t\t\t].code += `case '${method}': return st${index}(ctx)\\n`\n\t\t\t}\n\t\t} else {\n\t\t\tthis.router.add(method, path, mainHandler)\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath.endsWith('/')\n\t\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t\t: path + '/',\n\t\t\t\t\tmainHandler\n\t\t\t\t)\n\t\t}\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ url, port }) => {\n\t *         console.log(\"Running at ${url}:${port}\")\n\t *     })\n\t *     .listen(8080)\n\t * ```\n\t */\n\tonStart(handler: VoidLifeCycle<Instance>) {\n\t\tthis.on('start', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<Route extends OverwritableTypeRoute = TypedRoute>(\n\t\thandler: BeforeRequestHandler<Route, Instance>\n\t) {\n\t\tthis.on('request', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse(parser: BodyParser<any, Instance>) {\n\t\tthis.on('parse', parser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<Route extends OverwritableTypeRoute = TypedRoute>(\n\t\thandler: NoReturnHandler<Route, Instance>\n\t) {\n\t\tthis.on('transform', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Intercept request **before(()) main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<Route extends OverwritableTypeRoute = TypedRoute>(\n\t\thandler: Handler<Route, Instance>\n\t) {\n\t\tthis.on('beforeHandle', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<Route extends OverwritableTypeRoute = TypedRoute>(\n\t\thandler: AfterRequestHandler<Route, Instance>\n\t) {\n\t\tthis.on('afterHandle', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Called when handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\n\tonResponse<Route extends OverwritableTypeRoute = TypedRoute>(\n\t\thandler: VoidRequestHandler<Route, Instance>\n\t) {\n\t\tthis.on('response', handler)\n\n\t\treturn this\n\t}\n\n\taddError<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error'] & {\n\t\t\t\t[K in NonNullable<keyof Errors>]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\taddError<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\taddError(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): Elysia<any, any> {\n\t\tif (typeof name === 'string' && error) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\treturn this\n\t\t}\n\n\t\t// @ts-ignore\n\t\tfor (const [code, error] of Object.entries(name))\n\t\t\terror.prototype[ERROR_CODE] = code\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(handler: ErrorHandler<Instance['error']>): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error']\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t> {\n\t\tthis.on('error', handler)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: VoidLifeCycle<Instance>) {\n\t\tthis.on('stop', handler)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends LifeCycleEvent = LifeCycleEvent>(\n\t\ttype: Event,\n\t\thandler: LifeCycle<Instance>[Event]\n\t) {\n\t\thandler = asGlobal(handler)\n\n\t\tswitch (type) {\n\t\t\tcase 'start':\n\t\t\t\tthis.event.start.push(handler as LifeCycle<Instance>['start'])\n\t\t\t\tbreak\n\n\t\t\tcase 'request':\n\t\t\t\tthis.event.request.push(handler as LifeCycle['request'])\n\t\t\t\tbreak\n\n\t\t\tcase 'response':\n\t\t\t\tthis.event.onResponse.push(handler as LifeCycle['response'])\n\t\t\t\tbreak\n\n\t\t\tcase 'parse':\n\t\t\t\tthis.event.parse.splice(\n\t\t\t\t\tthis.event.parse.length - 1,\n\t\t\t\t\t0,\n\t\t\t\t\thandler as BodyParser<any, Instance>\n\t\t\t\t)\n\t\t\t\tbreak\n\n\t\t\tcase 'transform':\n\t\t\t\tthis.event.transform.push(handler as LifeCycle['transform'])\n\t\t\t\tbreak\n\n\t\t\tcase 'beforeHandle':\n\t\t\t\tthis.event.beforeHandle.push(\n\t\t\t\t\thandler as LifeCycle<Instance>['beforeHandle']\n\t\t\t\t)\n\t\t\t\tbreak\n\n\t\t\tcase 'afterHandle':\n\t\t\t\tthis.event.afterHandle.push(handler as LifeCycle['afterHandle'])\n\t\t\t\tbreak\n\n\t\t\tcase 'error':\n\t\t\t\tthis.event.error.push(handler as LifeCycle['error'])\n\t\t\t\tbreak\n\n\t\t\tcase 'stop':\n\t\t\t\tthis.event.stop.push(handler as LifeCycle<Instance>['stop'])\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn this\n\t}\n\n\tgroup<\n\t\tNewElysia extends Elysia<any, any> = Elysia<any, any>,\n\t\tPrefix extends string = string\n\t>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tstore: Instance['store'] & ElysiaInstance['store']\n\t\t\t\t\tschema: Instance['schema']\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tschema: Instance['meta']['schema']\n\t\t\t\t\t\tdefs: Instance['meta']['defs']\n\t\t\t\t\t\texposed: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>\n\t\t) => NewElysia\n\t): NewElysia extends Elysia<`${BasePath}${Prefix}`, infer NewInstance>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tschema: Instance['schema']\n\t\t\t\t\tstore: Instance['store']\n\t\t\t\t\tmeta: Instance['meta'] & NewInstance['meta']\n\t\t\t\t}\n\t\t  >\n\t\t: this\n\n\tgroup<\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>,\n\t\tNewElysia extends Elysia<any, any> = Elysia<any, any>,\n\t\tPrefix extends string = string\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<Schema, Instance, `${BasePath}${Prefix}`>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tstore: Instance['store'] & ElysiaInstance['store']\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tbody: undefined extends Schema['body']\n\t\t\t\t\t\t\t? Instance['schema']['body']\n\t\t\t\t\t\t\t: Schema['body']\n\t\t\t\t\t\theaders: undefined extends Schema['headers']\n\t\t\t\t\t\t\t? Instance['schema']['headers']\n\t\t\t\t\t\t\t: Schema['headers']\n\t\t\t\t\t\tquery: undefined extends Schema['query']\n\t\t\t\t\t\t\t? Instance['schema']['query']\n\t\t\t\t\t\t\t: Schema['query']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Instance['schema']['params']\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tresponse: undefined extends Schema['response']\n\t\t\t\t\t\t\t? Instance['schema']['response']\n\t\t\t\t\t\t\t: Schema['response']\n\t\t\t\t\t}\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tschema: Instance['meta']['schema']\n\t\t\t\t\t\tdefs: Instance['meta']['defs']\n\t\t\t\t\t\texposed: {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>\n\t\t) => NewElysia\n\t): NewElysia extends Elysia<`${BasePath}${Prefix}`, infer NewInstance>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tschema: Instance['schema']\n\t\t\t\t\tstore: Instance['store']\n\t\t\t\t\tmeta: Instance['meta'] &\n\t\t\t\t\t\t(Omit<NewInstance['meta'], 'schema'> &\n\t\t\t\t\t\t\tRecord<\n\t\t\t\t\t\t\t\t'schema',\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t[Path in keyof NewInstance['meta']['schema']]: NewInstance['meta']['schema'][Path]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>)\n\t\t\t\t}\n\t\t  >\n\t\t: this\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup<\n\t\tExecutor extends (group: Elysia) => Elysia,\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>\n\t>(\n\t\tprefix: string,\n\t\tschemaOrRun: LocalHook<Schema, Instance> | Executor,\n\t\trun?: Executor\n\t): this {\n\t\tconst instance = new Elysia<any, any>({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.store = this.store\n\n\t\tif (this.wsRouter) instance.use(ws())\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...(sandbox.event.request as any)\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...(sandbox.event.onResponse as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.meta.defs)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = this.config.prefix + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks\n\n\t\t\t\t\t// Same as guard\n\t\t\t\t\tconst hasWsRoute = instance.wsRouter?.find(\n\t\t\t\t\t\t'subscribe',\n\t\t\t\t\t\tpath\n\t\t\t\t\t)\n\t\t\t\t\tif (hasWsRoute) {\n\t\t\t\t\t\tconst wsRoute = instance.wsRouter!.history.find(\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t\t\t([_, wsPath]) => path === wsPath\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (!wsRoute) return\n\n\t\t\t\t\t\treturn this.ws(path as any, wsRoute[2] as any)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook as LocalHook<any, any>, {\n\t\t\t\t\t\t\t...localHook,\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tconst hasWsRoute = instance.wsRouter?.find(\n\t\t\t\t\t\t'subscribe',\n\t\t\t\t\t\tpath\n\t\t\t\t\t)\n\t\t\t\t\tif (hasWsRoute) {\n\t\t\t\t\t\tconst wsRoute = instance.wsRouter!.history.find(\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t\t\t([_, wsPath]) => path === wsPath\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (!wsRoute) return\n\n\t\t\t\t\t\treturn this.ws(path as any, wsRoute[2] as any)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\tif (instance.wsRouter && this.wsRouter)\n\t\t\tinstance.wsRouter.history.forEach(([method, path, handler]) => {\n\t\t\t\tpath = this.config.prefix + prefix + path\n\n\t\t\t\tif (path === '/') this.wsRouter?.add(method, prefix, handler)\n\t\t\t\telse this.wsRouter?.add(method, `${prefix}${path}`, handler)\n\t\t\t})\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>\n\t>(\n\t\thook: LocalHook<Schema, Instance>\n\t): Elysia<\n\t\tany,\n\t\t{\n\t\t\terror: Instance['error']\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta'] &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\t{\n\t\t\t\t\t\t[key in keyof Schema]: Schema[key]\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t}\n\t>\n\n\tguard<\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>,\n\t\tNewElysia extends Elysia<any, any> = Elysia<any, any>\n\t>(\n\t\thook: LocalHook<Schema, Instance>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tstore: Instance['store']\n\t\t\t\t\tschema: {\n\t\t\t\t\t\tbody: undefined extends Schema['body']\n\t\t\t\t\t\t\t? Instance['schema']['body']\n\t\t\t\t\t\t\t: Schema['body']\n\t\t\t\t\t\theaders: undefined extends Schema['headers']\n\t\t\t\t\t\t\t? Instance['schema']['headers']\n\t\t\t\t\t\t\t: Schema['headers']\n\t\t\t\t\t\tquery: undefined extends Schema['query']\n\t\t\t\t\t\t\t? Instance['schema']['query']\n\t\t\t\t\t\t\t: Schema['query']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? Instance['schema']['params']\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tresponse: undefined extends Schema['response']\n\t\t\t\t\t\t\t? Instance['schema']['response']\n\t\t\t\t\t\t\t: Schema['response']\n\t\t\t\t\t}\n\t\t\t\t\tmeta: Instance['meta']\n\t\t\t\t}\n\t\t\t>\n\t\t) => NewElysia\n\t): NewElysia extends Elysia<any, infer NewInstance>\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\terror: Instance['error']\n\t\t\t\t\trequest: Instance['request']\n\t\t\t\t\tstore: Instance['store']\n\t\t\t\t\tschema: Instance['schema']\n\t\t\t\t\tmeta: Instance['meta'] &\n\t\t\t\t\t\tRecord<\n\t\t\t\t\t\t\t'schema',\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t[key in keyof NewInstance['meta']['schema']]: NewInstance['meta']['schema'][key]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t}\n\t\t  >\n\t\t: this\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook: LocalHook<any, Instance>,\n\t\trun?: (group: Elysia<any, any>) => Elysia<any, any>\n\t): Elysia<any, any> {\n\t\tif (!run) {\n\t\t\tthis.event = mergeLifeCycle(this.event, hook)\n\t\t\tthis.$schema = {\n\t\t\t\tbody: hook.body,\n\t\t\t\theaders: hook.headers,\n\t\t\t\tparams: hook.params,\n\t\t\t\tquery: hook.query,\n\t\t\t\tresponse: hook.response\n\t\t\t}\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst instance = new Elysia<any>()\n\t\tinstance.store = this.store\n\t\tif (this.wsRouter) instance.use(ws())\n\n\t\tconst sandbox = run(instance)\n\t\tthis.decorators = mergeDeep(this.decorators, instance.decorators)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...this.event.request,\n\t\t\t\t...sandbox.event.request\n\t\t\t]\n\n\t\tif (sandbox.event.onResponse.length)\n\t\t\tthis.event.onResponse = [\n\t\t\t\t...this.event.onResponse,\n\t\t\t\t...sandbox.event.onResponse\n\t\t\t]\n\n\t\tthis.model(sandbox.meta.defs)\n\n\t\tObject.values(instance.routes).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tconst hasWsRoute = instance.wsRouter?.find('subscribe', path)\n\t\t\t\tif (hasWsRoute) {\n\t\t\t\t\tconst wsRoute = instance.wsRouter!.history.find(\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t\t([_, wsPath]) => path === wsPath\n\t\t\t\t\t)\n\t\t\t\t\tif (!wsRoute) return\n\n\t\t\t\t\treturn this.ws(path as any, wsRoute[2] as any)\n\t\t\t\t}\n\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as LocalHook<any, any>, {\n\t\t\t\t\t\t...localHook,\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t? [...localHook.error, ...sandbox.event.error]\n\t\t\t\t\t\t\t: [localHook.error, ...sandbox.event.error]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\tif (instance.wsRouter && this.wsRouter)\n\t\t\tinstance.wsRouter.history.forEach(([method, path, handler]) => {\n\t\t\t\tthis.wsRouter?.add(method, path, handler)\n\t\t\t})\n\n\t\treturn this as any\n\t}\n\n\t// Inline Fn\n\tuse<\n\t\tNewInstance extends ElysiaInstance,\n\t\tParams extends Elysia = Elysia<any, any>\n\t>(\n\t\tplugin: MaybePromise<\n\t\t\t(\n\t\t\t\tapp: Params extends Elysia<any, infer ParamsInstance>\n\t\t\t\t\t? IsAny<ParamsInstance> extends true\n\t\t\t\t\t\t? this\n\t\t\t\t\t\t: any\n\t\t\t\t\t: Params\n\t\t\t) => MaybePromise<Elysia<any, NewInstance>>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\terror: Instance['error'] & NewInstance['error']\n\t\t\trequest: Reconciliation<Instance['request'], NewInstance['request']>\n\t\t\tstore: Reconciliation<Instance['store'], NewInstance['store']>\n\t\t\tschema: Instance['schema'] & NewInstance['schema']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema'] & {\n\t\t\t\t\t[Path in keyof NewInstance['meta']['schema'] as Path extends string\n\t\t\t\t\t\t? `${BasePath}${Path}`\n\t\t\t\t\t\t: Path]: NewInstance['meta']['schema'][Path]\n\t\t\t\t}\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\tNewInstance['meta']['defs']\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed'] &\n\t\t\t\t\tNewInstance['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\tuse<NewInstance extends ElysiaInstance>(\n\t\tinstance: Elysia<any, NewInstance>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\terror: Instance['error'] & NewInstance['error']\n\t\t\trequest: Reconciliation<Instance['request'], NewInstance['request']>\n\t\t\tstore: Reconciliation<Instance['store'], NewInstance['store']>\n\t\t\tschema: Instance['schema'] & NewInstance['schema']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema'] & {\n\t\t\t\t\t[Path in keyof NewInstance['meta']['schema'] as Path extends string\n\t\t\t\t\t\t? `${BasePath}${Path}`\n\t\t\t\t\t\t: Path]: NewInstance['meta']['schema'][Path]\n\t\t\t\t}\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\tNewInstance['meta']['defs']\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed'] &\n\t\t\t\t\tNewInstance['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\t// Import Fn\n\tuse<LazyLoadElysia extends ElysiaInstance>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (\n\t\t\t\telysia: Elysia<any, any>\n\t\t\t) => MaybePromise<Elysia<any, LazyLoadElysia>>\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\terror: Instance['error'] & LazyLoadElysia['error']\n\t\t\trequest: Reconciliation<\n\t\t\t\tInstance['request'],\n\t\t\t\tLazyLoadElysia['request']\n\t\t\t>\n\t\t\tstore: Reconciliation<Instance['store'], LazyLoadElysia['store']>\n\t\t\tschema: Instance['schema'] & LazyLoadElysia['schema']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema'] & {\n\t\t\t\t\t[Path in keyof LazyLoadElysia['meta']['schema'] as Path extends string\n\t\t\t\t\t\t? `${BasePath}${Path}`\n\t\t\t\t\t\t: Path]: LazyLoadElysia['meta']['schema'][Path]\n\t\t\t\t}\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\tLazyLoadElysia['meta']['defs']\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed'] &\n\t\t\t\t\tLazyLoadElysia['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\t// Import inline\n\tuse<LazyLoadElysia extends ElysiaInstance>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: Elysia<any, any>) => Elysia<any, LazyLoadElysia>\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\terror: Instance['error'] & LazyLoadElysia['error']\n\t\t\trequest: Reconciliation<\n\t\t\t\tInstance['request'],\n\t\t\t\tLazyLoadElysia['request']\n\t\t\t>\n\t\t\tstore: Reconciliation<Instance['store'], LazyLoadElysia['store']>\n\t\t\tschema: Instance['schema'] & LazyLoadElysia['schema']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema'] & {\n\t\t\t\t\t[Path in keyof LazyLoadElysia['meta']['schema'] as Path extends string\n\t\t\t\t\t\t? `${BasePath}${Path}`\n\t\t\t\t\t\t: Path]: LazyLoadElysia['meta']['schema'][Path]\n\t\t\t\t}\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\tLazyLoadElysia['meta']['defs']\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed'] &\n\t\t\t\t\tLazyLoadElysia['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| Elysia<any, any>\n\t\t\t| MaybePromise<\n\t\t\t\t\t(app: Elysia<any, any>) => MaybePromise<Elysia<any, any>>\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: Elysia<any, any>\n\t\t\t  }>\n\t\t\t| Promise<{\n\t\t\t\t\tdefault: (\n\t\t\t\t\t\telysia: Elysia<any, any>\n\t\t\t\t\t) => MaybePromise<Elysia<any, any>>\n\t\t\t  }>\n\t): Elysia<any, any> {\n\t\tconst register = (\n\t\t\tplugin:\n\t\t\t\t| Elysia<any, any>\n\t\t\t\t| ((app: Elysia<any, any>) => MaybePromise<Elysia<any, any>>)\n\t\t) => {\n\t\t\tif (typeof plugin === 'function') {\n\t\t\t\tconst instance = plugin(\n\t\t\t\t\tthis as unknown as any\n\t\t\t\t) as unknown as any\n\t\t\t\tif (instance instanceof Promise) {\n\t\t\t\t\tthis.lazyLoadModules.push(instance.then((x) => x.compile()))\n\n\t\t\t\t\treturn this as unknown as any\n\t\t\t\t}\n\n\t\t\t\treturn instance\n\t\t\t}\n\n\t\t\tconst isScoped = plugin.config.scoped\n\n\t\t\tif (!isScoped) {\n\t\t\t\tthis.decorators = mergeDeep(this.decorators, plugin.decorators)\n\t\t\t\tthis.state(plugin.store)\n\t\t\t\tthis.model(plugin.meta.defs)\n\t\t\t\tthis.addError(plugin.error)\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tconfig: { name, seed }\n\t\t\t} = plugin\n\n\t\t\tObject.values(plugin.routes).forEach(\n\t\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\t\tconst hasWsRoute = plugin.wsRouter?.find('subscribe', path)\n\t\t\t\t\tif (hasWsRoute) {\n\t\t\t\t\t\tconst wsRoute = plugin.wsRouter!.history.find(\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t\t\t([_, wsPath]) => path === wsPath\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (!wsRoute) return\n\n\t\t\t\t\t\treturn this.ws(path as any, wsRoute[2] as any)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks, {\n\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (!isScoped)\n\t\t\t\tif (name) {\n\t\t\t\t\tif (!(name in this.dependencies))\n\t\t\t\t\t\tthis.dependencies[name] = []\n\n\t\t\t\t\tconst current =\n\t\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t\t: 0\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t\t(checksum) => current === checksum\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn this\n\n\t\t\t\t\tthis.dependencies[name].push(current)\n\t\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\t\tthis.event,\n\t\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\t\tcurrent\n\t\t\t\t\t)\n\t\t\t\t} else\n\t\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\t\tthis.event,\n\t\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.lazyLoadModules.push(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\treturn register(plugin.default)\n\t\t\t\t\t})\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\n\t\t\treturn this as unknown as any\n\t\t} else return register(plugin)\n\n\t\treturn this\n\t}\n\n\tmount(handle: (request: Request) => MaybePromise<Response>): this\n\tmount(\n\t\tpath: string,\n\t\thandle: (request: Request) => MaybePromise<Response>\n\t): this\n\n\tmount(\n\t\tpath: string | ((request: Request) => MaybePromise<Response>),\n\t\thandle?: (request: Request) => MaybePromise<Response>\n\t) {\n\t\tif (typeof path === 'function' || path.length === 0 || path === '/') {\n\t\t\tconst run = typeof path === 'function' ? path : handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t\trun(new Request('http://a.cc' + path || '/', request))\n\n\t\t\tthis.all('/', handler, {\n\t\t\t\ttype: 'none'\n\t\t\t})\n\t\t\tthis.all('/*', handler, {\n\t\t\t\ttype: 'none'\n\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\thandle!(\n\t\t\t\tnew Request('http://a.cc' + path.slice(length) || '/', request)\n\t\t\t)\n\n\t\tthis.all(path, handler, {\n\t\t\ttype: 'none'\n\t\t})\n\t\tthis.all(path + (path.endsWith('/') ? '*' : '/*'), handler, {\n\t\t\ttype: 'none'\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: {\n\t\t\t\tdefs: Instance['meta']['defs']\n\t\t\t\texposed: Instance['meta']['exposed']\n\t\t\t\tschema: Prettify<\n\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: {})\n\t\t\t\t>\n\t\t\t}\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('GET', path, handler as any, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('POST', path, handler as any, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('PUT', path, handler as any, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('PATCH', path, handler as any, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tdelete: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add(\n\t\t\t\t'DELETE',\n\t\t\t\tpath,\n\t\t\t\thandler as any,\n\t\t\t\thook as LocalHook<any, any>\n\t\t\t)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [OPTIONS]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add(\n\t\t\t\t'OPTIONS',\n\t\t\t\tpath,\n\t\t\t\thandler as any,\n\t\t\t\thook as LocalHook<any, any>\n\t\t\t)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with any method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t * ```\n\t */\n\tall<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tall: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('ALL', path, handler, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\thead: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('HEAD', path, handler, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### trace\n\t * Register handler for path with method [TRACE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .trace('/', () => 'hi')\n\t *     .trace('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\ttrace<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\ttrace: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('TRACE', path, handler, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tPaths extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>,\n\t\tSchema extends TypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\tpaths: Paths,\n\t\thandler: Handler,\n\t\thook?: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\t(MergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t\tconnect: {\n\t\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPaths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: {})\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.add('CONNECT', path, handler, hook as LocalHook<any, any>)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for websocket.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .use(ws())\n\t *     .ws('/ws', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tPaths extends string | string[],\n\t\tSchema extends WSTypedSchema<\n\t\t\tExtract<keyof Instance['meta']['defs'], string>\n\t\t>\n\t>(\n\t\t/**\n\t\t * Path to register websocket to\n\t\t */\n\t\tpaths: Paths,\n\t\toptions: this extends Elysia<any, infer Instance>\n\t\t\t? ElysiaWSOptions<\n\t\t\t\t\t`${BasePath}${Extract<Paths, string>}`,\n\t\t\t\t\tSchema,\n\t\t\t\t\tInstance\n\t\t\t  >\n\t\t\t: never\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Instance['meta'] &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tRecord<\n\t\t\t\t\t\t`${BasePath}${Extract<Paths, string>}`,\n\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tsubscribe: TypedWSRouteToEden<\n\t\t\t\t\t\t\t\t\t\tTyped,\n\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t`${BasePath}${Extract<Paths, string>}`\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: {}\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (!this.wsRouter)\n\t\t\tthrow new Error(\n\t\t\t\t\"Can't find WebSocket. Please register WebSocket plugin first by importing 'elysia/ws'\"\n\t\t\t)\n\n\t\tif (typeof paths === 'string') {\n\t\t\tpaths = [paths] as Paths\n\t\t}\n\t\tfor (const path of paths) {\n\t\t\tthis.wsRouter.add('subscribe', path, options as any)\n\n\t\t\tthis.get(\n\t\t\t\tpath,\n\t\t\t\t// @ts-ignore\n\t\t\t\t(context) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tthis.server?.upgrade(context.request, {\n\t\t\t\t\t\t\theaders:\n\t\t\t\t\t\t\t\ttypeof options.upgrade === 'function'\n\t\t\t\t\t\t\t\t\t? options.upgrade(context as any)\n\t\t\t\t\t\t\t\t\t: options.upgrade,\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t...context,\n\t\t\t\t\t\t\t\tid: Date.now(),\n\t\t\t\t\t\t\t\theaders: context.request.headers.toJSON(),\n\t\t\t\t\t\t\t\tmessage: getSchemaValidator(options?.body, {\n\t\t\t\t\t\t\t\t\tmodels: this.meta.defs\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\ttransformMessage: !options.transform\n\t\t\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t\t\t: Array.isArray(options.transformMessage)\n\t\t\t\t\t\t\t\t\t? options.transformMessage\n\t\t\t\t\t\t\t\t\t: [options.transformMessage]\n\t\t\t\t\t\t\t} as ElysiaWSContext<any>['data']\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\t\treturn\n\n\t\t\t\t\tcontext.set.status = 400\n\n\t\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tbeforeHandle: options.beforeHandle,\n\t\t\t\t\ttransform: options.transform,\n\t\t\t\t\theaders: options?.headers,\n\t\t\t\t\tparams: options?.params,\n\t\t\t\t\tquery: options?.query\n\t\t\t\t} as any\n\t\t\t)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with custom method\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('CUSTOM', '/', () => 'hi')\n\t *     .route('CUSTOM', '/with-hook', () => 'hi', {\n\t *         schema: {\n\t *             response: t.String()\n\t *         }\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>,\n\t\tMethod extends HTTPMethod,\n\t\tPath extends string | string[],\n\t\tHandler extends LocalHandler<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Path, string>}`\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handler,\n\t\t// @ts-ignore\n\t\t{\n\t\t\tconfig,\n\t\t\t...hook\n\t\t}: LocalHook<\n\t\t\tSchema,\n\t\t\tInstance,\n\t\t\t`${BasePath}${Extract<Path, string>}`\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t} = {\n\t\t\tconfig: {\n\t\t\t\tallowMeta: false\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\trequest: Instance['request']\n\t\t\tstore: Instance['store']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: Record<'defs', Instance['meta']['defs']> &\n\t\t\t\tRecord<'exposed', Instance['meta']['exposed']> &\n\t\t\t\tRecord<\n\t\t\t\t\t'schema',\n\t\t\t\t\tPrettify<\n\t\t\t\t\t\tInstance['meta']['schema'] &\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tSchema,\n\t\t\t\t\t\t\t\tInstance['schema']\n\t\t\t\t\t\t\t> extends infer Typed extends TypedSchema\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t[path in `${BasePath}${Extract<\n\t\t\t\t\t\t\t\t\t\tPath,\n\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t>}`]: {\n\t\t\t\t\t\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\t\t\t\t\t\tbody: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['body'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\theaders: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['headers'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\tquery: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['query'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\tparams: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\tTyped['params'],\n\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t\t\t\t\t\t\t\t> extends infer Result\n\t\t\t\t\t\t\t\t\t\t\t\t? Result extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t\t? Result\n\t\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t\t\t\t: Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtractPath<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExtract<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPath,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\tresponse: Typed['response'] extends\n\t\t\t\t\t\t\t\t\t\t\t\t| TSchema\n\t\t\t\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: Typed['response'] extends Record<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTSchema | string\n\t\t\t\t\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[key in keyof Typed['response']]: UnwrapSchema<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTyped['response'][key],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'200': ReturnType<Handler>\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t}\n\t> {\n\t\tif (typeof path === 'string') {\n\t\t\tpath = [path] as Path\n\t\t}\n\t\tfor (const p of path) {\n\t\t\tthis.add(method, p, handler, hook as LocalHook<any, any>, config)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Key extends string | number | symbol, Value>(\n\t\tname: Key,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Reconciliation<Instance['store'], Record<Key, Value>>\n\t\t\terror: Instance['error']\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tstore: NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Reconciliation<Instance['store'], DeepWritable<NewStore>>\n\t\t\terror: Instance['error']\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\tname: string | number | symbol | Record<string, unknown>,\n\t\tvalue?: unknown\n\t) {\n\t\tif (typeof name === 'object') {\n\t\t\tthis.store = mergeDeep(this.store, name)\n\n\t\t\treturn this as any\n\t\t}\n\n\t\tif (!(name in this.store)) {\n\t\t\t// eslint-disable-next-line no-extra-semi\n\t\t\t;(this.store as Record<string | number | symbol, unknown>)[name] =\n\t\t\t\tvalue\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error']\n\t\t\trequest: Reconciliation<Instance['request'], Record<Name, Value>>\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<Decorators extends Record<string, unknown>>(\n\t\tname: Decorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error']\n\t\t\trequest: Reconciliation<\n\t\t\t\tInstance['request'],\n\t\t\t\tDecorators\n\t\t\t>\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(name: string | Record<string, unknown>, value?: unknown) {\n\t\tif (typeof name === 'object') {\n\t\t\tthis.decorators = mergeDeep(this.decorators, name)\n\n\t\t\treturn this as any\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (!(name in this.decorators)) this.decorators[name] = value\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<Returned extends Object = Object>(\n\t\ttransform: (\n\t\t\tcontext: Context<\n\t\t\t\tTypedSchemaToRoute<\n\t\t\t\t\tInstance['schema'],\n\t\t\t\t\tInstance['meta']['defs']\n\t\t\t\t>,\n\t\t\t\tInstance['store']\n\t\t\t> &\n\t\t\t\tInstance['request']\n\t\t) => MaybePromise<Returned> extends { store: any } ? never : Returned\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\terror: Instance['error']\n\t\t\trequest: Instance['request'] & Awaited<Returned>\n\t\t\tschema: Instance['schema']\n\t\t\tmeta: Instance['meta']\n\t\t}\n\t> {\n\t\t// @ts-ignore\n\t\ttransform.$elysia = 'derive'\n\n\t\treturn this.onTransform(transform as any) as any\n\t}\n\n\t/**\n\t * ### schema\n\t * Define type strict validation for request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .schema({\n\t *         response: t.String()\n\t *     })\n\t *     .get('/', () => 'hi')\n\t * ```\n\t */\n\tschema<\n\t\tSchema extends TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t> = TypedSchema<\n\t\t\tExclude<keyof Instance['meta']['defs'], number | symbol>\n\t\t>,\n\t\tNewInstance = Elysia<\n\t\t\tBasePath,\n\t\t\t{\n\t\t\t\trequest: Instance['request']\n\t\t\t\tstore: Instance['store']\n\t\t\t\terror: Instance['error']\n\t\t\t\tschema: MergeSchema<Schema, Instance['schema']>\n\t\t\t\tmeta: Instance['meta']\n\t\t\t}\n\t\t>\n\t>(schema: Schema): NewInstance {\n\t\tconst models = this.meta.defs\n\n\t\tthis.$schema = {\n\t\t\tbody: getSchemaValidator(schema.body, {\n\t\t\t\tmodels\n\t\t\t}),\n\t\t\theaders: getSchemaValidator(schema?.headers, {\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties: true\n\t\t\t}),\n\t\t\tparams: getSchemaValidator(schema?.params, {\n\t\t\t\tmodels\n\t\t\t}),\n\t\t\tquery: getSchemaValidator(schema?.query, {\n\t\t\t\tmodels\n\t\t\t}),\n\t\t\t// @ts-ignore\n\t\t\tresponse: getSchemaValidator(schema?.response, {\n\t\t\t\tmodels\n\t\t\t})\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tcompile() {\n\t\tthis.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this)\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload({\n\t\t\t\t...this.server,\n\t\t\t\tfetch: this.fetch\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> =>\n\t\t(this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\n\tprivate handleError = async (\n\t\trequest: Request,\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError,\n\t\tset: Context['set']\n\t) =>\n\t\t(this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(request, error, set)\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message, {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tif (!Bun) throw new Error('Bun to run')\n\n\t\tthis.compile()\n\n\t\tif (typeof options === 'string') {\n\t\t\toptions = +options.trim()\n\n\t\t\tif (Number.isNaN(options))\n\t\t\t\tthrow new Error('Port must be a numeric value')\n\t\t}\n\n\t\tconst fetch = this.fetch\n\n\t\tconst serve =\n\t\t\ttypeof options === 'object'\n\t\t\t\t? ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\t\t\t\t: ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t...this.config.serve,\n\t\t\t\t\t\tport: options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t  } as Serve)\n\n\t\tif (typeof Bun === 'undefined')\n\t\t\tthrow new Error(\n\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t)\n\n\t\tthis.server = Bun?.serve(serve)\n\n\t\tfor (let i = 0; i < this.event.start.length; i++)\n\t\t\tthis.event.start[i](this as any)\n\n\t\tif (callback) callback(this.server!)\n\n\t\tPromise.all(this.lazyLoadModules).then(() => {\n\t\t\tBun?.gc(true)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(8080)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t */\n\tstop = async () => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tthis.server.stop()\n\n\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\tawait this.event.stop[i](this as any)\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn Promise.all(this.lazyLoadModules)\n\t}\n\n\tmodel<Name extends string, Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema']\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\tRecord<Name, Static<Model>>\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\tmodel<Recorder extends Record<string, TSchema>>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tstore: Instance['store']\n\t\t\trequest: Instance['request']\n\t\t\tschema: Instance['schema']\n\t\t\terror: Instance['error']\n\t\t\tmeta: {\n\t\t\t\tschema: Instance['meta']['schema']\n\t\t\t\tdefs: Reconciliation<\n\t\t\t\t\tInstance['meta']['defs'],\n\t\t\t\t\t{\n\t\t\t\t\t\t[key in keyof Recorder]: Static<Recorder[key]>\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\texposed: Instance['meta']['exposed']\n\t\t\t}\n\t\t}\n\t>\n\n\tmodel(name: string, model?: TSchema) {\n\t\tif (typeof name === 'object')\n\t\t\tObject.entries(name).forEach(([key, value]) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (!(key in this.meta.defs)) this.meta.defs[key] = value\n\t\t\t})\n\t\telse (this.meta.defs as Record<string, TSchema>)[name] = model!\n\n\t\treturn this as any\n\t}\n}\n\nexport { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler'\nexport { Elysia }\nexport { t } from './custom-types'\nexport { ws } from './ws'\n\nexport {\n\tgetSchemaValidator,\n\tmergeDeep,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator\n} from './utils'\n\nexport {\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError\n} from './error'\n\nexport type { Context, PreContext } from './context'\nexport type {\n\tHandler,\n\tRegisteredHook,\n\tBeforeRequestHandler,\n\tVoidRequestHandler,\n\tTypedRoute,\n\tOverwritableTypeRoute,\n\tElysiaInstance,\n\tElysiaConfig,\n\tHTTPMethod,\n\tComposedHandler,\n\tInternalRoute,\n\tBodyParser,\n\tErrorHandler,\n\tErrorCode,\n\tTypedSchema,\n\tLocalHook,\n\tLocalHandler,\n\tLifeCycle,\n\tLifeCycleEvent,\n\tAfterRequestHandler,\n\tHookHandler,\n\tTypedSchemaToRoute,\n\tUnwrapSchema,\n\tLifeCycleStore,\n\tVoidLifeCycle,\n\tSchemaValidator,\n\tExtractPath,\n\tIsPathParameter,\n\tIsAny,\n\tIsNever,\n\tUnknownFallback,\n\tWithArray,\n\tObjectValues,\n\tMaybePromise,\n\tMergeIfNotNull,\n\tElysiaDefaultMeta,\n\tAnyTypedSchema,\n\tDeepMergeTwoTypes\n} from './types'\n"
  ],
  "mappings": "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AAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI/C,EAAG,EAAG,EAAG,EAAG,EAAG,E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",
  "debugId": "0E021689109CFB3064756e2164756e21",
  "names": []
}