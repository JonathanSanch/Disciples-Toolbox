/// <reference types="bun-types" />
import type { Serve, Server } from 'bun';
import type { Context } from './context';
import type { ElysiaWSOptions, WSTypedSchema } from './ws';
import type { Handler, VoidRequestHandler, TypedRoute, ElysiaInstance, ElysiaConfig, HTTPMethod, InternalRoute, BodyParser, ErrorHandler, TypedSchema, LocalHook, LocalHandler, LifeCycle, LifeCycleEvent, LifeCycleStore, VoidLifeCycle, AfterRequestHandler, IsAny, OverwritableTypeRoute, MergeSchema, ListenCallback, NoReturnHandler, MaybePromise, Prettify, TypedWSRouteToEden, UnwrapSchema, ExtractPath, TypedSchemaToRoute, DeepWritable, Reconciliation, BeforeRequestHandler, ElysiaDefaultMeta } from './types';
import type { Static, TSchema } from '@sinclair/typebox';
export default class Elysia<BasePath extends string = '', Instance extends ElysiaInstance<{
    store?: Record<string, unknown>;
    request?: Record<string, unknown>;
    error?: Record<string, Error>;
    schema?: TypedSchema<any>;
    meta?: ElysiaDefaultMeta;
}> = {
    store: {};
    request: {};
    schema: {};
    error: {};
    meta: {
        schema: {};
        defs: {};
        exposed: {};
    };
}> {
    config: ElysiaConfig<BasePath>;
    private dependencies;
    store: Instance['store'];
    meta: Instance['meta'];
    private decorators;
    event: LifeCycleStore<Instance>;
    server: Server | null;
    private $schema;
    private error;
    private router;
    routes: InternalRoute<Instance>[];
    private staticRouter;
    private wsRouter;
    private dynamicRouter;
    private lazyLoadModules;
    path: BasePath;
    constructor(config?: Partial<ElysiaConfig<BasePath>>);
    private add;
    onStart(handler: VoidLifeCycle<Instance>): this;
    onRequest<Route extends OverwritableTypeRoute = TypedRoute>(handler: BeforeRequestHandler<Route, Instance>): this;
    onParse(parser: BodyParser<any, Instance>): this;
    onTransform<Route extends OverwritableTypeRoute = TypedRoute>(handler: NoReturnHandler<Route, Instance>): this;
    onBeforeHandle<Route extends OverwritableTypeRoute = TypedRoute>(handler: Handler<Route, Instance>): this;
    onAfterHandle<Route extends OverwritableTypeRoute = TypedRoute>(handler: AfterRequestHandler<Route, Instance>): this;
    onResponse<Route extends OverwritableTypeRoute = TypedRoute>(handler: VoidRequestHandler<Route, Instance>): this;
    addError<const Errors extends Record<string, {
        prototype: Error;
    }>>(errors: Errors): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'] & {
            [K in NonNullable<keyof Errors>]: Errors[K] extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : Errors[K];
        };
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    addError<Name extends string, const CustomError extends {
        prototype: Error;
    }>(name: Name, errors: CustomError): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'] & {
            [name in Name]: CustomError extends {
                prototype: infer LiteralError extends Error;
            } ? LiteralError : CustomError;
        };
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    onError(handler: ErrorHandler<Instance['error']>): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    onStop(handler: VoidLifeCycle<Instance>): this;
    on<Event extends LifeCycleEvent = LifeCycleEvent>(type: Event, handler: LifeCycle<Instance>[Event]): this;
    group<NewElysia extends Elysia<any, any> = Elysia<any, any>, Prefix extends string = string>(prefix: Prefix, run: (group: Elysia<`${BasePath}${Prefix}`, {
        error: Instance['error'];
        request: Instance['request'];
        store: Instance['store'] & ElysiaInstance['store'];
        schema: Instance['schema'];
        meta: {
            schema: Instance['meta']['schema'];
            defs: Instance['meta']['defs'];
            exposed: {};
        };
    }>) => NewElysia): NewElysia extends Elysia<`${BasePath}${Prefix}`, infer NewInstance> ? Elysia<BasePath, {
        error: Instance['error'];
        request: Instance['request'];
        schema: Instance['schema'];
        store: Instance['store'];
        meta: Instance['meta'] & NewInstance['meta'];
    }> : this;
    group<Schema extends TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>>, NewElysia extends Elysia<any, any> = Elysia<any, any>, Prefix extends string = string>(prefix: Prefix, schema: LocalHook<Schema, Instance, `${BasePath}${Prefix}`>, run: (group: Elysia<`${BasePath}${Prefix}`, {
        error: Instance['error'];
        request: Instance['request'];
        store: Instance['store'] & ElysiaInstance['store'];
        schema: {
            body: undefined extends Schema['body'] ? Instance['schema']['body'] : Schema['body'];
            headers: undefined extends Schema['headers'] ? Instance['schema']['headers'] : Schema['headers'];
            query: undefined extends Schema['query'] ? Instance['schema']['query'] : Schema['query'];
            params: undefined extends Schema['params'] ? Instance['schema']['params'] : Schema['params'];
            response: undefined extends Schema['response'] ? Instance['schema']['response'] : Schema['response'];
        };
        meta: {
            schema: Instance['meta']['schema'];
            defs: Instance['meta']['defs'];
            exposed: {};
        };
    }>) => NewElysia): NewElysia extends Elysia<`${BasePath}${Prefix}`, infer NewInstance> ? Elysia<BasePath, {
        error: Instance['error'];
        request: Instance['request'];
        schema: Instance['schema'];
        store: Instance['store'];
        meta: Instance['meta'] & (Omit<NewInstance['meta'], 'schema'> & Record<'schema', {
            [Path in keyof NewInstance['meta']['schema']]: NewInstance['meta']['schema'][Path];
        }>);
    }> : this;
    guard<Schema extends TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>>>(hook: LocalHook<Schema, Instance>): Elysia<any, {
        error: Instance['error'];
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Instance['meta'] & Record<'schema', {
            [key in keyof Schema]: Schema[key];
        }>;
    }>;
    guard<Schema extends TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>>, NewElysia extends Elysia<any, any> = Elysia<any, any>>(hook: LocalHook<Schema, Instance>, run: (group: Elysia<BasePath, {
        error: Instance['error'];
        request: Instance['request'];
        store: Instance['store'];
        schema: {
            body: undefined extends Schema['body'] ? Instance['schema']['body'] : Schema['body'];
            headers: undefined extends Schema['headers'] ? Instance['schema']['headers'] : Schema['headers'];
            query: undefined extends Schema['query'] ? Instance['schema']['query'] : Schema['query'];
            params: undefined extends Schema['params'] ? Instance['schema']['params'] : Schema['params'];
            response: undefined extends Schema['response'] ? Instance['schema']['response'] : Schema['response'];
        };
        meta: Instance['meta'];
    }>) => NewElysia): NewElysia extends Elysia<any, infer NewInstance> ? Elysia<BasePath, {
        error: Instance['error'];
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        meta: Instance['meta'] & Record<'schema', {
            [key in keyof NewInstance['meta']['schema']]: NewInstance['meta']['schema'][key];
        }>;
    }> : this;
    use<NewInstance extends ElysiaInstance, Params extends Elysia = Elysia<any, any>>(plugin: MaybePromise<(app: Params extends Elysia<any, infer ParamsInstance> ? IsAny<ParamsInstance> extends true ? this : any : Params) => MaybePromise<Elysia<any, NewInstance>>>): Elysia<BasePath, {
        error: Instance['error'] & NewInstance['error'];
        request: Reconciliation<Instance['request'], NewInstance['request']>;
        store: Reconciliation<Instance['store'], NewInstance['store']>;
        schema: Instance['schema'] & NewInstance['schema'];
        meta: {
            schema: Instance['meta']['schema'] & {
                [Path in keyof NewInstance['meta']['schema'] as Path extends string ? `${BasePath}${Path}` : Path]: NewInstance['meta']['schema'][Path];
            };
            defs: Reconciliation<Instance['meta']['defs'], NewInstance['meta']['defs']>;
            exposed: Instance['meta']['exposed'] & NewInstance['meta']['exposed'];
        };
    }>;
    use<NewInstance extends ElysiaInstance>(instance: Elysia<any, NewInstance>): Elysia<BasePath, {
        error: Instance['error'] & NewInstance['error'];
        request: Reconciliation<Instance['request'], NewInstance['request']>;
        store: Reconciliation<Instance['store'], NewInstance['store']>;
        schema: Instance['schema'] & NewInstance['schema'];
        meta: {
            schema: Instance['meta']['schema'] & {
                [Path in keyof NewInstance['meta']['schema'] as Path extends string ? `${BasePath}${Path}` : Path]: NewInstance['meta']['schema'][Path];
            };
            defs: Reconciliation<Instance['meta']['defs'], NewInstance['meta']['defs']>;
            exposed: Instance['meta']['exposed'] & NewInstance['meta']['exposed'];
        };
    }>;
    use<LazyLoadElysia extends ElysiaInstance>(plugin: Promise<{
        default: (elysia: Elysia<any, any>) => MaybePromise<Elysia<any, LazyLoadElysia>>;
    }>): Elysia<BasePath, {
        error: Instance['error'] & LazyLoadElysia['error'];
        request: Reconciliation<Instance['request'], LazyLoadElysia['request']>;
        store: Reconciliation<Instance['store'], LazyLoadElysia['store']>;
        schema: Instance['schema'] & LazyLoadElysia['schema'];
        meta: {
            schema: Instance['meta']['schema'] & {
                [Path in keyof LazyLoadElysia['meta']['schema'] as Path extends string ? `${BasePath}${Path}` : Path]: LazyLoadElysia['meta']['schema'][Path];
            };
            defs: Reconciliation<Instance['meta']['defs'], LazyLoadElysia['meta']['defs']>;
            exposed: Instance['meta']['exposed'] & LazyLoadElysia['meta']['exposed'];
        };
    }>;
    use<LazyLoadElysia extends ElysiaInstance>(plugin: Promise<{
        default: (elysia: Elysia<any, any>) => Elysia<any, LazyLoadElysia>;
    }>): Elysia<BasePath, {
        error: Instance['error'] & LazyLoadElysia['error'];
        request: Reconciliation<Instance['request'], LazyLoadElysia['request']>;
        store: Reconciliation<Instance['store'], LazyLoadElysia['store']>;
        schema: Instance['schema'] & LazyLoadElysia['schema'];
        meta: {
            schema: Instance['meta']['schema'] & {
                [Path in keyof LazyLoadElysia['meta']['schema'] as Path extends string ? `${BasePath}${Path}` : Path]: LazyLoadElysia['meta']['schema'][Path];
            };
            defs: Reconciliation<Instance['meta']['defs'], LazyLoadElysia['meta']['defs']>;
            exposed: Instance['meta']['exposed'] & LazyLoadElysia['meta']['exposed'];
        };
    }>;
    mount(handle: (request: Request) => MaybePromise<Response>): this;
    mount(path: string, handle: (request: Request) => MaybePromise<Response>): this;
    get<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: {
            defs: Instance['meta']['defs'];
            exposed: Instance['meta']['exposed'];
            schema: Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
                [path in `${BasePath}${Extract<Paths, string>}`]: {
                    get: {
                        body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                        headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                        query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                        params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                        response: Typed['response'] extends TSchema | string ? {
                            '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                        } : Typed['response'] extends Record<string, TSchema | string> ? {
                            [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                        } : {
                            '200': ReturnType<Handler>;
                        };
                    };
                };
            } : {})>;
        };
    }>;
    post<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                post: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    put<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                put: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    patch<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                patch: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    delete<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                delete: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    options<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                options: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    all<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                all: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    head<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                head: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    trace<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                trace: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    connect<Paths extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>, Schema extends TypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, handler: Handler, hook?: LocalHook<Schema, Instance, `${BasePath}${Extract<Paths, string>}`>): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & (MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Paths, string>}`]: {
                connect: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Paths, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : {})>>;
    }>;
    ws<Paths extends string | string[], Schema extends WSTypedSchema<Extract<keyof Instance['meta']['defs'], string>>>(paths: Paths, options: this extends Elysia<any, infer Instance> ? ElysiaWSOptions<`${BasePath}${Extract<Paths, string>}`, Schema, Instance> : never): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Instance['meta'] & Record<'schema', Record<`${BasePath}${Extract<Paths, string>}`, MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            subscribe: TypedWSRouteToEden<Typed, Instance['meta']['defs'], `${BasePath}${Extract<Paths, string>}`>;
        } : {}>>;
    }>;
    route<Schema extends TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>>, Method extends HTTPMethod, Path extends string | string[], Handler extends LocalHandler<Schema, Instance, `${BasePath}${Extract<Path, string>}`>>(method: Method, path: Path, handler: Handler, { config, ...hook }?: LocalHook<Schema, Instance, `${BasePath}${Extract<Path, string>}`> & {
        config: {
            allowMeta?: boolean;
        };
    }): Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: Record<'defs', Instance['meta']['defs']> & Record<'exposed', Instance['meta']['exposed']> & Record<'schema', Prettify<Instance['meta']['schema'] & MergeSchema<Schema, Instance['schema']> extends infer Typed extends TypedSchema ? {
            [path in `${BasePath}${Extract<Path, string>}`]: {
                [method in Method]: {
                    body: UnwrapSchema<Typed['body'], Instance['meta']['defs']>;
                    headers: UnwrapSchema<Typed['headers'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    query: UnwrapSchema<Typed['query'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : undefined;
                    params: UnwrapSchema<Typed['params'], Instance['meta']['defs']> extends infer Result ? Result extends Record<string, any> ? Result : undefined : Record<ExtractPath<Extract<Path, string>>, string>;
                    response: Typed['response'] extends TSchema | string ? {
                        '200': UnwrapSchema<Typed['response'], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : Typed['response'] extends Record<string, TSchema | string> ? {
                        [key in keyof Typed['response']]: UnwrapSchema<Typed['response'][key], Instance['meta']['defs'], ReturnType<Handler>>;
                    } : {
                        '200': ReturnType<Handler>;
                    };
                };
            };
        } : never>>;
    }>;
    state<Key extends string | number | symbol, Value>(name: Key, value: Value): Elysia<BasePath, {
        store: Reconciliation<Instance['store'], Record<Key, Value>>;
        error: Instance['error'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    state<NewStore extends Record<string, unknown>>(store: NewStore): Elysia<BasePath, {
        store: Reconciliation<Instance['store'], DeepWritable<NewStore>>;
        error: Instance['error'];
        request: Instance['request'];
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    decorate<const Name extends string, const Value>(name: Name, value: Value): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'];
        request: Reconciliation<Instance['request'], Record<Name, Value>>;
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    decorate<Decorators extends Record<string, unknown>>(name: Decorators): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'];
        request: Reconciliation<Instance['request'], Decorators>;
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    derive<Returned extends Object = Object>(transform: (context: Context<TypedSchemaToRoute<Instance['schema'], Instance['meta']['defs']>, Instance['store']> & Instance['request']) => MaybePromise<Returned> extends {
        store: any;
    } ? never : Returned): Elysia<BasePath, {
        store: Instance['store'];
        error: Instance['error'];
        request: Instance['request'] & Awaited<Returned>;
        schema: Instance['schema'];
        meta: Instance['meta'];
    }>;
    schema<Schema extends TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>> = TypedSchema<Exclude<keyof Instance['meta']['defs'], number | symbol>>, NewInstance = Elysia<BasePath, {
        request: Instance['request'];
        store: Instance['store'];
        error: Instance['error'];
        schema: MergeSchema<Schema, Instance['schema']>;
        meta: Instance['meta'];
    }>>(schema: Schema): NewInstance;
    compile(): this;
    handle: (request: Request) => Promise<Response>;
    fetch: (request: Request) => MaybePromise<Response>;
    private handleError;
    private outerErrorHandler;
    listen: (options: string | number | Partial<Serve>, callback?: ListenCallback) => this;
    stop: () => Promise<void>;
    get modules(): Promise<Elysia<any, any>[]>;
    model<Name extends string, Model extends TSchema>(name: Name, model: Model): Elysia<BasePath, {
        store: Instance['store'];
        request: Instance['request'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: {
            schema: Instance['meta']['schema'];
            defs: Reconciliation<Instance['meta']['defs'], Record<Name, Static<Model>>>;
            exposed: Instance['meta']['exposed'];
        };
    }>;
    model<Recorder extends Record<string, TSchema>>(record: Recorder): Elysia<BasePath, {
        store: Instance['store'];
        request: Instance['request'];
        schema: Instance['schema'];
        error: Instance['error'];
        meta: {
            schema: Instance['meta']['schema'];
            defs: Reconciliation<Instance['meta']['defs'], {
                [key in keyof Recorder]: Static<Recorder[key]>;
            }>;
            exposed: Instance['meta']['exposed'];
        };
    }>;
}
export { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler';
export { Elysia };
export { t } from './custom-types';
export { ws } from './ws';
export { getSchemaValidator, mergeDeep, mergeHook, mergeObjectArray, getResponseSchemaValidator } from './utils';
export { ParseError, NotFoundError, ValidationError, InternalServerError } from './error';
export type { Context, PreContext } from './context';
export type { Handler, RegisteredHook, BeforeRequestHandler, VoidRequestHandler, TypedRoute, OverwritableTypeRoute, ElysiaInstance, ElysiaConfig, HTTPMethod, ComposedHandler, InternalRoute, BodyParser, ErrorHandler, ErrorCode, TypedSchema, LocalHook, LocalHandler, LifeCycle, LifeCycleEvent, AfterRequestHandler, HookHandler, TypedSchemaToRoute, UnwrapSchema, LifeCycleStore, VoidLifeCycle, SchemaValidator, ExtractPath, IsPathParameter, IsAny, IsNever, UnknownFallback, WithArray, ObjectValues, MaybePromise, MergeIfNotNull, ElysiaDefaultMeta, AnyTypedSchema, DeepMergeTwoTypes } from './types';
