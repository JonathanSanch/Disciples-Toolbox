"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalServerError = exports.ValidationError = exports.NotFoundError = exports.ParseError = exports.getResponseSchemaValidator = exports.mergeObjectArray = exports.mergeHook = exports.mergeDeep = exports.getSchemaValidator = exports.ws = exports.t = exports.Elysia = exports.mapEarlyResponse = exports.mapCompactResponse = exports.mapResponse = void 0;
const memoirist_1 = require("memoirist");
const utils_1 = require("./utils");
const compose_1 = require("./compose");
const ws_1 = require("./ws");
const error_1 = require("./error");
const dynamic_handle_1 = require("./dynamic-handle");
class Elysia {
    constructor(config) {
        this.dependencies = {};
        this.store = {};
        this.meta = {
            schema: Object.create(null),
            defs: Object.create(null),
            exposed: Object.create(null)
        };
        this.decorators = {};
        this.event = {
            start: [],
            request: [],
            parse: [],
            transform: [],
            beforeHandle: [],
            afterHandle: [],
            onResponse: [],
            error: [],
            stop: []
        };
        this.server = null;
        this.$schema = null;
        this.error = {};
        this.router = new memoirist_1.Memoirist();
        this.routes = [];
        this.staticRouter = {
            handlers: [],
            variables: '',
            map: {},
            all: ''
        };
        this.dynamicRouter = new memoirist_1.Memoirist();
        this.lazyLoadModules = [];
        this.path = '';
        this.handle = async (request) => this.fetch(request);
        this.fetch = (request) => (this.fetch = this.config.aot
            ? (0, compose_1.composeGeneralHandler)(this)
            : (0, dynamic_handle_1.createDynamicHandler)(this))(request);
        this.handleError = async (request, error, set) => (this.handleError = this.config.aot
            ? (0, compose_1.composeErrorHandler)(this)
            : (0, dynamic_handle_1.createDynamicErrorHandler)(this))(request, error, set);
        this.outerErrorHandler = (error) => new Response(error.message, {
            status: error?.status ?? 500
        });
        this.listen = (options, callback) => {
            if (!Bun)
                throw new Error('Bun to run');
            this.compile();
            if (typeof options === 'string') {
                options = +options.trim();
                if (Number.isNaN(options))
                    throw new Error('Port must be a numeric value');
            }
            const fetch = this.fetch;
            const serve = typeof options === 'object'
                ? {
                    development: !error_1.isProduction,
                    ...this.config.serve,
                    ...options,
                    fetch,
                    error: this.outerErrorHandler
                }
                : {
                    development: !error_1.isProduction,
                    ...this.config.serve,
                    port: options,
                    fetch,
                    error: this.outerErrorHandler
                };
            if (typeof Bun === 'undefined')
                throw new Error('.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch');
            this.server = Bun?.serve(serve);
            for (let i = 0; i < this.event.start.length; i++)
                this.event.start[i](this);
            if (callback)
                callback(this.server);
            Promise.all(this.lazyLoadModules).then(() => {
                Bun?.gc(true);
            });
            return this;
        };
        this.stop = async () => {
            if (!this.server)
                throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
            this.server.stop();
            for (let i = 0; i < this.event.stop.length; i++)
                await this.event.stop[i](this);
        };
        this.config = {
            forceErrorEncapsulation: false,
            prefix: '',
            aot: true,
            strictPath: false,
            scoped: false,
            ...config,
            seed: config?.seed === undefined ? '' : config?.seed
        };
    }
    add(method, path, handler, hook, { allowMeta = false, skipPrefix = false } = {
        allowMeta: false,
        skipPrefix: false
    }) {
        path =
            path === '' ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
        if (this.config.prefix && !skipPrefix)
            path = this.config.prefix + path;
        const defs = this.meta.defs;
        if (hook?.type)
            switch (hook.type) {
                case 'text':
                    hook.type = 'text/plain';
                    break;
                case 'json':
                    hook.type = 'application/json';
                    break;
                case 'formdata':
                    hook.type = 'multipart/form-data';
                    break;
                case 'urlencoded':
                    hook.type = 'application/x-www-form-urlencoded';
                    break;
                case 'arrayBuffer':
                    hook.type = 'application/octet-stream';
                    break;
                default:
                    break;
            }
        const validator = {
            body: (0, utils_1.getSchemaValidator)(hook?.body ?? this.$schema?.body, {
                dynamic: !this.config.aot,
                models: defs
            }),
            headers: (0, utils_1.getSchemaValidator)(hook?.headers ?? this.$schema?.headers, {
                dynamic: !this.config.aot,
                models: defs,
                additionalProperties: true
            }),
            params: (0, utils_1.getSchemaValidator)(hook?.params ?? this.$schema?.params, {
                dynamic: !this.config.aot,
                models: defs
            }),
            query: (0, utils_1.getSchemaValidator)(hook?.query ?? this.$schema?.query, {
                dynamic: !this.config.aot,
                models: defs
            }),
            response: (0, utils_1.getResponseSchemaValidator)(hook?.response ?? this.$schema?.response, {
                dynamic: !this.config.aot,
                models: defs
            })
        };
        const hooks = (0, utils_1.mergeHook)(this.event, hook);
        const loosePath = path.endsWith('/')
            ? path.slice(0, path.length - 1)
            : path + '/';
        if (this.config.aot === false) {
            this.dynamicRouter.add(method, path, {
                validator,
                hooks,
                content: hook?.type,
                handle: handler
            });
            if (this.config.strictPath === false) {
                this.dynamicRouter.add(method, loosePath, {
                    validator,
                    hooks,
                    content: hook?.type,
                    handle: handler
                });
            }
            this.routes.push({
                method,
                path,
                composed: null,
                handler,
                hooks
            });
            return;
        }
        const mainHandler = (0, compose_1.composeHandler)({
            path,
            method,
            hooks,
            validator,
            handler,
            handleError: this.handleError,
            meta: allowMeta ? this.meta : undefined,
            onRequest: this.event.request,
            config: this.config
        });
        this.routes.push({
            method,
            path,
            composed: mainHandler,
            handler,
            hooks
        });
        if (path.indexOf(':') === -1 && path.indexOf('*') === -1) {
            const index = this.staticRouter.handlers.length;
            this.staticRouter.handlers.push(mainHandler);
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]\n`;
            if (!this.staticRouter.map[path])
                this.staticRouter.map[path] = {
                    code: ''
                };
            if (method === 'ALL')
                this.staticRouter.map[path].all = `default: return st${index}(ctx)\n`;
            else
                this.staticRouter.map[path].code += `case '${method}': return st${index}(ctx)\n`;
            if (!this.config.strictPath) {
                if (!this.staticRouter.map[loosePath])
                    this.staticRouter.map[loosePath] = {
                        code: ''
                    };
                if (method === 'ALL')
                    this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)\n`;
                else
                    this.staticRouter.map[loosePath].code += `case '${method}': return st${index}(ctx)\n`;
            }
        }
        else {
            this.router.add(method, path, mainHandler);
            if (!this.config.strictPath)
                this.router.add(method, path.endsWith('/')
                    ? path.slice(0, path.length - 1)
                    : path + '/', mainHandler);
        }
    }
    onStart(handler) {
        this.on('start', handler);
        return this;
    }
    onRequest(handler) {
        this.on('request', handler);
        return this;
    }
    onParse(parser) {
        this.on('parse', parser);
        return this;
    }
    onTransform(handler) {
        this.on('transform', handler);
        return this;
    }
    onBeforeHandle(handler) {
        this.on('beforeHandle', handler);
        return this;
    }
    onAfterHandle(handler) {
        this.on('afterHandle', handler);
        return this;
    }
    onResponse(handler) {
        this.on('response', handler);
        return this;
    }
    addError(name, error) {
        if (typeof name === 'string' && error) {
            error.prototype[error_1.ERROR_CODE] = name;
            return this;
        }
        for (const [code, error] of Object.entries(name))
            error.prototype[error_1.ERROR_CODE] = code;
        return this;
    }
    onError(handler) {
        this.on('error', handler);
        return this;
    }
    onStop(handler) {
        this.on('stop', handler);
        return this;
    }
    on(type, handler) {
        handler = (0, utils_1.asGlobal)(handler);
        switch (type) {
            case 'start':
                this.event.start.push(handler);
                break;
            case 'request':
                this.event.request.push(handler);
                break;
            case 'response':
                this.event.onResponse.push(handler);
                break;
            case 'parse':
                this.event.parse.splice(this.event.parse.length - 1, 0, handler);
                break;
            case 'transform':
                this.event.transform.push(handler);
                break;
            case 'beforeHandle':
                this.event.beforeHandle.push(handler);
                break;
            case 'afterHandle':
                this.event.afterHandle.push(handler);
                break;
            case 'error':
                this.event.error.push(handler);
                break;
            case 'stop':
                this.event.stop.push(handler);
                break;
        }
        return this;
    }
    group(prefix, schemaOrRun, run) {
        const instance = new Elysia({
            ...this.config,
            prefix: ''
        });
        instance.store = this.store;
        if (this.wsRouter)
            instance.use((0, ws_1.ws)());
        const isSchema = typeof schemaOrRun === 'object';
        const sandbox = (isSchema ? run : schemaOrRun)(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        if (sandbox.event.onResponse.length)
            this.event.onResponse = [
                ...this.event.onResponse,
                ...sandbox.event.onResponse
            ];
        this.model(sandbox.meta.defs);
        Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
            path = this.config.prefix + prefix + path;
            if (isSchema) {
                const hook = schemaOrRun;
                const localHook = hooks;
                const hasWsRoute = instance.wsRouter?.find('subscribe', path);
                if (hasWsRoute) {
                    const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                    if (!wsRoute)
                        return;
                    return this.ws(path, wsRoute[2]);
                }
                this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                    ...localHook,
                    error: !localHook.error
                        ? sandbox.event.error
                        : Array.isArray(localHook.error)
                            ? [...localHook.error, ...sandbox.event.error]
                            : [localHook.error, ...sandbox.event.error]
                }));
            }
            else {
                const hasWsRoute = instance.wsRouter?.find('subscribe', path);
                if (hasWsRoute) {
                    const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                    if (!wsRoute)
                        return;
                    return this.ws(path, wsRoute[2]);
                }
                this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                    error: sandbox.event.error
                }), {
                    skipPrefix: true
                });
            }
        });
        if (instance.wsRouter && this.wsRouter)
            instance.wsRouter.history.forEach(([method, path, handler]) => {
                path = this.config.prefix + prefix + path;
                if (path === '/')
                    this.wsRouter?.add(method, prefix, handler);
                else
                    this.wsRouter?.add(method, `${prefix}${path}`, handler);
            });
        return this;
    }
    guard(hook, run) {
        if (!run) {
            this.event = (0, utils_1.mergeLifeCycle)(this.event, hook);
            this.$schema = {
                body: hook.body,
                headers: hook.headers,
                params: hook.params,
                query: hook.query,
                response: hook.response
            };
            return this;
        }
        const instance = new Elysia();
        instance.store = this.store;
        if (this.wsRouter)
            instance.use((0, ws_1.ws)());
        const sandbox = run(instance);
        this.decorators = (0, utils_1.mergeDeep)(this.decorators, instance.decorators);
        if (sandbox.event.request.length)
            this.event.request = [
                ...this.event.request,
                ...sandbox.event.request
            ];
        if (sandbox.event.onResponse.length)
            this.event.onResponse = [
                ...this.event.onResponse,
                ...sandbox.event.onResponse
            ];
        this.model(sandbox.meta.defs);
        Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
            const hasWsRoute = instance.wsRouter?.find('subscribe', path);
            if (hasWsRoute) {
                const wsRoute = instance.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                if (!wsRoute)
                    return;
                return this.ws(path, wsRoute[2]);
            }
            this.add(method, path, handler, (0, utils_1.mergeHook)(hook, {
                ...localHook,
                error: !localHook.error
                    ? sandbox.event.error
                    : Array.isArray(localHook.error)
                        ? [...localHook.error, ...sandbox.event.error]
                        : [localHook.error, ...sandbox.event.error]
            }));
        });
        if (instance.wsRouter && this.wsRouter)
            instance.wsRouter.history.forEach(([method, path, handler]) => {
                this.wsRouter?.add(method, path, handler);
            });
        return this;
    }
    use(plugin) {
        const register = (plugin) => {
            if (typeof plugin === 'function') {
                const instance = plugin(this);
                if (instance instanceof Promise) {
                    this.lazyLoadModules.push(instance.then((x) => x.compile()));
                    return this;
                }
                return instance;
            }
            const isScoped = plugin.config.scoped;
            if (!isScoped) {
                this.decorators = (0, utils_1.mergeDeep)(this.decorators, plugin.decorators);
                this.state(plugin.store);
                this.model(plugin.meta.defs);
                this.addError(plugin.error);
            }
            const { config: { name, seed } } = plugin;
            Object.values(plugin.routes).forEach(({ method, path, handler, hooks }) => {
                const hasWsRoute = plugin.wsRouter?.find('subscribe', path);
                if (hasWsRoute) {
                    const wsRoute = plugin.wsRouter.history.find(([_, wsPath]) => path === wsPath);
                    if (!wsRoute)
                        return;
                    return this.ws(path, wsRoute[2]);
                }
                this.add(method, path, handler, (0, utils_1.mergeHook)(hooks, {
                    error: plugin.event.error
                }));
            });
            if (!isScoped)
                if (name) {
                    if (!(name in this.dependencies))
                        this.dependencies[name] = [];
                    const current = seed !== undefined
                        ? (0, utils_1.checksum)(name + JSON.stringify(seed))
                        : 0;
                    if (this.dependencies[name].some((checksum) => current === checksum))
                        return this;
                    this.dependencies[name].push(current);
                    this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event), current);
                }
                else
                    this.event = (0, utils_1.mergeLifeCycle)(this.event, (0, utils_1.filterGlobalHook)(plugin.event));
            return this;
        };
        if (plugin instanceof Promise) {
            this.lazyLoadModules.push(plugin
                .then((plugin) => {
                if (typeof plugin === 'function')
                    return plugin(this);
                if (typeof plugin.default === 'function')
                    return plugin.default(this);
                return register(plugin.default);
            })
                .then((x) => x.compile()));
            return this;
        }
        else
            return register(plugin);
        return this;
    }
    mount(path, handle) {
        if (typeof path === 'function' || path.length === 0 || path === '/') {
            const run = typeof path === 'function' ? path : handle;
            const handler = async ({ request, path }) => run(new Request('http://a.cc' + path || '/', request));
            this.all('/', handler, {
                type: 'none'
            });
            this.all('/*', handler, {
                type: 'none'
            });
            return this;
        }
        const length = path.length;
        const handler = async ({ request, path }) => handle(new Request('http://a.cc' + path.slice(length) || '/', request));
        this.all(path, handler, {
            type: 'none'
        });
        this.all(path + (path.endsWith('/') ? '*' : '/*'), handler, {
            type: 'none'
        });
        return this;
    }
    get(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('GET', path, handler, hook);
        }
        return this;
    }
    post(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('POST', path, handler, hook);
        }
        return this;
    }
    put(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('PUT', path, handler, hook);
        }
        return this;
    }
    patch(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('PATCH', path, handler, hook);
        }
        return this;
    }
    delete(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('DELETE', path, handler, hook);
        }
        return this;
    }
    options(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('OPTIONS', path, handler, hook);
        }
        return this;
    }
    all(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('ALL', path, handler, hook);
        }
        return this;
    }
    head(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('HEAD', path, handler, hook);
        }
        return this;
    }
    trace(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('TRACE', path, handler, hook);
        }
        return this;
    }
    connect(paths, handler, hook) {
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.add('CONNECT', path, handler, hook);
        }
        return this;
    }
    ws(paths, options) {
        if (!this.wsRouter)
            throw new Error("Can't find WebSocket. Please register WebSocket plugin first by importing 'elysia/ws'");
        if (typeof paths === 'string') {
            paths = [paths];
        }
        for (const path of paths) {
            this.wsRouter.add('subscribe', path, options);
            this.get(path, (context) => {
                if (this.server?.upgrade(context.request, {
                    headers: typeof options.upgrade === 'function'
                        ? options.upgrade(context)
                        : options.upgrade,
                    data: {
                        ...context,
                        id: Date.now(),
                        headers: context.request.headers.toJSON(),
                        message: (0, utils_1.getSchemaValidator)(options?.body, {
                            models: this.meta.defs
                        }),
                        transformMessage: !options.transform
                            ? []
                            : Array.isArray(options.transformMessage)
                                ? options.transformMessage
                                : [options.transformMessage]
                    }
                }))
                    return;
                context.set.status = 400;
                return 'Expected a websocket connection';
            }, {
                beforeHandle: options.beforeHandle,
                transform: options.transform,
                headers: options?.headers,
                params: options?.params,
                query: options?.query
            });
        }
        return this;
    }
    route(method, path, handler, { config, ...hook } = {
        config: {
            allowMeta: false
        }
    }) {
        if (typeof path === 'string') {
            path = [path];
        }
        for (const p of path) {
            this.add(method, p, handler, hook, config);
        }
        return this;
    }
    state(name, value) {
        if (typeof name === 'object') {
            this.store = (0, utils_1.mergeDeep)(this.store, name);
            return this;
        }
        if (!(name in this.store)) {
            ;
            this.store[name] =
                value;
        }
        return this;
    }
    decorate(name, value) {
        if (typeof name === 'object') {
            this.decorators = (0, utils_1.mergeDeep)(this.decorators, name);
            return this;
        }
        if (!(name in this.decorators))
            this.decorators[name] = value;
        return this;
    }
    derive(transform) {
        transform.$elysia = 'derive';
        return this.onTransform(transform);
    }
    schema(schema) {
        const models = this.meta.defs;
        this.$schema = {
            body: (0, utils_1.getSchemaValidator)(schema.body, {
                models
            }),
            headers: (0, utils_1.getSchemaValidator)(schema?.headers, {
                models,
                additionalProperties: true
            }),
            params: (0, utils_1.getSchemaValidator)(schema?.params, {
                models
            }),
            query: (0, utils_1.getSchemaValidator)(schema?.query, {
                models
            }),
            response: (0, utils_1.getSchemaValidator)(schema?.response, {
                models
            })
        };
        return this;
    }
    compile() {
        this.fetch = this.config.aot
            ? (0, compose_1.composeGeneralHandler)(this)
            : (0, dynamic_handle_1.createDynamicHandler)(this);
        if (typeof this.server?.reload === 'function')
            this.server.reload({
                ...this.server,
                fetch: this.fetch
            });
        return this;
    }
    get modules() {
        return Promise.all(this.lazyLoadModules);
    }
    model(name, model) {
        if (typeof name === 'object')
            Object.entries(name).forEach(([key, value]) => {
                if (!(key in this.meta.defs))
                    this.meta.defs[key] = value;
            });
        else
            this.meta.defs[name] = model;
        return this;
    }
}
exports.default = Elysia;
exports.Elysia = Elysia;
var handler_1 = require("./handler");
Object.defineProperty(exports, "mapResponse", { enumerable: true, get: function () { return handler_1.mapResponse; } });
Object.defineProperty(exports, "mapCompactResponse", { enumerable: true, get: function () { return handler_1.mapCompactResponse; } });
Object.defineProperty(exports, "mapEarlyResponse", { enumerable: true, get: function () { return handler_1.mapEarlyResponse; } });
var custom_types_1 = require("./custom-types");
Object.defineProperty(exports, "t", { enumerable: true, get: function () { return custom_types_1.t; } });
var ws_2 = require("./ws");
Object.defineProperty(exports, "ws", { enumerable: true, get: function () { return ws_2.ws; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "getSchemaValidator", { enumerable: true, get: function () { return utils_2.getSchemaValidator; } });
Object.defineProperty(exports, "mergeDeep", { enumerable: true, get: function () { return utils_2.mergeDeep; } });
Object.defineProperty(exports, "mergeHook", { enumerable: true, get: function () { return utils_2.mergeHook; } });
Object.defineProperty(exports, "mergeObjectArray", { enumerable: true, get: function () { return utils_2.mergeObjectArray; } });
Object.defineProperty(exports, "getResponseSchemaValidator", { enumerable: true, get: function () { return utils_2.getResponseSchemaValidator; } });
var error_2 = require("./error");
Object.defineProperty(exports, "ParseError", { enumerable: true, get: function () { return error_2.ParseError; } });
Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return error_2.NotFoundError; } });
Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return error_2.ValidationError; } });
Object.defineProperty(exports, "InternalServerError", { enumerable: true, get: function () { return error_2.InternalServerError; } });
