"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorToResponse = exports.mapCompactResponse = exports.mapResponse = exports.mapEarlyResponse = exports.isNotEmpty = void 0;
const hasHeaderShorthand = 'toJSON' in new Headers();
const isNotEmpty = (obj) => {
    for (const x in obj)
        return true;
    return false;
};
exports.isNotEmpty = isNotEmpty;
const parseSetCookies = (headers, setCookie) => {
    headers.delete('Set-Cookie');
    for (let i = 0; i < setCookie.length; i++) {
        const index = setCookie[i].indexOf('=');
        headers.append('Set-Cookie', `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
    }
    return headers;
};
const mapEarlyResponse = (response, set) => {
    if ((0, exports.isNotEmpty)(set.headers) || set.status !== 200 || set.redirect) {
        if (set.redirect) {
            set.headers.Location = set.redirect;
            set.status = 302;
        }
        if (set.headers['Set-Cookie'] &&
            Array.isArray(set.headers['Set-Cookie']))
            set.headers = parseSetCookies(new Headers(set.headers), set.headers['Set-Cookie']);
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response, set);
            case 'Object':
            case 'Array':
                return Response.json(response, set);
            case undefined:
                if (!response)
                    return;
                return Response.json(response, set);
            case 'Response':
                const inherits = Object.assign({}, set.headers);
                if (hasHeaderShorthand)
                    set.headers = response.headers.toJSON();
                else
                    for (const [key, value] of response.headers.entries())
                        if (!(key in set.headers))
                            set.headers[key] = value;
                for (const key in inherits)
                    response.headers.append(key, inherits[key]);
                if (response.status !== set.status)
                    set.status = response.status;
                return response;
            case 'Promise':
                return response.then((x) => {
                    const r = (0, exports.mapEarlyResponse)(x, set);
                    if (r !== undefined)
                        return r;
                    return;
                });
            case 'Error':
                return (0, exports.errorToResponse)(response, set.headers);
            case 'Function':
                return response();
            case 'Number':
            case 'Boolean':
                return new Response(response.toString(), set);
            default:
                if (response instanceof Response)
                    return response;
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123) {
                    if (!set.headers['Content-Type'])
                        set.headers['Content-Type'] = 'application/json';
                    return new Response(JSON.stringify(response), set);
                }
                return new Response(r, set);
        }
    }
    else
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response);
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case undefined:
                if (!response)
                    return new Response('');
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case 'Response':
                return response;
            case 'Promise':
                return response.then((x) => {
                    const r = (0, exports.mapEarlyResponse)(x, set);
                    if (r !== undefined)
                        return r;
                    return;
                });
            case 'Error':
                return (0, exports.errorToResponse)(response, set.headers);
            case 'Function':
                return response();
            case 'Number':
            case 'Boolean':
                return new Response(response.toString());
            default:
                if (response instanceof Response)
                    return response;
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123)
                    return new Response(JSON.stringify(response), {
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                return new Response(r);
        }
};
exports.mapEarlyResponse = mapEarlyResponse;
const mapResponse = (response, set) => {
    if ((0, exports.isNotEmpty)(set.headers) || set.status !== 200 || set.redirect) {
        if (set.redirect) {
            set.headers.Location = set.redirect;
            set.status = 302;
        }
        if (set.headers['Set-Cookie'] &&
            Array.isArray(set.headers['Set-Cookie']))
            set.headers = parseSetCookies(new Headers(set.headers), set.headers['Set-Cookie']);
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response, {
                    status: set.status,
                    headers: set.headers
                });
            case 'Object':
            case 'Array':
                return Response.json(response, set);
            case undefined:
                if (!response)
                    return new Response('', set);
                return Response.json(response, set);
            case 'Response':
                const inherits = Object.assign({}, set.headers);
                if (hasHeaderShorthand)
                    set.headers = response.headers.toJSON();
                else
                    for (const [key, value] of response.headers.entries())
                        if (!(key in set.headers))
                            set.headers[key] = value;
                for (const key in inherits)
                    response.headers.append(key, inherits[key]);
                return response;
            case 'Error':
                return (0, exports.errorToResponse)(response, set.headers);
            case 'Promise':
                return response.then((x) => (0, exports.mapResponse)(x, set));
            case 'Function':
                return response();
            case 'Number':
            case 'Boolean':
                return new Response(response.toString(), set);
            default:
                if (response instanceof Response)
                    return response;
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123) {
                    if (!set.headers['Content-Type'])
                        set.headers['Content-Type'] = 'application/json';
                    return new Response(JSON.stringify(response), set);
                }
                return new Response(r, set);
        }
    }
    else
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response);
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case undefined:
                if (!response)
                    return new Response('');
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case 'Response':
                return response;
            case 'Error':
                return (0, exports.errorToResponse)(response);
            case 'Promise':
                return response.then((x) => {
                    const r = (0, exports.mapResponse)(x, set);
                    if (r !== undefined)
                        return r;
                    return new Response('');
                });
            case 'Function':
                return response();
            case 'Number':
            case 'Boolean':
                return new Response(response.toString());
            default:
                if (response instanceof Response)
                    return response;
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123)
                    return new Response(JSON.stringify(response), {
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                return new Response(r);
        }
};
exports.mapResponse = mapResponse;
const mapCompactResponse = (response) => {
    switch (response?.constructor?.name) {
        case 'String':
        case 'Blob':
            return new Response(response);
        case 'Object':
        case 'Array':
            return new Response(JSON.stringify(response), {
                headers: {
                    'content-type': 'application/json'
                }
            });
        case undefined:
            if (!response)
                return new Response('');
            return new Response(JSON.stringify(response), {
                headers: {
                    'content-type': 'application/json'
                }
            });
        case 'Response':
            return response;
        case 'Error':
            return (0, exports.errorToResponse)(response);
        case 'Promise':
            return response.then((x) => {
                const r = (0, exports.mapCompactResponse)(x);
                if (r !== undefined)
                    return r;
                return new Response('');
            });
        case 'Function':
            return response();
        case 'Number':
        case 'Boolean':
            return new Response(response.toString());
        default:
            if (response instanceof Response)
                return response;
            const r = JSON.stringify(response);
            if (r.charCodeAt(0) === 123)
                return new Response(JSON.stringify(response), {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
            return new Response(r);
    }
};
exports.mapCompactResponse = mapCompactResponse;
const errorToResponse = (error, headers) => new Response(JSON.stringify({
    name: error?.name,
    message: error?.message,
    cause: error?.cause
}), {
    status: 500,
    headers
});
exports.errorToResponse = errorToResponse;
