/// <reference types="bun-types" />
import { Type, type SchemaOptions, type NumericOptions } from '@sinclair/typebox';
import type { TypeCheck } from '@sinclair/typebox/compiler';
type MaybeArray<T> = T | T[];
export declare namespace ElysiaTypeOptions {
    type Numeric = NumericOptions<number>;
    type FileUnit = number | `${number}${'k' | 'm'}`;
    interface File extends SchemaOptions {
        type?: MaybeArray<(string & {}) | 'image' | 'image/jpeg' | 'image/png' | 'image/gif' | 'image/tiff' | 'image/x-icon' | 'image/svg' | 'image/webp' | 'image/avif' | 'audio' | 'audio/mpeg' | 'audio/x-ms-wma' | 'audio/vnd.rn-realaudio' | 'audio/x-wav' | 'video' | 'video/mpeg' | 'video/mp4' | 'video/quicktime' | 'video/x-ms-wmv' | 'video/x-msvideo' | 'video/x-flv' | 'video/webm' | 'text' | 'text/css' | 'text/csv' | 'text/html' | 'text/javascript' | 'text/plain' | 'text/xml' | 'application' | 'application/ogg' | 'application/pdf' | 'application/xhtml' | 'application/html' | 'application/json' | 'application/ld+json' | 'application/xml' | 'application/zip'>;
        minSize?: FileUnit;
        maxSize?: FileUnit;
    }
    interface Files extends File {
        minItems?: number;
        maxItems?: number;
    }
}
export declare const ElysiaType: {
    readonly Numeric: (options?: Partial<NumericOptions<number>> | undefined) => import("@sinclair/typebox").TUnsafe<number>;
    readonly File: (options?: Partial<ElysiaTypeOptions.File> | undefined) => import("@sinclair/typebox").TUnsafe<Blob>;
    readonly Files: (options?: Partial<ElysiaTypeOptions.Files> | undefined) => import("@sinclair/typebox").TUnsafe<Blob[]>;
};
declare module '@sinclair/typebox' {
    interface TypeBuilder {
        Numeric: typeof ElysiaType.Numeric;
        File: typeof ElysiaType.File;
        Files: typeof ElysiaType.Files;
        URLEncoded: (typeof Type)['Object'];
    }
    interface SchemaOptions {
        error?: string | ((type: string, validator: TypeCheck<any>, value: unknown) => string | void);
    }
}
export { Type as t };
