"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDynamicErrorHandler = exports.createDynamicHandler = void 0;
const error_1 = require("./error");
const handler_1 = require("./handler");
const fast_querystring_1 = require("fast-querystring");
const createDynamicHandler = (app) => async (request) => {
    const set = {
        status: 200,
        headers: {}
    };
    let context;
    if (app.decorators) {
        context = app.decorators;
        context.request = request;
        context.set = set;
        context.store = app.store;
    }
    else {
        context = {
            set,
            store: app.store,
            request
        };
    }
    const url = request.url, s = url.indexOf('/', 11), q = url.indexOf('?', s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
    try {
        for (let i = 0; i < app.event.request.length; i++) {
            const onRequest = app.event.request[i];
            let response = onRequest(context);
            if (response instanceof Promise)
                response = await response;
            response = (0, handler_1.mapEarlyResponse)(response, set);
            if (response)
                return response;
        }
        const handler = app.dynamicRouter.find(request.method, path) ??
            app.dynamicRouter.find('ALL', path);
        if (!handler)
            throw new error_1.NotFoundError();
        const { handle, hooks, validator, content } = handler.store;
        let body;
        if (request.method !== 'GET') {
            if (content) {
                switch (content) {
                    case 'application/json':
                        body = await request.json();
                        break;
                    case 'text/plain':
                        body = await request.text();
                        break;
                    case 'application/x-www-form-urlencoded':
                        body = (0, fast_querystring_1.parse)(await request.text());
                        break;
                    case 'application/octet-stream':
                        body = await request.arrayBuffer();
                        break;
                    case 'multipart/form-data':
                        body = {};
                        const form = await request.formData();
                        for (const key of form.keys()) {
                            if (body[key])
                                continue;
                            const value = form.getAll(key);
                            if (value.length === 1)
                                body[key] = value[0];
                            else
                                body[key] = value;
                        }
                        break;
                }
            }
            else {
                let contentType = request.headers.get('content-type');
                if (contentType) {
                    const index = contentType.indexOf(';');
                    if (index !== -1)
                        contentType = contentType.slice(0, index);
                    for (let i = 0; i < app.event.parse.length; i++) {
                        let temp = app.event.parse[i](context, contentType);
                        if (temp instanceof Promise)
                            temp = await temp;
                        if (temp) {
                            body = temp;
                            break;
                        }
                    }
                    if (body === undefined) {
                        switch (contentType) {
                            case 'application/json':
                                body = await request.json();
                                break;
                            case 'text/plain':
                                body = await request.text();
                                break;
                            case 'application/x-www-form-urlencoded':
                                body = (0, fast_querystring_1.parse)(await request.text());
                                break;
                            case 'application/octet-stream':
                                body = await request.arrayBuffer();
                                break;
                            case 'multipart/form-data':
                                body = {};
                                const form = await request.formData();
                                for (const key of form.keys()) {
                                    if (body[key])
                                        continue;
                                    const value = form.getAll(key);
                                    if (value.length === 1)
                                        body[key] = value[0];
                                    else
                                        body[key] = value;
                                }
                                break;
                        }
                    }
                }
            }
        }
        context.body = body;
        context.params = handler?.params || {};
        context.query = q === -1 ? {} : (0, fast_querystring_1.parse)(url.substring(q + 1));
        for (let i = 0; i < hooks.transform.length; i++) {
            const operation = hooks.transform[i](context);
            if (hooks.transform[i].$elysia === 'derive') {
                if (operation instanceof Promise)
                    Object.assign(context, await operation);
                else
                    Object.assign(context, operation);
            }
            else if (operation instanceof Promise)
                await operation;
        }
        if (validator) {
            if (validator.headers) {
                const _header = {};
                for (const key in request.headers)
                    _header[key] = request.headers.get(key);
                if (validator.headers.Check(_header) === false)
                    throw new error_1.ValidationError('header', validator.headers, _header);
            }
            if (validator.params?.Check(context.params) === false)
                throw new error_1.ValidationError('params', validator.params, context.params);
            if (validator.query?.Check(context.query) === false)
                throw new error_1.ValidationError('query', validator.query, context.query);
            if (validator.body?.Check(body) === false)
                throw new error_1.ValidationError('body', validator.body, body);
        }
        for (let i = 0; i < hooks.beforeHandle.length; i++) {
            let response = hooks.beforeHandle[i](context);
            if (response instanceof Promise)
                response = await response;
            if (response !== undefined) {
                for (let i = 0; i < hooks.afterHandle.length; i++) {
                    let newResponse = hooks.afterHandle[i](context, response);
                    if (newResponse instanceof Promise)
                        newResponse = await newResponse;
                    if (newResponse)
                        response = newResponse;
                }
                const result = (0, handler_1.mapEarlyResponse)(response, context.set);
                if (result)
                    return result;
            }
        }
        let response = handle(context);
        if (response instanceof Promise)
            response = await response;
        if (!hooks.afterHandle.length) {
            const responseValidator = validator?.response?.[response.status];
            if (responseValidator?.Check(response) === false)
                throw new error_1.ValidationError('response', responseValidator, response);
        }
        else
            for (let i = 0; i < hooks.afterHandle.length; i++) {
                let newResponse = hooks.afterHandle[i](context, response);
                if (newResponse instanceof Promise)
                    newResponse = await newResponse;
                const result = (0, handler_1.mapEarlyResponse)(newResponse, context.set);
                if (result !== undefined) {
                    const responseValidator = validator?.response?.[response.status];
                    if (responseValidator?.Check(result) === false)
                        throw new error_1.ValidationError('response', responseValidator, result);
                    return result;
                }
            }
        return (0, handler_1.mapResponse)(response, context.set);
    }
    catch (error) {
        if (error.status)
            set.status = error.status;
        return app.handleError(request, error, set);
    }
    finally {
        for (const onResponse of app.event.onResponse)
            await onResponse(context);
    }
};
exports.createDynamicHandler = createDynamicHandler;
const createDynamicErrorHandler = (app) => async (request, error, set = {
    headers: {}
}) => {
    for (let i = 0; i < app.event.error.length; i++) {
        let response = app.event.error[i]({
            request,
            code: error.code ?? error[error_1.ERROR_CODE] ?? 'UNKNOWN',
            error,
            set
        });
        if (response instanceof Promise)
            response = await response;
        if (response !== undefined && response !== null)
            return (0, handler_1.mapResponse)(response, set);
    }
    return new Response(typeof error.cause === 'string' ? error.cause : error.message, {
        headers: set.headers,
        status: error.status ?? 500
    });
};
exports.createDynamicErrorHandler = createDynamicErrorHandler;
