"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterGlobalHook = exports.asGlobal = exports.asGlobalHook = exports.mergeLifeCycle = exports.checksum = exports.getResponseSchemaValidator = exports.getSchemaValidator = exports.mergeHook = exports.mergeObjectArray = exports.mergeDeep = void 0;
const typebox_1 = require("@sinclair/typebox");
const value_1 = require("@sinclair/typebox/value");
const compiler_1 = require("@sinclair/typebox/compiler");
const mergician_1 = __importDefault(require("mergician"));
exports.mergeDeep = (0, mergician_1.default)({
    appendArrays: true
});
const mergeObjectArray = (a, b) => {
    const array = [...(Array.isArray(a) ? a : [a])];
    const checksums = [];
    for (const item of array) {
        if (item.$elysiaChecksum)
            checksums.push(item.$elysiaChecksum);
    }
    for (const item of Array.isArray(b) ? b : [b]) {
        if (!checksums.includes(item?.$elysiaChecksum))
            array.push(item);
    }
    return array;
};
exports.mergeObjectArray = mergeObjectArray;
const mergeHook = (a, b) => {
    return {
        body: b?.body ?? a?.body,
        headers: b?.headers ?? a?.headers,
        params: b?.params ?? a?.params,
        query: b?.query ?? a?.query,
        response: b?.response ?? a?.response,
        type: a?.type || b?.type,
        detail: (0, exports.mergeDeep)(b?.detail ?? {}, a?.detail ?? {}),
        parse: (0, exports.mergeObjectArray)(a.parse ?? [], b?.parse ?? []),
        transform: (0, exports.mergeObjectArray)(a.transform ?? [], b?.transform ?? []),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle ?? [], b?.beforeHandle ?? []),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle ?? [], b?.afterHandle ?? []),
        onResponse: (0, exports.mergeObjectArray)(a.onResponse ?? [], b?.onResponse ?? []),
        error: (0, exports.mergeObjectArray)(a.error ?? [], b?.error ?? [])
    };
};
exports.mergeHook = mergeHook;
const getSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const schema = typeof s === 'string' ? models[s] : s;
    if (schema.type === 'object' && 'additionalProperties' in schema === false)
        schema.additionalProperties = additionalProperties;
    if (dynamic)
        return {
            schema,
            references: '',
            checkFunc: () => { },
            code: '',
            Check: (value) => value_1.Value.Check(schema, value),
            Errors: (value) => value_1.Value.Errors(schema, value),
            Code: () => ''
        };
    return compiler_1.TypeCompiler.Compile(schema);
};
exports.getSchemaValidator = getSchemaValidator;
const getResponseSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s;
    const compile = (schema) => {
        if (dynamic)
            return {
                schema,
                references: '',
                checkFunc: () => { },
                code: '',
                Check: (value) => value_1.Value.Check(schema, value),
                Errors: (value) => value_1.Value.Errors(schema, value),
                Code: () => ''
            };
        return compiler_1.TypeCompiler.Compile(schema);
    };
    if (typebox_1.Kind in maybeSchemaOrRecord)
        return {
            200: compile(maybeSchemaOrRecord)
        };
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
        const maybeNameOrSchema = maybeSchemaOrRecord[status];
        if (typeof maybeNameOrSchema === 'string') {
            if (maybeNameOrSchema in models) {
                const schema = models[maybeNameOrSchema];
                schema.type === 'object' &&
                    'additionalProperties' in schema === false;
                record[+status] = typebox_1.Kind in schema ? compile(schema) : schema;
            }
            return undefined;
        }
        if (maybeNameOrSchema.type === 'object' &&
            'additionalProperties' in maybeNameOrSchema === false)
            maybeNameOrSchema.additionalProperties = additionalProperties;
        record[+status] =
            typebox_1.Kind in maybeNameOrSchema
                ? compile(maybeNameOrSchema)
                : maybeNameOrSchema;
    });
    return record;
};
exports.getResponseSchemaValidator = getResponseSchemaValidator;
const checksum = (s) => {
    let h = 9;
    for (let i = 0; i < s.length;)
        h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return (h = h ^ (h >>> 9));
};
exports.checksum = checksum;
const mergeLifeCycle = (a, b, checksum) => {
    const injectChecksum = (x) => {
        if (checksum)
            x.$elysiaChecksum = checksum;
        return x;
    };
    return {
        start: (0, exports.mergeObjectArray)(a.start, ('start' in b ? b.start : []).map(injectChecksum)),
        request: (0, exports.mergeObjectArray)(a.request, ('request' in b ? b.request : []).map(injectChecksum)),
        parse: (0, exports.mergeObjectArray)(a.parse, b?.parse ?? []).map(injectChecksum),
        transform: (0, exports.mergeObjectArray)(a.transform, (b?.transform ?? []).map(injectChecksum)),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
        onResponse: (0, exports.mergeObjectArray)(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
        error: (0, exports.mergeObjectArray)(a.error, (b?.error ?? []).map(injectChecksum)),
        stop: (0, exports.mergeObjectArray)(a.stop, ('stop' in b ? b.stop : []).map(injectChecksum))
    };
};
exports.mergeLifeCycle = mergeLifeCycle;
const asGlobalHook = (hook, inject = true) => {
    return {
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: (0, exports.asGlobal)(hook?.parse, inject),
        transform: (0, exports.asGlobal)(hook?.transform, inject),
        beforeHandle: (0, exports.asGlobal)(hook?.beforeHandle, inject),
        afterHandle: (0, exports.asGlobal)(hook?.afterHandle, inject),
        onResponse: (0, exports.asGlobal)(hook?.onResponse, inject),
        error: (0, exports.asGlobal)(hook?.error, inject)
    };
};
exports.asGlobalHook = asGlobalHook;
const asGlobal = (fn, inject = true) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        if (inject)
            fn.$elysiaHookType = 'global';
        else
            fn.$elysiaHookType = undefined;
        return fn;
    }
    return fn.map((x) => {
        if (inject)
            x.$elysiaHookType = 'global';
        else
            x.$elysiaHookType = undefined;
        return x;
    });
};
exports.asGlobal = asGlobal;
const filterGlobal = (fn) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        return fn.$elysiaHookType === 'global' ? fn : undefined;
    }
    return fn.filter((x) => x.$elysiaHookType === 'global');
};
const filterGlobalHook = (hook) => {
    return {
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: filterGlobal(hook?.parse),
        transform: filterGlobal(hook?.transform),
        beforeHandle: filterGlobal(hook?.beforeHandle),
        afterHandle: filterGlobal(hook?.afterHandle),
        onResponse: filterGlobal(hook?.onResponse),
        error: filterGlobal(hook?.error)
    };
};
exports.filterGlobalHook = filterGlobalHook;
