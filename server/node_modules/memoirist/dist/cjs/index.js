"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(exports,{Memoirist:function(){return a},default:function(){return n}});const e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});class a{root={};history=[];static regex={static:/:.+?(?=\/|$)/,params:/:.+?(?=\/|$)/g};add(l,n,i){let s;if("string"!=typeof n)throw TypeError("Route path must be a string");""===n?n="/":"/"!==n[0]&&(n=`/${n}`),this.history.push([l,n,i]);let o="*"===n[n.length-1];o&&(n=n.slice(0,-1));let u=n.split(a.regex.static),p=n.match(a.regex.params)||[];""===u[u.length-1]&&u.pop(),s=this.root[l]?this.root[l]:this.root[l]=e("/");let c=0;for(let a=0;a<u.length;++a){let l=u[a];if(a>0){let t=p[c++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route "${n}" with parameter "${t}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(l);continue}s=a.inert}for(let r=0;;){if(r===l.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(l,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(l.charCodeAt(r))){s=s.inert.get(l.charCodeAt(r)),l=l.slice(r),r=0;continue}let t=e(l.slice(r));s.inert.set(l.charCodeAt(r),t),s=t;break}if(l[r]!==s.part[r]){let a=t(s,s.part.slice(r)),n=e(l.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,n])),s=n;break}++r}}if(c<p.length){let e=p[c],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route "${n}" with parameter "${t}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return o?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?l(t,t.length,r,0):null}}const l=(e,t,r,a)=>{let n=r?.part,i=a+n.length;if(n.length>1){if(i>t)return null;if(n.length<15){for(let t=1,r=a+1;t<n.length;++t,++r)if(n.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(a,i)!==n)return null}if(i===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{"*":""}}:null;if(null!==r.inert){let a=r.inert.get(e.charCodeAt(i));if(void 0!==a){let r=l(e,t,a,i);if(null!==r)return r}}if(null!==r.params){let a=r.params,n=e.indexOf("/",i);if(n!==i){if(-1===n||n>=t){if(null!==a.store){let r={};return r[a.paramName]=e.substring(i,t),{store:a.store,params:r}}}else if(null!==a.inert){let r=l(e,t,a.inert,n);if(null!==r)return r.params[a.paramName]=e.substring(i,n),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{"*":e.substring(i,t)}}:null},n=a;