let e=(e,t)=>({part:e,store:null,inert:void 0!==t?new Map(t.map(e=>[e.part.charCodeAt(0),e])):null,params:null,wildcardStore:null}),t=(e,t)=>({...e,part:t}),r=e=>({paramName:e,store:null,inert:null});export class Memoirist{root={};history=[];static regex={static:/:.+?(?=\/|$)/,params:/:.+?(?=\/|$)/g};add(a,l,i){let s;if("string"!=typeof l)throw TypeError("Route path must be a string");""===l?l="/":"/"!==l[0]&&(l=`/${l}`),this.history.push([a,l,i]);let n="*"===l[l.length-1];n&&(l=l.slice(0,-1));let o=l.split(Memoirist.regex.static),u=l.match(Memoirist.regex.params)||[];""===o[o.length-1]&&o.pop(),s=this.root[a]?this.root[a]:this.root[a]=e("/");let p=0;for(let a=0;a<o.length;++a){let i=o[a];if(a>0){let t=u[p++].slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route "${l}" with parameter "${t}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);let a=s.params;if(null===a.inert){s=a.inert=e(i);continue}s=a.inert}for(let r=0;;){if(r===i.length){if(r<s.part.length){let a=t(s,s.part.slice(r));Object.assign(s,e(i,[a]))}break}if(r===s.part.length){if(null===s.inert)s.inert=new Map;else if(s.inert.has(i.charCodeAt(r))){s=s.inert.get(i.charCodeAt(r)),i=i.slice(r),r=0;continue}let t=e(i.slice(r));s.inert.set(i.charCodeAt(r),t),s=t;break}if(i[r]!==s.part[r]){let a=t(s,s.part.slice(r)),l=e(i.slice(r));Object.assign(s,e(s.part.slice(0,r),[a,l])),s=l;break}++r}}if(p<u.length){let e=u[p],t=e.slice(1);if(null===s.params)s.params=r(t);else if(s.params.paramName!==t)throw Error(`Cannot create route "${l}" with parameter "${t}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);return null===s.params.store&&(s.params.store=i),s.params.store}return n?(null===s.wildcardStore&&(s.wildcardStore=i),s.wildcardStore):(null===s.store&&(s.store=i),s.store)}find(e,t){let r=this.root[e];return r?a(t,t.length,r,0):null}}let a=(e,t,r,l)=>{let i=r?.part,s=l+i.length;if(i.length>1){if(s>t)return null;if(i.length<15){for(let t=1,r=l+1;t<i.length;++t,++r)if(i.charCodeAt(t)!==e.charCodeAt(r))return null}else if(e.substring(l,s)!==i)return null}if(s===t)return null!==r.store?{store:r.store,params:{}}:null!==r.wildcardStore?{store:r.wildcardStore,params:{"*":""}}:null;if(null!==r.inert){let l=r.inert.get(e.charCodeAt(s));if(void 0!==l){let r=a(e,t,l,s);if(null!==r)return r}}if(null!==r.params){let l=r.params,i=e.indexOf("/",s);if(i!==s){if(-1===i||i>=t){if(null!==l.store){let r={};return r[l.paramName]=e.substring(s,t),{store:l.store,params:r}}}else if(null!==l.inert){let r=a(e,t,l.inert,i);if(null!==r)return r.params[l.paramName]=e.substring(s,i),r}}}return null!==r.wildcardStore?{store:r.wildcardStore,params:{"*":e.substring(s,t)}}:null};export default Memoirist;