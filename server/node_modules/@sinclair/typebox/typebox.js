"use strict";
/*--------------------------------------------------------------------------

@sinclair/typebox

The MIT License (MIT)

Copyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

---------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = void 0;
// --------------------------------------------------------------------------
// Symbols
// --------------------------------------------------------------------------
exports.Readonly = Symbol.for('TypeBox.Readonly');
exports.Optional = Symbol.for('TypeBox.Optional');
exports.Hint = Symbol.for('TypeBox.Hint');
exports.Kind = Symbol.for('TypeBox.Kind');
// --------------------------------------------------------------------------
// Patterns
// --------------------------------------------------------------------------
exports.PatternBoolean = '(true|false)';
exports.PatternNumber = '(0|[1-9][0-9]*)';
exports.PatternString = '(.*)';
exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
exports.PatternNumberExact = `^${exports.PatternNumber}$`;
exports.PatternStringExact = `^${exports.PatternString}$`;
/** A registry for user defined types */
var TypeRegistry;
(function (TypeRegistry) {
    const map = new Map();
    /** Returns the entries in this registry */
    function Entries() {
        return new Map(map);
    }
    TypeRegistry.Entries = Entries;
    /** Clears all user defined types */
    function Clear() {
        return map.clear();
    }
    TypeRegistry.Clear = Clear;
    /** Deletes a registered type */
    function Delete(kind) {
        return map.delete(kind);
    }
    TypeRegistry.Delete = Delete;
    /** Returns true if this registry contains this kind */
    function Has(kind) {
        return map.has(kind);
    }
    TypeRegistry.Has = Has;
    /** Sets a validation function for a user defined type */
    function Set(kind, func) {
        map.set(kind, func);
    }
    TypeRegistry.Set = Set;
    /** Gets a custom validation function for a user defined type */
    function Get(kind) {
        return map.get(kind);
    }
    TypeRegistry.Get = Get;
})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
/** A registry for user defined string formats */
var FormatRegistry;
(function (FormatRegistry) {
    const map = new Map();
    /** Returns the entries in this registry */
    function Entries() {
        return new Map(map);
    }
    FormatRegistry.Entries = Entries;
    /** Clears all user defined string formats */
    function Clear() {
        return map.clear();
    }
    FormatRegistry.Clear = Clear;
    /** Deletes a registered format */
    function Delete(format) {
        return map.delete(format);
    }
    FormatRegistry.Delete = Delete;
    /** Returns true if the user defined string format exists */
    function Has(format) {
        return map.has(format);
    }
    FormatRegistry.Has = Has;
    /** Sets a validation function for a user defined string format */
    function Set(format, func) {
        map.set(format, func);
    }
    FormatRegistry.Set = Set;
    /** Gets a validation function for a user defined string format */
    function Get(format) {
        return map.get(format);
    }
    FormatRegistry.Get = Get;
})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
// --------------------------------------------------------------------------
// ValueGuard
// --------------------------------------------------------------------------
var ValueGuard;
(function (ValueGuard) {
    function IsObject(value) {
        return typeof value === 'object' && value !== null;
    }
    ValueGuard.IsObject = IsObject;
    function IsArray(value) {
        return Array.isArray(value);
    }
    ValueGuard.IsArray = IsArray;
    function IsBoolean(value) {
        return typeof value === 'boolean';
    }
    ValueGuard.IsBoolean = IsBoolean;
    function IsNull(value) {
        return value === null;
    }
    ValueGuard.IsNull = IsNull;
    function IsUndefined(value) {
        return value === undefined;
    }
    ValueGuard.IsUndefined = IsUndefined;
    function IsBigInt(value) {
        return typeof value === 'bigint';
    }
    ValueGuard.IsBigInt = IsBigInt;
    function IsNumber(value) {
        return typeof value === 'number';
    }
    ValueGuard.IsNumber = IsNumber;
    function IsString(value) {
        return typeof value === 'string';
    }
    ValueGuard.IsString = IsString;
})(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
// --------------------------------------------------------------------------
// TypeGuard
// --------------------------------------------------------------------------
class TypeGuardUnknownTypeError extends Error {
    constructor(schema) {
        super('TypeGuard: Unknown type');
        this.schema = schema;
    }
}
exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
/** Provides functions to test if JavaScript values are TypeBox types */
var TypeGuard;
(function (TypeGuard) {
    function IsPattern(value) {
        try {
            new RegExp(value);
            return true;
        }
        catch {
            return false;
        }
    }
    function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value))
            return false;
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
                return false;
            }
        }
        return true;
    }
    function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
    }
    function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern(value) {
        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));
    }
    function IsOptionalFormat(value) {
        return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));
    }
    function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
    }
    /** Returns true if the given schema is TAny */
    function TAny(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Any') &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TAny = TAny;
    /** Returns true if the given schema is TArray */
    function TArray(schema) {
        return (TKindOf(schema, 'Array') &&
            schema.type === 'array' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.items) &&
            IsOptionalNumber(schema.minItems) &&
            IsOptionalNumber(schema.maxItems) &&
            IsOptionalBoolean(schema.uniqueItems) &&
            IsOptionalSchema(schema.contains) &&
            IsOptionalNumber(schema.minContains) &&
            IsOptionalNumber(schema.maxContains));
    }
    TypeGuard.TArray = TArray;
    /** Returns true if the given schema is TAsyncIterator */
    function TAsyncIterator(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'AsyncIterator') &&
            schema.type === 'AsyncIterator' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.items));
    }
    TypeGuard.TAsyncIterator = TAsyncIterator;
    /** Returns true if the given schema is TBigInt */
    function TBigInt(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'BigInt') &&
            schema.type === 'bigint' &&
            IsOptionalString(schema.$id) &&
            IsOptionalBigInt(schema.multipleOf) &&
            IsOptionalBigInt(schema.minimum) &&
            IsOptionalBigInt(schema.maximum) &&
            IsOptionalBigInt(schema.exclusiveMinimum) &&
            IsOptionalBigInt(schema.exclusiveMaximum));
    }
    TypeGuard.TBigInt = TBigInt;
    /** Returns true if the given schema is TBoolean */
    function TBoolean(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Boolean') &&
            schema.type === 'boolean' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TBoolean = TBoolean;
    /** Returns true if the given schema is TConstructor */
    function TConstructor(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Constructor') &&
            schema.type === 'constructor' &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsArray(schema.parameters) &&
            TSchema(schema.returns))) {
            return false;
        }
        for (const parameter of schema.parameters) {
            if (!TSchema(parameter))
                return false;
        }
        return true;
    }
    TypeGuard.TConstructor = TConstructor;
    /** Returns true if the given schema is TDate */
    function TDate(schema) {
        return (TKindOf(schema, 'Date') &&
            schema.type === 'Date' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.minimumTimestamp) &&
            IsOptionalNumber(schema.maximumTimestamp) &&
            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&
            IsOptionalNumber(schema.exclusiveMaximumTimestamp));
    }
    TypeGuard.TDate = TDate;
    /** Returns true if the given schema is TFunction */
    function TFunction(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Function') &&
            schema.type === 'function' &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsArray(schema.parameters) &&
            TSchema(schema.returns))) {
            return false;
        }
        for (const parameter of schema.parameters) {
            if (!TSchema(parameter))
                return false;
        }
        return true;
    }
    TypeGuard.TFunction = TFunction;
    /** Returns true if the given schema is TInteger */
    function TInteger(schema) {
        return (TKindOf(schema, 'Integer') &&
            schema.type === 'integer' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.multipleOf) &&
            IsOptionalNumber(schema.minimum) &&
            IsOptionalNumber(schema.maximum) &&
            IsOptionalNumber(schema.exclusiveMinimum) &&
            IsOptionalNumber(schema.exclusiveMaximum));
    }
    TypeGuard.TInteger = TInteger;
    /** Returns true if the given schema is TIntersect */
    function TIntersect(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Intersect') &&
            ValueGuard.IsArray(schema.allOf) &&
            IsOptionalString(schema.type) &&
            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&
            IsOptionalString(schema.$id))) {
            return false;
        }
        if ('type' in schema && schema.type !== 'object') {
            return false;
        }
        for (const inner of schema.allOf) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TIntersect = TIntersect;
    /** Returns true if the given schema is TIterator */
    function TIterator(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Iterator') &&
            schema.type === 'Iterator' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.items));
    }
    TypeGuard.TIterator = TIterator;
    /** Returns true if the given schema is a TKind with the given name. */
    function TKindOf(schema, kind) {
        return TKind(schema) && schema[exports.Kind] === kind;
    }
    TypeGuard.TKindOf = TKindOf;
    /** Returns true if the given schema is TKind */
    function TKind(schema) {
        return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
    }
    TypeGuard.TKind = TKind;
    /** Returns true if the given schema is TLiteral<string> */
    function TLiteralString(schema) {
        return TLiteral(schema) && ValueGuard.IsString(schema.const);
    }
    TypeGuard.TLiteralString = TLiteralString;
    /** Returns true if the given schema is TLiteral<number> */
    function TLiteralNumber(schema) {
        return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
    }
    TypeGuard.TLiteralNumber = TLiteralNumber;
    /** Returns true if the given schema is TLiteral<boolean> */
    function TLiteralBoolean(schema) {
        return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
    }
    TypeGuard.TLiteralBoolean = TLiteralBoolean;
    /** Returns true if the given schema is TLiteral */
    function TLiteral(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Literal') &&
            IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) ||
            ValueGuard.IsNumber(schema.const) ||
            ValueGuard.IsString(schema.const)));
    }
    TypeGuard.TLiteral = TLiteral;
    /** Returns true if the given schema is TNever */
    function TNever(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Never') &&
            ValueGuard.IsObject(schema.not) &&
            Object.getOwnPropertyNames(schema.not).length === 0);
    }
    TypeGuard.TNever = TNever;
    /** Returns true if the given schema is TNot */
    function TNot(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Not') &&
            TSchema(schema.not));
    }
    TypeGuard.TNot = TNot;
    /** Returns true if the given schema is TNull */
    function TNull(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Null') &&
            schema.type === 'null' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TNull = TNull;
    /** Returns true if the given schema is TNumber */
    function TNumber(schema) {
        return (TKindOf(schema, 'Number') &&
            schema.type === 'number' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.multipleOf) &&
            IsOptionalNumber(schema.minimum) &&
            IsOptionalNumber(schema.maximum) &&
            IsOptionalNumber(schema.exclusiveMinimum) &&
            IsOptionalNumber(schema.exclusiveMaximum));
    }
    TypeGuard.TNumber = TNumber;
    /** Returns true if the given schema is TObject */
    function TObject(schema) {
        if (!(TKindOf(schema, 'Object') &&
            schema.type === 'object' &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsObject(schema.properties) &&
            IsAdditionalProperties(schema.additionalProperties) &&
            IsOptionalNumber(schema.minProperties) &&
            IsOptionalNumber(schema.maxProperties))) {
            return false;
        }
        for (const [key, value] of Object.entries(schema.properties)) {
            if (!IsControlCharacterFree(key))
                return false;
            if (!TSchema(value))
                return false;
        }
        return true;
    }
    TypeGuard.TObject = TObject;
    /** Returns true if the given schema is TPromise */
    function TPromise(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Promise') &&
            schema.type === 'Promise' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.item));
    }
    TypeGuard.TPromise = TPromise;
    /** Returns true if the given schema is TRecord */
    function TRecord(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Record') &&
            schema.type === 'object' &&
            IsOptionalString(schema.$id) &&
            IsAdditionalProperties(schema.additionalProperties) &&
            ValueGuard.IsObject(schema.patternProperties))) {
            return false;
        }
        const keys = Object.getOwnPropertyNames(schema.patternProperties);
        if (keys.length !== 1) {
            return false;
        }
        if (!IsPattern(keys[0])) {
            return false;
        }
        if (!TSchema(schema.patternProperties[keys[0]])) {
            return false;
        }
        return true;
    }
    TypeGuard.TRecord = TRecord;
    /** Returns true if the given schema is TRef */
    function TRef(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Ref') &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsString(schema.$ref));
    }
    TypeGuard.TRef = TRef;
    /** Returns true if the given schema is TString */
    function TString(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'String') &&
            schema.type === 'string' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.minLength) &&
            IsOptionalNumber(schema.maxLength) &&
            IsOptionalPattern(schema.pattern) &&
            IsOptionalFormat(schema.format));
    }
    TypeGuard.TString = TString;
    /** Returns true if the given schema is TSymbol */
    function TSymbol(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Symbol') &&
            schema.type === 'symbol' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TSymbol = TSymbol;
    /** Returns true if the given schema is TTemplateLiteral */
    function TTemplateLiteral(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'TemplateLiteral') &&
            schema.type === 'string' &&
            ValueGuard.IsString(schema.pattern) &&
            schema.pattern[0] === '^' &&
            schema.pattern[schema.pattern.length - 1] === '$');
    }
    TypeGuard.TTemplateLiteral = TTemplateLiteral;
    /** Returns true if the given schema is TThis */
    function TThis(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'This') &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsString(schema.$ref));
    }
    TypeGuard.TThis = TThis;
    /** Returns true if the given schema is TTuple */
    function TTuple(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Tuple') &&
            schema.type === 'array' &&
            IsOptionalString(schema.$id) &&
            ValueGuard.IsNumber(schema.minItems) &&
            ValueGuard.IsNumber(schema.maxItems) &&
            schema.minItems === schema.maxItems)) {
            return false;
        }
        if (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0) {
            return true;
        }
        if (!ValueGuard.IsArray(schema.items)) {
            return false;
        }
        for (const inner of schema.items) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TTuple = TTuple;
    /** Returns true if the given schema is TUndefined */
    function TUndefined(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Undefined') &&
            schema.type === 'undefined' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TUndefined = TUndefined;
    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */
    function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));
    }
    TypeGuard.TUnionLiteral = TUnionLiteral;
    /** Returns true if the given schema is TUnion */
    function TUnion(schema) {
        // prettier-ignore
        if (!(TKindOf(schema, 'Union') &&
            ValueGuard.IsArray(schema.anyOf) &&
            IsOptionalString(schema.$id))) {
            return false;
        }
        for (const inner of schema.anyOf) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TUnion = TUnion;
    /** Returns true if the given schema is TUint8Array */
    function TUint8Array(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Uint8Array') &&
            schema.type === 'Uint8Array' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.minByteLength) &&
            IsOptionalNumber(schema.maxByteLength));
    }
    TypeGuard.TUint8Array = TUint8Array;
    /** Returns true if the given schema is TUnknown */
    function TUnknown(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Unknown') &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TUnknown = TUnknown;
    /** Returns true if the given schema is a raw TUnsafe */
    function TUnsafe(schema) {
        return TKindOf(schema, 'Unsafe');
    }
    TypeGuard.TUnsafe = TUnsafe;
    /** Returns true if the given schema is TVoid */
    function TVoid(schema) {
        // prettier-ignore
        return (TKindOf(schema, 'Void') &&
            schema.type === 'void' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TVoid = TVoid;
    /** Returns true if this schema has the Readonly modifier */
    function TReadonly(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Readonly] === 'Readonly';
    }
    TypeGuard.TReadonly = TReadonly;
    /** Returns true if this schema has the Optional modifier */
    function TOptional(schema) {
        return ValueGuard.IsObject(schema) && schema[exports.Optional] === 'Optional';
    }
    TypeGuard.TOptional = TOptional;
    /** Returns true if the given schema is TSchema */
    function TSchema(schema) {
        return (ValueGuard.IsObject(schema) &&
            (TAny(schema) ||
                TArray(schema) ||
                TBoolean(schema) ||
                TBigInt(schema) ||
                TAsyncIterator(schema) ||
                TConstructor(schema) ||
                TDate(schema) ||
                TFunction(schema) ||
                TInteger(schema) ||
                TIntersect(schema) ||
                TIterator(schema) ||
                TLiteral(schema) ||
                TNever(schema) ||
                TNot(schema) ||
                TNull(schema) ||
                TNumber(schema) ||
                TObject(schema) ||
                TPromise(schema) ||
                TRecord(schema) ||
                TRef(schema) ||
                TString(schema) ||
                TSymbol(schema) ||
                TTemplateLiteral(schema) ||
                TThis(schema) ||
                TTuple(schema) ||
                TUndefined(schema) ||
                TUnion(schema) ||
                TUint8Array(schema) ||
                TUnknown(schema) ||
                TUnsafe(schema) ||
                TVoid(schema) ||
                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));
    }
    TypeGuard.TSchema = TSchema;
})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
// --------------------------------------------------------------------------
// ExtendsUndefined
// --------------------------------------------------------------------------
/** Fast undefined check used for properties of type undefined */
var ExtendsUndefined;
(function (ExtendsUndefined) {
    function Check(schema) {
        if (schema[exports.Kind] === 'Undefined')
            return true;
        if (schema[exports.Kind] === 'Not') {
            return !Check(schema.not);
        }
        if (schema[exports.Kind] === 'Intersect') {
            const intersect = schema;
            return intersect.allOf.every((schema) => Check(schema));
        }
        if (schema[exports.Kind] === 'Union') {
            const union = schema;
            return union.anyOf.some((schema) => Check(schema));
        }
        return false;
    }
    ExtendsUndefined.Check = Check;
})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
// --------------------------------------------------------------------------
// TypeExtends
// --------------------------------------------------------------------------
var TypeExtendsResult;
(function (TypeExtendsResult) {
    TypeExtendsResult[TypeExtendsResult["Union"] = 0] = "Union";
    TypeExtendsResult[TypeExtendsResult["True"] = 1] = "True";
    TypeExtendsResult[TypeExtendsResult["False"] = 2] = "False";
})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
var TypeExtends;
(function (TypeExtends) {
    // --------------------------------------------------------------------------
    // IntoBooleanResult
    // --------------------------------------------------------------------------
    function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // StructuralRight
    // --------------------------------------------------------------------------
    function IsStructuralRight(right) {
        // prettier-ignore
        return (TypeGuard.TNever(right) ||
            TypeGuard.TIntersect(right) ||
            TypeGuard.TUnion(right) ||
            TypeGuard.TUnknown(right) ||
            TypeGuard.TAny(right));
    }
    function StructuralRight(left, right) {
        if (TypeGuard.TNever(right))
            return TNeverRight(left, right);
        if (TypeGuard.TIntersect(right))
            return TIntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return TUnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return TUnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return TAnyRight(left, right);
        throw Error('TypeExtends: StructuralRight');
    }
    // --------------------------------------------------------------------------
    // Any
    // --------------------------------------------------------------------------
    function TAnyRight(left, right) {
        return TypeExtendsResult.True;
    }
    function TAny(left, right) {
        if (TypeGuard.TIntersect(right))
            return TIntersectRight(left, right);
        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))
            return TypeExtendsResult.True;
        if (TypeGuard.TUnion(right))
            return TypeExtendsResult.Union;
        if (TypeGuard.TUnknown(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TAny(right))
            return TypeExtendsResult.True;
        return TypeExtendsResult.Union;
    }
    // --------------------------------------------------------------------------
    // Array
    // --------------------------------------------------------------------------
    function TArrayRight(left, right) {
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        return TypeExtendsResult.False;
    }
    function TArray(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TArray(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
    }
    // --------------------------------------------------------------------------
    // AsyncIterator
    // --------------------------------------------------------------------------
    function TAsyncIterator(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (!TypeGuard.TAsyncIterator(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
    }
    // --------------------------------------------------------------------------
    // BigInt
    // --------------------------------------------------------------------------
    function TBigInt(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Boolean
    // --------------------------------------------------------------------------
    function TBooleanRight(left, right) {
        if (TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const))
            return TypeExtendsResult.True;
        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Constructor
    // --------------------------------------------------------------------------
    function TConstructor(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (!TypeGuard.TConstructor(right))
            return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
            return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
            return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
    }
    // --------------------------------------------------------------------------
    // Date
    // --------------------------------------------------------------------------
    function TDate(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Function
    // --------------------------------------------------------------------------
    function TFunction(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (!TypeGuard.TFunction(right))
            return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
            return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
            return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
    }
    // --------------------------------------------------------------------------
    // Integer
    // --------------------------------------------------------------------------
    function TIntegerRight(left, right) {
        if (TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const))
            return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Intersect
    // --------------------------------------------------------------------------
    function TIntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Iterator
    // --------------------------------------------------------------------------
    function TIterator(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (!TypeGuard.TIterator(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
    }
    // --------------------------------------------------------------------------
    // Literal
    // --------------------------------------------------------------------------
    function TLiteral(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        if (TypeGuard.TString(right))
            return TStringRight(left, right);
        if (TypeGuard.TNumber(right))
            return TNumberRight(left, right);
        if (TypeGuard.TInteger(right))
            return TIntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
            return TBooleanRight(left, right);
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Never
    // --------------------------------------------------------------------------
    function TNeverRight(left, right) {
        return TypeExtendsResult.False;
    }
    function TNever(left, right) {
        return TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // Not
    // --------------------------------------------------------------------------
    function UnwrapTNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
            if (!TypeGuard.TNot(current))
                break;
            current = current.not;
            depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    function TNot(left, right) {
        // TypeScript has no concept of negated types, and attempts to correctly check the negated
        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer
        // the type. Instead we unwrap to either unknown or T and continue evaluating.
        if (TypeGuard.TNot(left))
            return Visit(UnwrapTNot(left), right);
        if (TypeGuard.TNot(right))
            return Visit(left, UnwrapTNot(right));
        throw new Error(`TypeExtends: Invalid fallthrough for Not`);
    }
    // --------------------------------------------------------------------------
    // Null
    // --------------------------------------------------------------------------
    function TNull(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Number
    // --------------------------------------------------------------------------
    function TNumberRight(left, right) {
        if (TypeGuard.TLiteralNumber(left))
            return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Object
    // --------------------------------------------------------------------------
    function IsObjectPropertyCount(schema, count) {
        return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
        // prettier-ignore
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&
            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&
            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));
    }
    function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);
    }
    function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);
    }
    function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);
    }
    // --------------------------------------------------------------------------
    // Property
    // --------------------------------------------------------------------------
    function Property(left, right) {
        if (Visit(left, right) === TypeExtendsResult.False)
            return TypeExtendsResult.False;
        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))
            return TypeExtendsResult.False;
        return TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteralString(left) && IsObjectStringLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TString(left) && IsObjectStringLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TDate(left) && IsObjectDateLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {
            // When expressing a Record with literal key values, the Record is converted into a Object with
            // the Hint assigned as `Record`. This is used to invert the extends logic.
            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {
            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        return TypeExtendsResult.False;
    }
    function TObject(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        if (!TypeGuard.TObject(right))
            return TypeExtendsResult.False;
        for (const key of Object.getOwnPropertyNames(right.properties)) {
            if (!(key in left.properties))
                return TypeExtendsResult.False;
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
            }
        }
        return TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // Promise
    // --------------------------------------------------------------------------
    function TPromise(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TPromise(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.item, right.item));
    }
    // --------------------------------------------------------------------------
    // Record
    // --------------------------------------------------------------------------
    function RecordKey(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
            return exports.Type.Number();
        if (exports.PatternStringExact in schema.patternProperties)
            return exports.Type.String();
        throw Error('TypeExtends: Cannot get record key');
    }
    function RecordValue(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
            return schema.patternProperties[exports.PatternNumberExact];
        if (exports.PatternStringExact in schema.patternProperties)
            return schema.patternProperties[exports.PatternStringExact];
        throw Error('TypeExtends: Cannot get record value');
    }
    function TRecordRight(left, right) {
        const Key = RecordKey(right);
        const Value = RecordValue(right);
        if (TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)
            return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TObject(left)) {
            for (const key of Object.getOwnPropertyNames(left.properties)) {
                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
                    return TypeExtendsResult.False;
                }
            }
            return TypeExtendsResult.True;
        }
        return TypeExtendsResult.False;
    }
    function TRecord(left, right) {
        const Value = RecordValue(left);
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (!TypeGuard.TRecord(right))
            return TypeExtendsResult.False;
        return Visit(Value, RecordValue(right));
    }
    // --------------------------------------------------------------------------
    // String
    // --------------------------------------------------------------------------
    function TStringRight(left, right) {
        if (TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const))
            return TypeExtendsResult.True;
        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Symbol
    // --------------------------------------------------------------------------
    function TSymbol(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // TemplateLiteral
    // --------------------------------------------------------------------------
    function TTemplateLiteral(left, right) {
        // TemplateLiteral types are resolved to either unions for finite expressions or string
        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for
        // either type and continue evaluating.
        if (TypeGuard.TTemplateLiteral(left))
            return Visit(TemplateLiteralResolver.Resolve(left), right);
        if (TypeGuard.TTemplateLiteral(right))
            return Visit(left, TemplateLiteralResolver.Resolve(right));
        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);
    }
    // --------------------------------------------------------------------------
    // Tuple
    // --------------------------------------------------------------------------
    function IsArrayOfTuple(left, right) {
        // prettier-ignore
        return (TypeGuard.TArray(right) &&
            left.items !== undefined &&
            left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True));
    }
    function TTupleRight(left, right) {
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        return TypeExtendsResult.False;
    }
    function TTuple(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TTuple(right))
            return TypeExtendsResult.False;
        if ((ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)))
            return TypeExtendsResult.False;
        if (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items))
            return TypeExtendsResult.True;
        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Uint8Array
    // --------------------------------------------------------------------------
    function TUint8Array(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Undefined
    // --------------------------------------------------------------------------
    function TUndefined(left, right) {
        if (IsStructuralRight(right))
            return StructuralRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return TRecordRight(left, right);
        if (TypeGuard.TVoid(right))
            return VoidRight(left, right);
        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Union
    // --------------------------------------------------------------------------
    function TUnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Unknown
    // --------------------------------------------------------------------------
    function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
    }
    function TUnknown(left, right) {
        if (TypeGuard.TNever(right))
            return TNeverRight(left, right);
        if (TypeGuard.TIntersect(right))
            return TIntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return TUnionRight(left, right);
        if (TypeGuard.TAny(right))
            return TAnyRight(left, right);
        if (TypeGuard.TString(right))
            return TStringRight(left, right);
        if (TypeGuard.TNumber(right))
            return TNumberRight(left, right);
        if (TypeGuard.TInteger(right))
            return TIntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
            return TBooleanRight(left, right);
        if (TypeGuard.TArray(right))
            return TArrayRight(left, right);
        if (TypeGuard.TTuple(right))
            return TTupleRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Void
    // --------------------------------------------------------------------------
    function VoidRight(left, right) {
        if (TypeGuard.TUndefined(left))
            return TypeExtendsResult.True;
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid(left, right) {
        if (TypeGuard.TIntersect(right))
            return TIntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return TUnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return TUnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return TAnyRight(left, right);
        if (TypeGuard.TObject(right))
            return TObjectRight(left, right);
        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit(left, right) {
        // Resolvable Types
        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))
            return TTemplateLiteral(left, right);
        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))
            return TNot(left, right);
        // Standard Types
        if (TypeGuard.TAny(left))
            return TAny(left, right);
        if (TypeGuard.TArray(left))
            return TArray(left, right);
        if (TypeGuard.TBigInt(left))
            return TBigInt(left, right);
        if (TypeGuard.TBoolean(left))
            return TBoolean(left, right);
        if (TypeGuard.TAsyncIterator(left))
            return TAsyncIterator(left, right);
        if (TypeGuard.TConstructor(left))
            return TConstructor(left, right);
        if (TypeGuard.TDate(left))
            return TDate(left, right);
        if (TypeGuard.TFunction(left))
            return TFunction(left, right);
        if (TypeGuard.TInteger(left))
            return TInteger(left, right);
        if (TypeGuard.TIntersect(left))
            return TIntersect(left, right);
        if (TypeGuard.TIterator(left))
            return TIterator(left, right);
        if (TypeGuard.TLiteral(left))
            return TLiteral(left, right);
        if (TypeGuard.TNever(left))
            return TNever(left, right);
        if (TypeGuard.TNull(left))
            return TNull(left, right);
        if (TypeGuard.TNumber(left))
            return TNumber(left, right);
        if (TypeGuard.TObject(left))
            return TObject(left, right);
        if (TypeGuard.TRecord(left))
            return TRecord(left, right);
        if (TypeGuard.TString(left))
            return TString(left, right);
        if (TypeGuard.TSymbol(left))
            return TSymbol(left, right);
        if (TypeGuard.TTuple(left))
            return TTuple(left, right);
        if (TypeGuard.TPromise(left))
            return TPromise(left, right);
        if (TypeGuard.TUint8Array(left))
            return TUint8Array(left, right);
        if (TypeGuard.TUndefined(left))
            return TUndefined(left, right);
        if (TypeGuard.TUnion(left))
            return TUnion(left, right);
        if (TypeGuard.TUnknown(left))
            return TUnknown(left, right);
        if (TypeGuard.TVoid(left))
            return TVoid(left, right);
        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
    }
    function Extends(left, right) {
        return Visit(left, right);
    }
    TypeExtends.Extends = Extends;
})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
// --------------------------------------------------------------------------
// TypeClone
// --------------------------------------------------------------------------
/** Specialized Clone for Types */
var TypeClone;
(function (TypeClone) {
    function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        return { ...clonedProperties, ...clonedSymbols };
    }
    function ArrayType(value) {
        return value.map((value) => Visit(value));
    }
    function Visit(value) {
        if (ValueGuard.IsArray(value))
            return ArrayType(value);
        if (ValueGuard.IsObject(value))
            return ObjectType(value);
        return value;
    }
    /** Clones a type. */
    function Clone(schema, options = {}) {
        return { ...Visit(schema), ...options };
    }
    TypeClone.Clone = Clone;
})(TypeClone || (exports.TypeClone = TypeClone = {}));
// --------------------------------------------------------------------------
// IndexedAccessor
// --------------------------------------------------------------------------
var IndexedAccessor;
(function (IndexedAccessor) {
    function OptionalUnwrap(schema) {
        return schema.map((schema) => {
            const { [exports.Optional]: _, ...clone } = TypeClone.Clone(schema);
            return clone;
        });
    }
    function IsIntersectOptional(schema) {
        return schema.every((schema) => TypeGuard.TOptional(schema));
    }
    function IsUnionOptional(schema) {
        return schema.some((schema) => TypeGuard.TOptional(schema));
    }
    function ResolveIntersect(schema) {
        const optional = IsIntersectOptional(schema.allOf);
        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    function ResolveUnion(schema) {
        const optional = IsUnionOptional(schema.anyOf);
        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    function ResolveOptional(schema) {
        if (schema[exports.Kind] === 'Intersect')
            return ResolveIntersect(schema);
        if (schema[exports.Kind] === 'Union')
            return ResolveUnion(schema);
        return schema;
    }
    function TIntersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema) => {
            const indexed = Visit(schema, key);
            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
    }
    function TUnion(schema, key) {
        const resolved = schema.anyOf.map((schema) => Visit(schema, key));
        return ResolveOptional(exports.Type.Union(resolved));
    }
    function TObject(schema, key) {
        const property = schema.properties[key];
        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    function TTuple(schema, key) {
        const items = schema.items;
        if (ValueGuard.IsUndefined(items))
            return exports.Type.Never();
        const element = items[key]; //
        if (ValueGuard.IsUndefined(element))
            return exports.Type.Never();
        return element;
    }
    function Visit(schema, key) {
        if (schema[exports.Kind] === 'Intersect')
            return TIntersect(schema, key);
        if (schema[exports.Kind] === 'Union')
            return TUnion(schema, key);
        if (schema[exports.Kind] === 'Object')
            return TObject(schema, key);
        if (schema[exports.Kind] === 'Tuple')
            return TTuple(schema, key);
        return exports.Type.Never();
    }
    function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
    }
    IndexedAccessor.Resolve = Resolve;
})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
// --------------------------------------------------------------------------
// Intrinsic
// --------------------------------------------------------------------------
var Intrinsic;
(function (Intrinsic) {
    function Uncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value) {
        return value.toUpperCase();
    }
    function Lowercase(value) {
        return value.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema, mode) {
        // note: template literals require special runtime handling as they are encoded in string patterns.
        // This diverges from the mapped type which would otherwise map on the template literal kind.
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
            return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports.Type.Union(mapped);
        return exports.Type.TemplateLiteral([union]);
    }
    function IntrinsicLiteral(value, mode) {
        // prettier-ignore
        return typeof value === 'string' ? (mode === 'Uncapitalize' ? Uncapitalize(value) :
            mode === 'Capitalize' ? Capitalize(value) :
                mode === 'Uppercase' ? Uppercase(value) :
                    mode === 'Lowercase' ? Lowercase(value) :
                        value) : value.toString();
    }
    function IntrinsicRest(schema, mode) {
        if (schema.length === 0)
            return [];
        const [L, ...R] = schema;
        return [Map(L, mode), ...IntrinsicRest(R, mode)];
    }
    function Visit(schema, mode) {
        if (TypeGuard.TTemplateLiteral(schema))
            return IntrinsicTemplateLiteral(schema, mode);
        if (TypeGuard.TUnion(schema))
            return exports.Type.Union(IntrinsicRest(schema.anyOf, mode));
        if (TypeGuard.TLiteral(schema))
            return exports.Type.Literal(IntrinsicLiteral(schema.const, mode));
        return schema;
    }
    /** Applies an intrinsic string manipulation to the given type. */
    function Map(schema, mode) {
        return Visit(schema, mode);
    }
    Intrinsic.Map = Map;
})(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
// --------------------------------------------------------------------------
// ObjectMap
// --------------------------------------------------------------------------
var ObjectMap;
(function (ObjectMap) {
    function TIntersect(schema, callback) {
        // prettier-ignore
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TUnion(schema, callback) {
        // prettier-ignore
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TObject(schema, callback) {
        return callback(schema);
    }
    function Visit(schema, callback) {
        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would
        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the
        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only
        // used for composition, we use explicit checks instead.
        if (schema[exports.Kind] === 'Intersect')
            return TIntersect(schema, callback);
        if (schema[exports.Kind] === 'Union')
            return TUnion(schema, callback);
        if (schema[exports.Kind] === 'Object')
            return TObject(schema, callback);
        return schema;
    }
    function Map(schema, callback, options) {
        return { ...Visit(TypeClone.Clone(schema), callback), ...options };
    }
    ObjectMap.Map = Map;
})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
var KeyResolver;
(function (KeyResolver) {
    function UnwrapPattern(key) {
        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect(schema, options) {
        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);
    }
    function TUnion(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];
    }
    function TObject(schema, options) {
        return Object.getOwnPropertyNames(schema.properties);
    }
    function TRecord(schema, options) {
        return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    function Visit(schema, options) {
        if (TypeGuard.TIntersect(schema))
            return TIntersect(schema, options);
        if (TypeGuard.TUnion(schema))
            return TUnion(schema, options);
        if (TypeGuard.TObject(schema))
            return TObject(schema, options);
        if (TypeGuard.TRecord(schema))
            return TRecord(schema, options);
        return [];
    }
    /** Resolves an array of keys in this schema */
    function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
    }
    KeyResolver.ResolveKeys = ResolveKeys;
    /** Resolves a regular expression pattern matching all keys in this schema */
    function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join('|')})$`;
    }
    KeyResolver.ResolvePattern = ResolvePattern;
})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
// --------------------------------------------------------------------------
// KeyArrayResolver
// --------------------------------------------------------------------------
var KeyArrayResolver;
(function (KeyArrayResolver) {
    /** Resolves an array of string[] keys from the given schema or array type. */
    function Resolve(schema) {
        if (Array.isArray(schema))
            return schema;
        if (TypeGuard.TUnionLiteral(schema))
            return schema.anyOf.map((schema) => schema.const.toString());
        if (TypeGuard.TLiteral(schema))
            return [schema.const];
        if (TypeGuard.TTemplateLiteral(schema)) {
            const expression = TemplateLiteralParser.ParseExact(schema.pattern);
            if (!TemplateLiteralFinite.Check(expression))
                throw Error('KeyArrayResolver: Cannot resolve keys from infinite template expression');
            return [...TemplateLiteralGenerator.Generate(expression)];
        }
        return [];
    }
    KeyArrayResolver.Resolve = Resolve;
})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
// --------------------------------------------------------------------------
// UnionResolver
// --------------------------------------------------------------------------
var UnionResolver;
(function (UnionResolver) {
    function* TUnion(union) {
        for (const schema of union.anyOf) {
            if (schema[exports.Kind] === 'Union') {
                yield* TUnion(schema);
            }
            else {
                yield schema;
            }
        }
    }
    /** Returns a resolved union with interior unions flattened */
    function Resolve(union) {
        return exports.Type.Union([...TUnion(union)], { ...union });
    }
    UnionResolver.Resolve = Resolve;
})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
// --------------------------------------------------------------------------
// TemplateLiteralPattern
// --------------------------------------------------------------------------
var TemplateLiteralPattern;
(function (TemplateLiteralPattern) {
    function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function Visit(schema, acc) {
        if (TypeGuard.TTemplateLiteral(schema)) {
            return schema.pattern.slice(1, schema.pattern.length - 1);
        }
        else if (TypeGuard.TUnion(schema)) {
            return `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})`;
        }
        else if (TypeGuard.TNumber(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TInteger(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TBigInt(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TString(schema)) {
            return `${acc}${exports.PatternString}`;
        }
        else if (TypeGuard.TLiteral(schema)) {
            return `${acc}${Escape(schema.const.toString())}`;
        }
        else if (TypeGuard.TBoolean(schema)) {
            return `${acc}${exports.PatternBoolean}`;
        }
        else if (TypeGuard.TNever(schema)) {
            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');
        }
        else {
            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
        }
    }
    function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\$`;
    }
    TemplateLiteralPattern.Create = Create;
})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralResolver
// --------------------------------------------------------------------------------------
var TemplateLiteralResolver;
(function (TemplateLiteralResolver) {
    /** Resolves a template literal as a TUnion */
    function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
            return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
    }
    TemplateLiteralResolver.Resolve = Resolve;
})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralParser
// --------------------------------------------------------------------------------------
class TemplateLiteralParserError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.TemplateLiteralParserError = TemplateLiteralParserError;
var TemplateLiteralParser;
(function (TemplateLiteralParser) {
    function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, '(');
    }
    function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ')');
    }
    function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, '|');
    }
    function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
            return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (count === 0 && index !== pattern.length - 1)
                return false;
        }
        return true;
    }
    function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0)
                return true;
        }
        return false;
    }
    function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                return true;
        }
        return false;
    }
    function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0) {
                const range = pattern.slice(start, index);
                if (range.length > 0)
                    expressions.push(Parse(range));
                start = index + 1;
            }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
            expressions.push(Parse(range));
        if (expressions.length === 0)
            return { type: 'const', const: '' };
        if (expressions.length === 1)
            return expressions[0];
        return { type: 'or', expr: expressions };
    }
    function And(pattern) {
        function Group(value, index) {
            if (!IsOpenParen(value, index))
                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
            let count = 0;
            for (let scan = index; scan < value.length; scan++) {
                if (IsOpenParen(value, scan))
                    count += 1;
                if (IsCloseParen(value, scan))
                    count -= 1;
                if (count === 0)
                    return [index, scan];
            }
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern, index) {
            for (let scan = index; scan < pattern.length; scan++) {
                if (IsOpenParen(pattern, scan))
                    return [index, scan];
            }
            return [index, pattern.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index)) {
                const [start, end] = Group(pattern, index);
                const range = pattern.slice(start, end + 1);
                expressions.push(Parse(range));
                index = end;
            }
            else {
                const [start, end] = Range(pattern, index);
                const range = pattern.slice(start, end);
                if (range.length > 0)
                    expressions.push(Parse(range));
                index = end - 1;
            }
        }
        if (expressions.length === 0)
            return { type: 'const', const: '' };
        if (expressions.length === 1)
            return expressions[0];
        return { type: 'and', expr: expressions };
    }
    /** Parses a pattern and returns an expression tree */
    function Parse(pattern) {
        if (IsGroup(pattern))
            return Parse(InGroup(pattern));
        if (IsPrecedenceOr(pattern))
            return Or(pattern);
        if (IsPrecedenceAnd(pattern))
            return And(pattern);
        return { type: 'const', const: pattern };
    }
    TemplateLiteralParser.Parse = Parse;
    /** Parses a pattern and strips forward and trailing ^ and $ */
    function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
    }
    TemplateLiteralParser.ParseExact = ParseExact;
})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralFinite
// --------------------------------------------------------------------------------------
var TemplateLiteralFinite;
(function (TemplateLiteralFinite) {
    function IsNumber(expression) {
        // prettier-ignore
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === '0' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === '[1-9][0-9]*');
    }
    function IsBoolean(expression) {
        // prettier-ignore
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === 'true' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === 'false');
    }
    function IsString(expression) {
        return expression.type === 'const' && expression.const === '.*';
    }
    function Check(expression) {
        if (IsBoolean(expression))
            return true;
        if (IsNumber(expression) || IsString(expression))
            return false;
        if (expression.type === 'and')
            return expression.expr.every((expr) => Check(expr));
        if (expression.type === 'or')
            return expression.expr.every((expr) => Check(expr));
        if (expression.type === 'const')
            return true;
        throw Error(`TemplateLiteralFinite: Unknown expression type`);
    }
    TemplateLiteralFinite.Check = Check;
})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralGenerator
// --------------------------------------------------------------------------------------
var TemplateLiteralGenerator;
(function (TemplateLiteralGenerator) {
    function* Reduce(buffer) {
        if (buffer.length === 1)
            return yield* buffer[0];
        for (const left of buffer[0]) {
            for (const right of Reduce(buffer.slice(1))) {
                yield `${left}${right}`;
            }
        }
    }
    function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
        for (const expr of expression.expr)
            yield* Generate(expr);
    }
    function* Const(expression) {
        return yield expression.const;
    }
    function* Generate(expression) {
        if (expression.type === 'and')
            return yield* And(expression);
        if (expression.type === 'or')
            return yield* Or(expression);
        if (expression.type === 'const')
            return yield* Const(expression);
        throw Error('TemplateLiteralGenerator: Unknown expression');
    }
    TemplateLiteralGenerator.Generate = Generate;
})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
// ---------------------------------------------------------------------
// TemplateLiteralDslParser
// ---------------------------------------------------------------------
var TemplateLiteralDslParser;
(function (TemplateLiteralDslParser) {
    function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, '');
        if (trim === 'boolean')
            return yield exports.Type.Boolean();
        if (trim === 'number')
            return yield exports.Type.Number();
        if (trim === 'bigint')
            return yield exports.Type.BigInt();
        if (trim === 'string')
            return yield exports.Type.String();
        const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));
        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
    }
    function* ParseTerminal(template) {
        if (template[1] !== '{') {
            const L = exports.Type.Literal('$');
            const R = ParseLiteral(template.slice(1));
            return yield* [L, ...R];
        }
        for (let i = 2; i < template.length; i++) {
            if (template[i] === '}') {
                const L = ParseUnion(template.slice(2, i));
                const R = ParseLiteral(template.slice(i + 1));
                return yield* [...L, ...R];
            }
        }
        yield exports.Type.Literal(template);
    }
    function* ParseLiteral(template) {
        for (let i = 0; i < template.length; i++) {
            if (template[i] === '$') {
                const L = exports.Type.Literal(template.slice(0, i));
                const R = ParseTerminal(template.slice(i));
                return yield* [L, ...R];
            }
        }
        yield exports.Type.Literal(template);
    }
    function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser.Parse = Parse;
})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
// --------------------------------------------------------------------------
// TypeOrdinal: Used for auto $id generation
// --------------------------------------------------------------------------
let TypeOrdinal = 0;
// --------------------------------------------------------------------------
// TypeBuilder
// --------------------------------------------------------------------------
class TypeBuilder {
    /** `[Utility]` Creates a schema without `static` and `params` types */
    Create(schema) {
        return schema;
    }
    /** `[Utility]` Discards a property key from the given schema */
    Discard(schema, key) {
        const { [key]: _, ...rest } = schema;
        return rest;
    }
    /** `[Standard]` Omits compositing symbols from this schema */
    Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
    }
}
exports.TypeBuilder = TypeBuilder;
// --------------------------------------------------------------------------
// StandardTypeBuilder
// --------------------------------------------------------------------------
class StandardTypeBuilder extends TypeBuilder {
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Standard]` Creates a Readonly and Optional property */
    ReadonlyOptional(schema) {
        return this.Readonly(this.Optional(schema));
    }
    /** `[Standard]` Creates a Readonly property */
    Readonly(schema) {
        return { ...TypeClone.Clone(schema), [exports.Readonly]: 'Readonly' };
    }
    /** `[Standard]` Creates an Optional property */
    Optional(schema) {
        return { ...TypeClone.Clone(schema), [exports.Optional]: 'Optional' };
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Standard]` Creates an Any type */
    Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Any' });
    }
    /** `[Standard]` Creates an Array type */
    Array(schema, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(schema) });
    }
    /** `[Standard]` Creates a Boolean type */
    Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });
    }
    /** `[Standard]` Intrinsic function to Capitalize LiteralString types */
    Capitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Capitalize'), ...options };
    }
    /** `[Standard]` Creates a Composite object type */
    Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
    }
    /** `[Standard]` Creates a Enum type */
    Enum(item, options = {}) {
        // prettier-ignore
        const values = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const anyOf = values.map((value) => (ValueGuard.IsString(value) ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));
        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });
    }
    /** `[Standard]` Creates a Conditional type */
    Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
            case TypeExtendsResult.Union:
                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
            case TypeExtendsResult.True:
                return TypeClone.Clone(trueType, options);
            case TypeExtendsResult.False:
                return TypeClone.Clone(falseType, options);
        }
    }
    /** `[Standard]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude(unionType, excludedMembers, options = {}) {
        if (TypeGuard.TTemplateLiteral(unionType))
            return this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options);
        if (TypeGuard.TTemplateLiteral(excludedMembers))
            return this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options);
        if (TypeGuard.TUnion(unionType)) {
            const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));
        }
        else {
            return (TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(unionType, options));
        }
    }
    /** `[Standard]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract(type, union, options = {}) {
        if (TypeGuard.TTemplateLiteral(type))
            return this.Extract(TemplateLiteralResolver.Resolve(type), union, options);
        if (TypeGuard.TTemplateLiteral(union))
            return this.Extract(type, TemplateLiteralResolver.Resolve(union), options);
        if (TypeGuard.TUnion(type)) {
            const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));
        }
        else {
            return (TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Clone(type, options) : this.Never(options));
        }
    }
    /** `[Standard]` Returns an Indexed property type for the given keys */
    Index(schema, unresolved, options = {}) {
        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {
            return TypeClone.Clone(schema.items, options);
        }
        else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const cloned = items.map((schema) => TypeClone.Clone(schema));
            return this.Union(cloned, options);
        }
        else {
            const keys = KeyArrayResolver.Resolve(unresolved);
            const clone = TypeClone.Clone(schema);
            return IndexedAccessor.Resolve(clone, keys, options);
        }
    }
    /** `[Standard]` Creates an Integer type */
    Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });
    }
    /** `[Standard]` Creates an Intersect type */
    Intersect(allOf, options = {}) {
        if (allOf.length === 0)
            return exports.Type.Never();
        if (allOf.length === 1)
            return TypeClone.Clone(allOf[0], options);
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = allOf.map((schema) => TypeClone.Clone(schema));
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties) } : {};
        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {
            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });
        }
        else {
            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });
        }
    }
    /** `[Standard]` Creates a KeyOf type */
    KeyOf(schema, options = {}) {
        if (TypeGuard.TRecord(schema)) {
            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
            if (pattern === exports.PatternNumberExact)
                return this.Number(options);
            if (pattern === exports.PatternStringExact)
                return this.String(options);
            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');
        }
        else if (TypeGuard.TTuple(schema)) {
            const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
            const literals = items.map((_, index) => exports.Type.Literal(index));
            return this.Union(literals, options);
        }
        else if (TypeGuard.TArray(schema)) {
            return this.Number(options);
        }
        else {
            const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
            if (keys.length === 0)
                return this.Never(options);
            const literals = keys.map((key) => this.Literal(key));
            return this.Union(literals, options);
        }
    }
    /** `[Standard]` Creates a Literal type */
    Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });
    }
    /** `[Standard]` Intrinsic function to Lowercase LiteralString types */
    Lowercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Lowercase'), ...options };
    }
    /** `[Standard]` Creates a Never type */
    Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });
    }
    /** `[Standard]` Creates a Not type */
    Not(schema, options) {
        return this.Create({ ...options, [exports.Kind]: 'Not', not: TypeClone.Clone(schema) });
    }
    /** `[Standard]` Creates a Null type */
    Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });
    }
    /** `[Standard]` Creates a Number type */
    Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });
    }
    /** `[Standard]` Creates an Object type */
    Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key]) }), {});
        if (requiredKeys.length > 0) {
            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });
        }
        else {
            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });
        }
    }
    /** `[Standard]` Constructs a type whose keys are omitted from the given type */
    Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema), (object) => {
            if (ValueGuard.IsArray(object.required)) {
                object.required = object.required.filter((key) => !keys.includes(key));
                if (object.required.length === 0)
                    delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
                if (keys.includes(key))
                    delete object.properties[key];
            }
            return this.Create(object);
        }, options);
    }
    /** `[Standard]` Constructs a type where all properties are optional */
    Partial(schema, options = {}) {
        // prettier-ignore
        return ObjectMap.Map(schema, (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
                return { ...acc, [key]: this.Optional(object.properties[key]) };
            }, {});
            return this.Object(properties, this.Discard(object, 'required') /* object used as options to retain other constraints */);
        }, options);
    }
    /** `[Standard]` Constructs a type whose keys are picked from the given type */
    Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema), (object) => {
            if (ValueGuard.IsArray(object.required)) {
                object.required = object.required.filter((key) => keys.includes(key));
                if (object.required.length === 0)
                    delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
                if (!keys.includes(key))
                    delete object.properties[key];
            }
            return this.Create(object);
        }, options);
    }
    /** `[Standard]` Creates a Record type */
    Record(key, schema, options = {}) {
        if (TypeGuard.TTemplateLiteral(key)) {
            const expression = TemplateLiteralParser.ParseExact(key.pattern);
            // prettier-ignore
            return TemplateLiteralFinite.Check(expression)
                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema) }), {}), options))
                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema) } });
        }
        else if (TypeGuard.TUnion(key)) {
            const union = UnionResolver.Resolve(key);
            if (TypeGuard.TUnionLiteral(union)) {
                const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema) }), {});
                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });
            }
            else
                throw Error('StandardTypeBuilder: Record key of type union contains non-literal types');
        }
        else if (TypeGuard.TLiteral(key)) {
            if (ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const)) {
                return this.Object({ [key.const]: TypeClone.Clone(schema) }, options);
            }
            else
                throw Error('StandardTypeBuilder: Record key of type literal is not of type string or number');
        }
        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {
            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [exports.PatternNumberExact]: TypeClone.Clone(schema) } });
        }
        else if (TypeGuard.TString(key)) {
            const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema) } });
        }
        else {
            throw Error(`StandardTypeBuilder: Record key is an invalid type`);
        }
    }
    /** `[Standard]` Creates a Recursive type */
    Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
            options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });
    }
    /** `[Standard]` Creates a Ref type. */
    Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
            return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved });
        if (ValueGuard.IsUndefined(unresolved.$id))
            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');
        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: unresolved.$id });
    }
    /** `[Standard]` Constructs a type where all properties are required */
    Required(schema, options = {}) {
        // prettier-ignore
        return ObjectMap.Map(schema, (object) => {
            const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
                return { ...acc, [key]: this.Discard(object.properties[key], exports.Optional) };
            }, {});
            return this.Object(properties, object /* object used as options to retain other constraints  */);
        }, options);
    }
    /** `[Standard]` Extracts the rest array from a Tuple */
    Rest(schema) {
        if (TypeGuard.TTuple(schema)) {
            if (ValueGuard.IsUndefined(schema.items))
                return [];
            return schema.items.map((schema) => TypeClone.Clone(schema));
        }
        else {
            return [TypeClone.Clone(schema)];
        }
    }
    /** `[Standard]` Creates a String type */
    String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });
    }
    /** `[Standard]` Creates a TemplateLiteral type */
    TemplateLiteral(unresolved, options = {}) {
        // prettier-ignore
        const pattern = (ValueGuard.IsString(unresolved))
            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))
            : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });
    }
    /** `[Standard]` Creates a Tuple type */
    Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = items.map((item) => TypeClone.Clone(item));
        // prettier-ignore
        const schema = (items.length > 0 ?
            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :
            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });
        return this.Create(schema);
    }
    /** `[Standard]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Uncapitalize'), ...options };
    }
    /** `[Standard]` Creates a Union type */
    Union(union, options = {}) {
        if (TypeGuard.TTemplateLiteral(union)) {
            return TemplateLiteralResolver.Resolve(union);
        }
        else {
            const anyOf = union;
            if (anyOf.length === 0)
                return this.Never(options);
            if (anyOf.length === 1)
                return this.Create(TypeClone.Clone(anyOf[0], options));
            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema));
            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });
        }
    }
    /** `[Standard]` Creates an Unknown type */
    Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Unknown' });
    }
    /** `[Standard]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });
    }
    /** `[Standard]` Intrinsic function to Uppercase LiteralString types */
    Uppercase(schema, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Clone(schema), 'Uppercase'), ...options };
    }
}
exports.StandardTypeBuilder = StandardTypeBuilder;
// --------------------------------------------------------------------------
// ExtendedTypeBuilder
// --------------------------------------------------------------------------
class ExtendedTypeBuilder extends StandardTypeBuilder {
    /** `[Extended]` Creates a AsyncIterator type */
    AsyncIterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'AsyncIterator', type: 'AsyncIterator', items: TypeClone.Clone(items) });
    }
    /** `[Extended]` Constructs a type by recursively unwrapping Promise types */
    Awaited(schema, options = {}) {
        const AwaitedRest = (rest) => {
            if (rest.length === 0)
                return rest;
            const [L, ...R] = rest;
            return [this.Awaited(L), ...AwaitedRest(R)];
        };
        // prettier-ignore
        return (TypeGuard.TIntersect(schema) ? exports.Type.Intersect(AwaitedRest(schema.allOf)) :
            TypeGuard.TUnion(schema) ? exports.Type.Union(AwaitedRest(schema.anyOf)) :
                TypeGuard.TPromise(schema) ? this.Awaited(schema.item) :
                    TypeClone.Clone(schema, options));
    }
    /** `[Extended]` Creates a BigInt type */
    BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'bigint' });
    }
    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
    }
    /** `[Extended]` Creates a Constructor type */
    Constructor(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns);
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter));
        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'constructor', parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[Extended]` Creates a Date type */
    Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'Date' });
    }
    /** `[Extended]` Creates a Function type */
    Function(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter));
        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'function', parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[Extended]` Extracts the InstanceType from the given Constructor type */
    InstanceType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
    }
    /** `[Extended]` Creates an Iterator type */
    Iterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Iterator', type: 'Iterator', items: TypeClone.Clone(items) });
    }
    /** `[Extended]` Extracts the Parameters from the given Function type */
    Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
    }
    /** `[Extended]` Creates a Promise type */
    Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'Promise', item: TypeClone.Clone(item) });
    }
    /** `[Extended]` Creates a String type */
    RegExp(unresolved, options = {}) {
        const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern });
    }
    /**
     * @deprecated Use `Type.RegExp`
     */
    RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
    }
    /** `[Extended]` Extracts the ReturnType from the given Function type */
    ReturnType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
    }
    /** `[Extended]` Creates a Symbol type */
    Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'symbol' });
    }
    /** `[Extended]` Creates a Undefined type */
    Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'undefined' });
    }
    /** `[Extended]` Creates a Uint8Array type */
    Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'Uint8Array' });
    }
    /** `[Extended]` Creates a Void type */
    Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'void' });
    }
}
exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
/** JSON Schema Type Builder with Static Resolution for TypeScript */
exports.StandardType = new StandardTypeBuilder();
/** JSON Schema Type Builder with Static Resolution for TypeScript */
exports.Type = new ExtendedTypeBuilder();
